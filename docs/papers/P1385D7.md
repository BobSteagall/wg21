---
geometry:
  - left=0.75in
  - right=0.75in
  - top=0.75in
  - bottom=0.75in
  - headheight=0.25in
  - footskip=0.3in
title: "A proposal to add linear algebra support to the C++ standard library"
document: P1385D7 (Draft)
date: 2020-06-09
audience: LEWG
author:
  - name:  Guy Davidson
    email: <guy@hatcat.com>
  - name:  Bob Steagall
    email: <bob.steagall.cpp@gmail.com>
toc: true
toc-depth: 2
---

# Abstract{.unnumbered}

This document proposes a set of fundamental linear algebra types and functions 
for the standard C++ library.  The facilities described herein are pure addtions,
requiring no changes to existing implementations.

\newpage

# Introduction

Linear algebra is a mathematical discipline of ever-increasing importance, 
with direct application to a wide variety of problem domains, such as signal 
processing, computer graphics, medical imaging, scientific simulations, 
machine learning, analytics, financial modeling, and high-performance 
computing.  And yet, despite the relevance of linear algebra to so many 
aspects of modern computing, the C++ standard library does not include a 
set of linear algebra facilities. This paper proposes to remedy this deficit 
for C++23.

The authors advise that this paper be read after P1166, in which we describe 
a high-level set of expectations for what a linear algebra library should contain.


# Revision history

## P1385R0: Initial version 

Sent in pre-Kona 2019 mailing.


## P1385D1: Update for presentation at Kona 2019

Draft version D1 of this paper was reviewed by LEWG(I) and a joint session of SG14 
and SG19.  Both reviews were generally positive, several good suggestions were made, 
and some polls regarding future directions were taken.

### LEWG(I) session polls and feedback [Wednesday 2019-02-20](http://wiki.edg.com/bin/view/Wg21kona2019/P1385)

**Poll**: We want 0-based indexing as opposed to 1-based indexing. (20 present)

-----------
 Unanimous
-----------

**Poll**: We like having separate row_vector and column_vector types in addition 
to `matrix`.  (21 present) 

  SF    F     N     A     SA
----- ----- ----- ----- ----- -------------
  3     0     5     4     4    (consensus)

**Poll**: We want explicitly named operations (e.g., dot and outer) in addition 
to operators.  (21 present) 

  SF    F     N     A     SA
----- ----- ----- ----- ----- -------------
  8     5     2     1     0    (consensus)

**Poll**: Define engine/matrix classes in terms of mdspan + storage and mdspan 
concepts (e.g., extents), and expose an mdspan-esque interface.  This implies 
that fs_ and dyn_ are combined into one template parametrized on extents (which 
are either static or dynamic).  (22 present) 

  SF    F     N     A     SA
----- ----- ----- ----- ----- -------------
  6     2     7     0     0    (consensus)

There were a few additional requests:

- Provide some implementation and usage experience.

- Provide a comparison with prior art.

- Explore the re-usability of `mdspan` and `common_type`.

- Be careful of allowing specializations of traits types that are part of 
namespace `std`; be consistent with other traits.

### Joint SG14/SG19 session feedback [Friday 2019-02-22](http://wiki.edg.com/bin/view/Wg21kona2019/SG14MinutesP1385)

No polls were taken in this session, but there were some requests:

- Stick to 0-based indexing, for compatibility with current practice, and 
also for performance reasons.

- In this session, there was very broad agreement that the one-vector 
approach advocated by LEWG(I) was the way to proceed.

- Outer product computation is rare in practice, so, the vector-vector 
multiplication operator should return the inner product, and the outer 
product should be a named function.

### Other Suggestions Gathered at the Meeting

- Experiment with executors for concurrent operations.

- Include an "audience table" (see [P1362R0](http://wg21.link/p1362r0), 
Section 4.4)  showing feature levels and anticipated user sophistication 
foreach.

- Include tutorial material on how the library can be used and extended, with 
several illustrative examples.


## P1385R1: Update for post-Kona 2019 mailing

Includes feedback from LEWG(I) and joint SG14/SG19 session. 


## P1385R2: Update for Cologne 2019 meeting

Includes feedback from Kona and monthly SIG conference calls.

- Emphasized proposed `std::math` namespace

- Replaced `row_vector` and `column_vector` types with a single `vector` type 
to represent both.

- Removed discussion regarding 0-based or 1-based indexing in favor of 0-based.

- Reduced number of customization points within namespace `std` to two.

## P1385D3: Draft update for Cologne 2019 meeting.

This is a last-minute update prior to review in order to remove erroneous 
references to   `row_vector` and `column_vector` in the R2 text.

### Joint SG14/SG19/SG6 session feedback Friday 2019-07-20 [morning](http://wiki.edg.com/bin/view/Wg21cologne2019/SG6P1385R2) and [afternoon](http://wiki.edg.com/bin/view/Wg21cologne2019/SG14LA)

At the Cologne 2019 meeting, a joint session of SG14, SG19, and SG6 was held on 
Friday 20-Jul-2019 and version D3 of this paper was presented.  A vote was held 
in the afternoon, and the room reached consensus to forward P1385 to LEWG subject 
to reconciling implementation with P1673.

**Poll**: Forward P1385 to LEWG subject to reconciling implementation with 1673.                     

  SF    F     N     A     SA
----- ----- ----- ----- ----- -------------
  9     4     9     2     2    (consensus)

In the intervening months, the authors of P1673 created an initial 
implementation of the interface described therein, and provided it to 
the authors of this proposal. We are currently endeavoring to integrate 
it into the P1385 reference implementation.


## P1385R3: Update for Belfast 2019 meeting.

### Changes

- Remove more erroneous references to `row_vector` and `column_vector`. 

### SG6 feedback

The paper was reviewed by SG6 briefly. SG6 only require further review if a 
numeric question arises. 

### LEWG(I) Polls and feedback [Wednesday 2019-11-06](http://wiki.edg.com/bin/view/Wg21belfast/P1385) 

**Poll**: We want to be able to modify elements through `matrix_*_view`s 
(similar to `span`). (20 present) 

  SF    F     N     A     SA
----- ----- ----- ----- ----- -------------
  8     8     0     0     0    (consensus)

**Poll**: For matrix types with overloaded operators, we are comfortable 
with supporting hooks for expression templates but having no expression 
templates by default in the standard library. (20 present) 

  SF    F     N     A     SA
----- ----- ----- ----- ----- -------------
  2     4     4     2     0    (consensus) 

**Poll**: Given what we've seen so far, we are comfortable with the 
customization mechanisms for overloaded operators on matrices. (20 present)

  SF    F     N     A     SA
----- ----- ----- ----- ----- -------------
  2     4     7     0     2    (consensus)

CONSENSUS: Bring a revision with the guidance below to LEWGI for further 
design review. 

Note from the Chair: These pieces of guidance from Kona seem not to have 
been addressed.  Please address them in the next revision of the paper. 

- Define engine/matrix classes in terms of mdspan & storage and mdspan concepts
(e.g. extents), and expose an mdspan-esque interface. This implies that fs_ and 
dyn_ are combined into one template parameterized on extents (which are either 
static or dynamic). 

- Add explicitly named operations (e.g. dot, outer) in addition to operators. 

Other feedback and suggestions:

- Ask SG6 to formulate a precise definition of `is_field`, `is_nc_ring` and 
`is_ring`, and consider what the answers should be for builtin types (e.g. 
signed integers, unsigned integers, and floating point types). 

- Make `numeric_traits` non-implementation-defined; for non-builtin/non-`std` 
types, assume the properties are false. 

- Separate `is_complex` or `is_specialization_of` into a separate paper. 

- Remove the `numeric_traits` helper traits (`is_field`, `is_nc_ring`, etc). 

- Make `matrix_*_view`'s copy constructor and copy assignment methods `noexcept`. 

- Add non-const `begin` and `end` to `matrix_*_view`. 

- Remove `assign` method from `matrix_*_view`. 

- Provide a way to modify elements through `matrix_*_view` types: one option is 
to add `matrix_*_ref` types that allow modification of the underlying elements. 

- Explore adding a submatrix view. 

- Make `index_type` `ptrdiff_t` and `size_type` `size_t`. 

- Develop a clear plan for `is_rectangular == false`. 

- Add `data` to engine types. 

- `is_fixed_size` and `is_resizable` are inverses of each other; explore combining. 

- Explore different designs for `numeric_traits`: either looking for embedded 
type aliases in the classes instead of a trait, or granular traits *a la* P1370. 


## P1385R4: Update to R3 for post-Belfast 2019 mailing. 

### Changes

- Include feedback from reviews in Belfast. 


## P1385R5: Update for pre-Prague mailing, based on feedback from Belfast. 

### Changes

- Removed element type predicate traits from the public interface. 

- Removed `is_complex` from the public interface. 

- Added mutating row, column, transpose, and submatrix "views" (in addition 
to the corresponding const "views"). 

- Changed type of NTTPs for sizes to `size_t`. - Changed `index_type` to 
`size_type` for indexing. 

- Changed names formerly `*_view` to `*_engine`. 

- Removed `matrix_` prefix from non-owning engine names. 

- Removed nested boolean attributes from engines and math objects. 

- Renamed `const_*_tag` and `mutable_*_tag` tag types to `readable_*_tag` 
  and `writable_*_tag`, respectively. 

The paper was reviewed by SG6/SG14/SG19 briefly and then by LEWG(I).

### LEWG(I) polls and feedback [several sessions](http://wiki.edg.com/bin/view/Wg21prague/P1385) 

**Poll**: We want `operator*(std::math::vector, std::math::vector)` in the 
standard library, even though some believe it is ambiguous. (25 present)

  SF    F     N     A     SA
----- ----- ----- ----- ----- ----------------
  5     6     2     1     6    (no consensus)

**Poll**: We want overloaded operators (e.g. `operator*`, `operator+`, etc) for 
matrix/vector operations in the standard library. (25 present)

  SF    F     N     A     SA
----- ----- ----- ----- ----- -------------
  10    4     3     2     2    (consensus) 

**Poll**: Assuming we have overloaded operators (e.g. `operator*`, `operator+`, 
etc) for matrix/vector operations in the standard library, we want their 
semantics to be customizable by users. (25 present)

  SF    F     N     A     SA
----- ----- ----- ----- ----- ----------------
  5     4     8     1     3    (no consensus) 

**Poll**: We are okay with only providing submatrices/slices with non-owning 
semantics in the first version we ship.  (17 present)

  SF    F     N     A     SA
----- ----- ----- ----- ----- -------------
  8     4     2     2     0    (consensus) 

Guidance: Bring a revision of D1385R6 (DSL Linear Algebra Library), 
with the suggestions below, to LEWGI for further design review. 

- Add further justification for why matrix operations need to be customizable 
by users; this should be a focus of the next discussion in an effort to 
increase consensus. 

- Remove `operator*(std::math::vector, std::math::vector)`. 

- `swap()` on engines should be `noexcept`.

- Bikeshed "view" in this paper on the LEWG mailing list. 

- Bikeshed the `t` and `h` member functions on the LEWG mailing list.

- Use `extents` instead of `size_tuple`. 

- Explore alternatives to `initializer_list<initializer_list<>>` that enforce 
that the dimensions of all the inner lists are identical (follow-up with Eric 
Fiselier). 

- Demonstrate and clarify how the engine categories work and how you could use 
them to write generic functions that accept matrices of certain categories 
(follow up with Gašper Ažman). 


## P1385R6: Update for post-Prague 2020 mailing 

- Added `initable_*_tag` to specify types for which construction and assignment
  from an `initializer_list` are acceptable. 

- Added support for `basic_mdspan` for the engine types, `vector`, and `matrix`. 

- Reduced the number of non-owning, view-style engine types to two: 
`vector_view_engine` and `matrix_view_engine` (and consequently removed 
`row_engine`, `column_engine`, and `transpose_engine`). 

- Added function templates `inner_product()` and `outer_product(). 

- Removed iteration from the public interfaces of `vector` and all vector engines. 

- Added free function templates `begin()`, `end()`, etc. to provide iteration over 
the elements of a `vector` object. 


## P1385D7: Update for summer 2020 review

- Added various helper variable templates used by the library and useful
for customizers.

- Ensured all `swap()` member functions are marked noexcept.

- Changed all NTTPs of type `size_t` back to `ptrdiff_t` to be consistent with 
`mdspan`.

- Changed `size_type` back to `index_type` to be consistent with `mdspan`.

- Added support for `mdspan` when building under Windows.

- Augmented the names of the arithmetic operation traits to include the word
`arithmetic`.

- Added support scalar division, including element promotion traits, engine
promotion traits, arithmetic traits, and an overloaded `operator /()`.

- Removed negation as an arithmetic operation and made it a `readable` (i.e., 
read-only) view instead.

- Constrained transpose and hermitian views to be `readable` (i.e., read-only).

- Renamed `math::vector::elements()` to `math::vector::size()`.

- Made all arithmetic operation traits and overloaded arithmetic operators
`constexpr`.

# Goals

We expect that typical users of a standard linear algebra library are
likely to value two features above all else: ease-of-use (including
expressiveness), and high performance out of the box. This set of users 
will expect the ability to compose arithmetical expressions of linear 
algebra objects similar to what one might find in a textbook; indeed, 
this has been deemed a "must-have" feature by several participants in 
SG14 Linear Algebra SIG conference calls. And for a given arithmetical 
expression, they will expect run-time computational performance that 
is close to what they could obtain with an equivalent sequence of 
function calls to a more "traditional" linear algebra library, such as
*LAPACK*, *Blaze*, *Eigen*, etc.

There also exists a set of linear algebra “super-users” who will value
most highly a third feature – the ability to customize underlying
infrastructure in order to maximize performance for specific problems
and computing platforms. These users seek the highest possible run-time
performance, and to achieve it, require the ability to customize any and
every portion of the library’s computational infrastructure.

With these high-level user requirements in mind, in this paper we propose 
an interface specification intended to achieve the following goals:

1. To provide a set of vocabulary types for representing the mathematical 
objects and fundamental operations relevant to linear algebra;

1. To provide a public interface for linear algebra expressions that is
intuitive, teachable, and mimics the expressiveness of traditional 
mathematical notation to the greatest *reasonable* extent;

1. To exhibit out-of-the-box performance in the neighborhood of that 
of that exhibited by an equivalent sequence of function calls to a more 
traditional linear algebra library, such as *LAPACK*, *Blaze*, *Eigen*, etc.;

1. To provide a set of building blocks that manage the source,
ownership, lifetime, layout, and access of the memory required to
represent the linear algebra vocabulary types;

1. To provide straightforward facilities and techniques for
customization that enable users to optimize performance for their
specific problem domain on their specific hardware; and,

1. To provide a *reasonable* level of granularity for customization so 
that developers only have to implement a minimum set of types and 
functions to integrate their performance enhancements with the rest of
the linear algebra facilities described here.


# Definitions

When discussing linear algebra and related topics for a proposal such as
this, it is important to note that there are several overloaded terms
(such as *matrix*, *vector*, *dimension*, and *rank*) which must be
defined and disambiguated if such discussions are to be productive.
These terms have specific meanings in mathematics, as well as different,
but confusingly similar, meanings to C++ programmers.

In the following sections we provide definitions for relevant
mathematical concepts, C++ type design concepts, and describe how 
this proposal employs those overloaded terms in various contexts.


## Mathematical terms

In order to facilitate subsequent discussion, we first provide the
following *informal* set of definitions for important mathematical
concepts:

1.  A **vector space** is a collection of **vectors**, where vectors 
are objects that may be added together and multiplied by scalars.
Euclidean vectors are an example of a vector space, typically used
to represent displacements, as well as physical quantities such as
force or momentum. Linear algebra is concerned primarily with the
study of vector spaces.

1.  The **dimension** of a vector space is the minimum number of
coordinates required to specify any point within the space.

1.  A **matrix** is a rectangular array of numbers, symbols, or
expressions, arranged in rows and columns. A matrix having *m* rows
and *n* columns is said to have size *m* x *n*. Although matrices
can be used to solve systems of simultaneous linear equations, they are
most commonly used to represent linear transformations, solve linear
least squares problems, and to explore and/or manipulate the
properties of vector spaces.

1.  The **rank** of a matrix is the dimension of the vector space
spanned by its columns, which is equal to the dimension of the
vector space spanned by its rows. The rank is also equal to the
maximum number of linearly-independent columns and rows.

1.  An **element** of a matrix is an individual member (number, symbol,
expression) of the rectangular array comprising the matrix, lying at
the intersection of a single row and a single column. In traditional
mathematical notation, row and column indexing is 1-based, where
rows are indexed from 1 to *m* and columns are indexed from 1 to
*n*. Given some matrix *A*, element *a*<sub>*11*</sub> refers to the
element in the upper left-hand corner of the array and element
*a*<sub>*mn*</sub> refers to the element in the lower right-hand
corner.

1.  A **row vector** is a matrix containing a single row; in other
words, a matrix of size *1* x *n*. In many applications of linear
algebra, row vectors represent spatial vectors.

1.  A **column vector** is a matrix containing a single column; in other
words, a matrix of size *m* x *1*. In many applications of linear
algebra, column vectors represent spatial vectors.

1.  **Element transforms** are non-arithmetical operations that modify
the relative positions of elements in a matrix, such as transpose,
column exchange, and row exchange.

1.  **Element arithmetic** refers to arithmetical operations that read
or modify the values of individual elements independently of other
elements, such as assigning a value to a specific element or
multiplying a row by some value.

1. **Matrix arithmetic** refers to the assignment, addition,
subtraction, negation, multiplication, and determinant operations
defined for matrices, row vectors, and column vectors as wholes.

1. A **rectangular matrix** is a matrix requiring a full *m* x *n*
representation; that is, a matrix not possessing a special form,
such as identity, triangular, band, etc.

1. The **identity matrix** is a square matrix where all elements on the
diagonal are equal to one and all off-diagonal elements are equal to
zero.

1. A **triangular matrix** is a matrix where all elements above or
below the diagonal are zero; those with non-zero elements above the
diagonal are called *upper triangular*, while those with non-zero
elements below the diagonal are called *lower triangular*.

1. A **band matrix** is a sparse matrix whose non-zero entries are
confined to a diagonal band, lying on the main diagonal and zero or
more diagonals on either side.

1. **Decompositions** are complex sequences of arithmetic operations,
element arithmetic, and element transforms performed upon a matrix
that expose important mathematical properties of that matrix.
Several types of decomposition are often performed in solving
least-squares problems.

1. **Eigen-decompositions** are decompositions performed upon a
symmetric matrix in order to compute the eigenvalues and eigenvectors 
of that matrix; this is often performed when solving problems involving 
linear dynamic systems.


## Terms pertaining to C++ types

The following are terms used in this proposal that describe various
aspects of how the mathematical concepts described above in Section 3.1
might be implemented:

1.  An **array** is a data structure representing an indexable collection 
of objects (elements) such that each element is identified by at 
least one index. An array is said to be *one-dimensional* if its 
elements are accessible with a single index; a *multi-dimensional* array 
is an array for which more than one index is required to access its 
elements.

1.  The **dimension** of an array refers to the number of indices
required to access an element of that array. The **rank** of an
array is a synonym for its dimension.

1.  This proposal uses the term **MathObj** to refer generically to one
of the C++ types described herein representing matrices and vectors (i.e.,
`matrix` and `vector`). These are the public-facing types developers will 
use in their code.

1.  An **engine** is an implementation type that manages the resources
associated with a *MathObj* instance.  This includes, at a minimum, the 
storage-related aspects of, and access to, the elements of a *MathObj*. 
It could also include execution-related aspects, such as an execution 
context. In this proposal, an engine object is a private member of a 
*MathObj*. Other than as a template parameter, engines are not part of 
a *MathObj*’s public interface.

1.  The adjective **dense** refers to a *MathObj* representation where
storage is allocated for every element.

1.  The adjective **sparse** refers to a *MathObj* representation where
storage is allocated only for non-zero elements;

1.  **Storage** is used by this proposal as a synonym for memory.

1.  **Traits** refers to a stateless class template that provides some
set of services, normalizing those services over its set of template
parameters.

1.  **Row size** and **column size** refer to the number of rows and
columns, respectively, that a *MathObj* represents, which must be
less than or equal to its row and column capacities, defined below.

1. **Row capacity** and **column capacity** refer to the maximum number
of rows and columns, respectively, that a *MathObj* can possibly
represent.

1. **Fixed-size** (FS) refers to an engine type whose row and column
sizes are fixed at instantiation time and constant thereafter.

1. **Fixed-capacity** (FC) refers to an engine type whose row and
column capacities are fixed at instantiation time and constant
thereafter.

1. **Dynamically re-sizable** (DR) refers to an engine type whose row
and column sizes and capacities may be changed at run time.

## Overloaded terms

This section describes how we use certain overloaded terms in this proposal 
and in future works.


### Matrix

The term *matrix* is frequently used by C++ programmers to mean a
general-purpose array of arbitrary size. For example, one of the authors
worked at a company where it was common practice to refer to 4-dimensional 
arrays as “4-dimensional matrices.”

In this proposal, we use the word *array* only to mean a data structure
whose elements are accessible using one or more indices, and which has
no invariants pertaining to higher-level or mathematical meaning.

We use *matrix* to mean the mathematical object as defined above in
Section 3.1, and `matrix` (in monospaced font) to mean the C++ class
template that implements the mathematical object. We sometimes use
`MathObj` (in monospaced font) in some of the component interface code
and text below to generically refer to a `matrix` or `vector` object.


### Vector

Likewise, many C++ programmers incorrectly use the term *vector* as a
synonym for “dynamically re-sizable array.” This bad habit is
reinforced by the unfortunate naming of `std::vector`.

This proposal uses the term *vector* to mean an element of a vector
space, per Section 3.1 above. Further, we also mean *vector* generically 
to have both of the meanings set out in 3.1, and `vector` (in monospaced 
font) is the C++ class template implementing those mathematical objects. 
We sometimes use `MathObj` (in monospaced font) in some of the component 
code interface code and test below to generically refer to a `vector` or 
`matrix` object.


### Dimension

In linear algebra, a vector space *V* is said to be of *dimension n*, or
be *n-dimensional*, if there exist *n* linearly independent vectors which
span *V*. This is another way of saying that *n* is the minimum number
of coordinates required to specify any point in *V*. However, in common
programming parlance, *dimension* refers to the number of indices used
to access an element in an array.

We use the term dimension both ways in this proposal, but try to do so
consistently and in a way that is clear from the context. For example, a
rotation matrix used by a game engine is a two-dimensional data structure 
composed of three-dimensional row and column vectors. A vector describing 
an electric field is an example of a one-dimensional data structure that
could be implemented as a three-dimensional column vector.


### Rank

The *rank* of a matrix is the dimension of the vector space spanned by
its columns (or rows), which corresponds to the maximal number of
linearly independent columns (or rows) of that matrix. Rank also has 
another meaning in tensor analysis, where it is commonly used as a
synonym for a tensor’s *order*.

However, rank also has a meaning in computer science where it is used as
a synonym for dimension. In the C++ standard at [*meta.unary.prop.query*], 
rank is described as the number of dimensions of `T` if `T` names an array, 
otherwise it is zero.

We avoid using the term *rank* in this proposal in the context of linear
algebra, except as a quantity that might result from performing certain
decompositions wherein the mathematical rank of a matrix is computed.


# Scope

We contend that the best approach for standardizing a set of linear
algebra components for C++23 will be one that is layered, iterative, and
incremental. This paper is quite deliberately a “basic linear algebra-only”
proposal; it describes what we believe is a foundational layer providing
the minimum set of components and arithmetic operations necessary to provide 
a reasonable, basic level of functionality.

Higher-level functionality can be specified in terms of the interfaces
described here, and we encourage succession papers to explore this
possibility.


## Functional requirements

The foundational layer, as described here, should include the minimal
set of types and functions required to perform matrix arithmetic in
finite dimensional spaces. This includes:

+ Matrix and vector class templates;

+ Arithmetic operations for scalar multiplication and scalar division of 
matrices and vectors;

+ Arithmetic operations for addition, subtraction, and multiplication of 
appropriate combinations of matrices and vectors;

+ Well-defined facilities for integrating custom element types;

+ Well-defined facilities for defining and integrating custom engines; and,

+ Well-defined facilities for definining and integrating custom arithmetic 
operations.


## Considered but excluded

**Tensors**

There has been a great deal of interest expressed in specifying an
interface for general-purpose tensor processing in which linear algebra
facilities fall out as a special case. We exclude this idea from this
proposal for two reasons. First, given the practical realities of
standardization work, the enormous scope of such an effort would very
likely delay introduction of linear algebra facilities until C++26 or
later.

Second, and more importantly, implementing matrices as derived types or
specializations of a general-purpose tensor type is bad type design.
Consider the following: a tensor is (informally) an array of
mathematical objects (numbers or functions) such that its elements
transform according to certain rules under a coordinate system change.
In a *p*-dimensional space, a tensor of rank *n* will have
*p*<sup>*n*</sup> elements. In particular, a rank-2 tensor in a
*p*-dimensional space may be represented by a *p* x *p* matrix having
certain invariants related to coordinate transformation not possessed by
all *p* x *p* matrices.

These defining characteristics of a tensor lead us to the crux of the
issue: every rank-2 tensor can be represented by a square matrix, but
not every square matrix represents a tensor. As one quickly realizes,
only a small fraction of all possible matrices are representations of
rank-2 tensors.

All of this is a long way of saying that the class invariants governing
a matrix type are quite different from those governing a tensor type,
and as such, the public interfaces of such types will also differ
substantially.

From this we conclude that matrices are not Liskov-substitutable for
rank-2 tensors, and therefore as matter of good type design, matrices
and tensors should be implemented as distinct types, perhaps with
appropriate inter-conversion operations.

This situation is analogous to the age-old object-oriented design
question: when designing a group of classes that represent geometric
shapes, is a square a kind of rectangle? In other words, should class
`square` be publicly derived from class `rectangle`? Mathematically,
yes, a square *is* a rectangle. But from the perspective of good
interface design, class `square` is typically not substitutable for class
`rectangle` and is usually best implemented as a distinct type having
no IS-A relationship with `rectangle`.

**Quaternions and octonions**

There has also been interest expressed in including other useful
mathematical objects, such as quaternions and octonions, as part of a
standard linear algebra library. Although element storage for these
types might be implemented using the engines described in this proposal,
quaternions and octonions represent mathematical concepts that are
fundamentally different from those of matrices and vectors.

As with tensors, the class invariants and public interfaces for
quaternions and octonions would be substantially different from that of
the linear algebra components. Liskov substitutability would not be
possible, and therefore quaternions and octonions should be implemented
as types distinct from the linear algebra types.


# Design aspects

The following describe several important aspects of the problem domain
affecting the design of the proposed interface. Importantly, these
aspects are orthogonal, and are addressable through judicious
combinations of template parameters and implementation type design.


## Memory source

Perhaps the first question to be answered is that of the source of
memory in which elements will reside. One can easily imagine multiple
sources of memory:

+ Elements reside in an external buffer allocated from the global heap.

+ Elements reside in an external buffer allocated by a custom allocator
and/or specialized heap.

+ Elements reside in an external fixed-size buffer that exists
independently of the *MathObj*, not allocated from a heap, and which
has a lifetime greater than that of the *MathObj*.

+ Elements reside in a fixed-size buffer that is a member of the
*MathObj* itself.

+ Elements reside collectively in a set of buffers distributed across
multiple machines.


## Addressing model

It is also possible that the memory used by a *MathObj* might be
addressed using what the standard calls a *pointer-like type*, also
known as a *fancy pointer*.

For example, consider an element buffer existing in a shared memory
segment managed by a custom allocator. In this case, the allocator 
might employ a fancy pointer type that performs location-independent
addressing based on a segment index and an offset into that segment.

One can also imagine a fancy pointer that is a handle to a memory
resource existing somewhere on a network, and addressing operations
require first mapping that resource into the local address space,
perhaps by copying over the network or by some magic sequence of RPC
invocations.


## Memory ownership

The next important questions pertain to memory ownership. Should the
memory in which elements reside be deallocated, and if so, what object
is responsible for performing the deallocation?

A *MathObj* might own the memory in which it stores its elements, or it 
might employ some non-owning view type, like `mdspan`, to manipulate 
elements owned by some other object.


## Capacity and resizability

As with `std::string` and `std::vector`, it is occasionally useful
for a *MathObj* to have excess storage capacity in order to reduce the
number of re-allocations required by anticipated future resizing operations. 
Some linear algebra libraries, like LAPACK, account for the fact that a
*MathObj*’s capacity may be different than its size. This capability was
of critical importance to the success of one author’s prior work in
functional MRI image analysis.

In other problem domains, like computer graphics, *MathObj*s are small
and always of the same size. In this case, the size and capacity are
equal, and there is no need for a *MathObj* to maintain or manage excess
capacity.


## Element layout

There are many ways to arrange the elements of a matrix in memory, the
most common in C++ being row-major dense rectangular. In Fortran-based
libraries, the two-dimensional arrays used to represent matrices are
usually column-major. There are also special arrangements of elements
for upper/lower triangular and banded diagonal matrices that are both
row-major and column-major. These arrangements of elements have been
well-known for many years, and libraries like LAPACK in the hands of a
knowledgeable user can use them to implement code that is optimal in
both time and space.


## Element access and indexing

In keeping with the goal of supporting a natural syntax, and in analogy
with the indexing operations provided by the random-access standard
library containers, it seems reasonable to provide both const and
non-const indexing for reading and writing individual elements.


## Element type

C++ supports a relatively narrow range of arithmetic types, lacking
direct support for arbitrary precision numbers and fixed-point numbers,
among others. Libraries exist to implement these types, and they should
not be precluded from use in a standard linear algebra library. It is
possible that individual elements of a *MathObj* may allocate memory,
and therefore an implementation cannot assume that element types have
trivial constructors or destructors.


## Mixed-element-type expressions

In general, when multiple built-in arithmetic types are present in an
arithmetical expression, the resulting type will have a precision
greater than or equal to that of the type with greatest precision in the
expression. In other words, to the greatest reasonable extent, information 
is preserved.

We contend that a similar principal should apply to expressions involving 
*MathObj*s where more than one element type is present. Arithmetic operations
involving *MathObj*s should, to the greatest reasonable extent, preserve 
element-wise information.

For example, just as the result of multiplying a `float` by a
`double` is a `double`, the result multiplying a matrix-of-`float`
by a matrix-of-`double` should be a matrix-of-`double`. We call the
process of determining the resulting element type *element promotion*.


## Mixed-engine expressions

In analogy with element type, *MathObj* expressions may include mixed
storage management strategies, as implemented by their corresponding
engine types. For example, consider the case of a fixed-size matrix
multiplied by a dynamically-resizable matrix. What is the engine type of
the resulting matrix?

Expressions involving mixed engine types should not limit the
availability of basic arithmetic operations. This means that there
should be a mechanism for determining the engine type of the result
of such expressions. We call the process of determining the resulting
engine type *engine promotion*.

We contend that in most cases, the resulting engine type should be at 
least as "general" as the most "general" of the two engine types.
For example, one could make the argument that a dynamically-resizable
engine is more general than a fixed-size engine, and therefore 
the resulting engine type in an expression involving both these engine
types should be a dynamically-resizable engine.

However, there are cases in which it may be possible to choose a more 
performant engine at compile time.  For example, consider the case adding
a fixed-size matrix and a dynamically-resizable matrix.  Although size
checking must be performed at run time, the resulting engine might be
specified as fixed-size.


## Arithmetic customization

In pursuit of optimal performance, developers may want to customize
specific arithmetic operations, such as matrix-matrix or matrix-vector
multiplication.  Customization might be based on things like element 
layout in memory, fixed-size -vs- dynamically resizable, special hardware
capabilities, etc.

One such possible optimization is the use of multiple cores, perhaps
distributed across a network, to carry out multiplication on very large 
pairs of matrices, particularly in situations where the operation is used 
to produce a third matrix rather than modify one of the operands; the 
matrix multiplication operation is particularly amenable to this approach.

Developers may also wish to make use of SIMD intrinsics to enable
parallel evaluation of matrix multiplication. This is common in game
development environments where programs are written for very specific
platforms, where the make and model of processor is well defined. This
would impact on element layout and storage. Such work has already been
demonstrated in paper N4454.

It is possible that two operands may be associated with different arithmetic
customizations.  We call the process of determining which of those two 
customizations to employ when performing the actual arithmetic operations
*operation traits promotion*.


# Interface description

In this section, we describe the various types, operators, and functions
comprising the proposed interface. The reader should note that the
descriptions below are by no means ready for wording; rather, they are
intended to foster further discussions and refinements, and to serve
as a guide for hardy souls attempting to build implementations from this
specification.


## Overview

At the highest level, the interface is divided into four broad categories:

1. **Engines**, which are implementation types that manage the resources
associated with a *MathObj* instance, including memory ownership and lifetime, 
as well as element access; and, 

1. **MathObjs**, which provide a unified interface intended to model a 
corresponding mathematical abstraction (i.e., `vector`, `matrix`);

1. **Operators**, which provide the desired mathematical syntax and carry
out the promised arithmetic.

1. **Operation traits** act as a "container" for element promotion, engine
promotion, and arithmetic traits (described below) and provide the "glue"
that connects the engines, *MathObjs*, and the operators.  This traits type 
is a template parameter to the *MathObj* types, and provides a way to inform 
an operator of the set of available arithmetic traits to be used when deciding 
how to perform an arithmetic operation.

At the next lower level are a number of supporting traits types employed by 
the operation traits to determine the return type of the operator and perform 
the corresponding arithmetic operation.  There are several such traits types:

+ **Element promotion traits** determine the resulting element type of an
  arithmetic operation involving two *elements*. 

+ **Engine promotion traits** determine the resulting engine type of an
arithmetic operation involving *matrix* and/or *vector* objects.  As part 
of that process, this traits type uses the element promotion traits to 
determine the element type of the resulting engine.

+ **Arithmetic traits** determine the type and value of a *MathObj* 
resulting from an arithmetical operation.  As part of that process, 
this traits type uses the engine promotion traits to determine the 
engine type of the resulting *MathObj*.  Having determined the result 
type, the arithmetic traits also have a member function that carries 
out the actual computations.

And finally, **operation selector traits** provide the means by which an 
arithmetic operator selects the operation traits that will perform the 
arithmetic. In the case where each operand has the same operation traits, 
the decision is simple.  However, it is possible that the operands may be 
instantiated with different operation traits types, and so the operator 
uses the operation selector traits to decide which operation traits type 
to use for computing its result.  The proposed traits class 
`std::math::matrix_operation_traits` is a library customization point.


### Template parameter nomenclature

In order to avoid excessive visual noise in the code displayed in subsequent 
sections of this paper, we use the following abbreviation-based naming 
conventions for template parameters:

+ Parameter names `T`, `T1`, `T2`, `U`, `U1`, and `U2` represent element 
types. 

+ Parameter names `ET`, `ET1`, and `ET2` represent engine types.

+ Parameter names `OT`, `OT1`, and `OT2` represent operation traits types.

+ Parameter names `OP`, `OP1`, and `OP2` represent the operand types 
deduced by an arithmetic operator.

+ Parameter names `AT`, `AT1`, and `AT2` represent allocator types.

+ Parameter names `N`, `N1`, and `N2` represent the number of elements
in a fixed-size vector or vector engine.

+ Parameter names `C`, `C1`, and `C2` represent the number of columns in
a fixed-size matrix or matrix engine.

+ Parameter names `R`, `R1`, and `R2` represent the number of rows in
a fixed-size matrix or matrix engine.

+ Parameter name `VCT` represents a vector engine's category tag type.
  
+ Parameter name `MCT` represents a matrix engine's category tag type.

+ Parameter name `VFT` represents a view engine's functionality tag type 
(i.e., row, column, subset, transpose, hermitian, negation).


## `std::math` namespace

We propose adding the new namespace `std::math` to the standard library to contain the linear 
algebra facilities described in this paper.  There are two reasons for this: first, in order to 
group a related set of mathematical facilities in a meaningful and orderly fashion; and second, 
to distinguish the mathematical vector type described in this proposal, `std::math::vector`, 
from the general-purpose container type `std::vector`.


## Header `<linear_algebra>` synopsis

~~~~c++
#include <cstdint>
#include <complex>
#include <initializer_list>
#include <mdspan>
#include <memory>
#include <tuple>
#include <type_traits>

namespace std::math {
//- Engine category tag types, used to specify/distinguish the interfaces exhibited by engine types.
//
struct scalar_engine_tag;

struct readable_vector_engine_tag;
struct writable_vector_engine_tag;
struct initable_vector_engine_tag;
struct resizable_vector_engine_tag;

struct readable_matrix_engine_tag;
struct writable_matrix_engine_tag;
struct initable_matrix_engine_tag;
struct resizable_matrix_engine_tag;

//- Variable templates used to probe properties associated with engine category tags.
//
template<class CT> inline constexpr
bool    is_scalar_engine_tag_v = @_implementation-defined_@;

template<class CT> inline constexpr
bool    is_vector_engine_tag_v = @_implementation-defined_@;

template<class CT> inline constexpr
bool    is_matrix_engine_tag_v = @_implementation-defined_@;

template<class CT> inline constexpr
bool    is_readable_engine_tag_v = @_implementation-defined_@;

template<class CT> inline constexpr
bool    is_writable_engine_tag_v = @_implementation-defined_@;

template<class CT> inline constexpr
bool    is_initable_engine_tag_v = @_implementation-defined_@;

template<class CT> inline constexpr
bool    is_resizable_engine_tag_v = @_implementation-defined_@;

//- Variable templates used to probe properties of engine types.
//
template<class ET> inline constexpr
bool    is_engine_v = @_implementation-defined_@;

template<class ET> inline constexpr
bool    is_scalar_engine_v = @_implementation-defined_@;

template<class ET> inline constexpr
bool    is_vector_engine_v = @_implementation-defined_@;

template<typename ET> inline constexpr
bool    is_matrix_engine_v = @_implementation-defined_@;

template<class ET> inline constexpr
bool    is_readable_engine_v = @_implementation-defined_@;

template<class ET> inline constexpr
bool    is_writable_engine_v = @_implementation-defined_@;

template<class ET> inline constexpr
bool    is_initable_engine_v = @_implementation-defined_@;

template<class ET> inline constexpr
bool    is_resizable_engine_v = @_implementation-defined_@;

template<class ET1, class ET2> inline constexpr
bool    engines_are_similar_v = @_implementation-defined_@;

//- A trivial engine that represents a scalar operand.
//
template<class T>   struct scalar_engine;

//- Owning engines with fixed-size internal storage.
//
template<class T, size_t N>                 class fs_vector_engine;
template<class T, size_t R, size_t C>       class fs_matrix_engine;

//- Owning engines with dynamically-allocated external storage.
//
template<class T, class AT = allocator<T>>  class dr_vector_engine;
template<class T, class AT = allocator<T>>  class dr_matrix_engine;

//- Non-owning view function tag types, used to specify the transformation performed by a view.
//
struct column_view_tag;
struct row_view_tag;
struct subset_view_tag;
struct negation_view_tag;
struct transpose_view_tag;
struct hermitian_view_tag;

//- Non-owning, view-style engines.
//
template<class ET, class VCT, class VFT>    class vector_view_engine;
template<class ET, class MCT, class VFT>    class matrix_view_engine;

//- These are some convenience aliases, to make it easier for user-created 
//  operation traits.
//
template<class ET>
using vector_negation_engine = vector_view_engine<ET, readable_vector_engine_tag, negation_view_tag>;

template<class ET, class VCT>
using vector_subset_engine = vector_view_engine<ET, VCT, subset_view_tag>;

template<class ET>
using matrix_negation_engine = matrix_view_engine<ET, readable_matrix_engine_tag, negation_view_tag>;

template<class ET>
using matrix_transpose_engine = matrix_view_engine<ET, readable_matrix_engine_tag, transpose_view_tag>;

template<class ET>
using matrix_hermitian_engine = matrix_view_engine<ET, readable_matrix_engine_tag, hermitian_view_tag>;

template<class ET, class VCT>
using matrix_column_engine = vector_view_engine<ET, VCT, column_view_tag>;

template<class ET, class VCT>
using matrix_row_engine = vector_view_engine<ET, VCT, row_view_tag>;

template<class ET, class MCT>
using matrix_subset_engine = matrix_view_engine<ET, MCT, subset_view_tag>;

//- The default element promotion, engine promotion, and arithmetic operation 
//  traits for the four basic arithmetic operations.
//
struct matrix_operation_traits;

//- The two primary math object types, vector and matrix.
//
template<class ET, class OT=matrix_operation_traits> class vector;
template<class ET, class OT=matrix_operation_traits> class matrix;

//- Iteration for vector.
//
template<class ET, class OT> constexpr
@_implementation-defined_@  begin(vector<ET, OT>& v) noexcept;
template<class ET, class OT> constexpr
@_implementation-defined_@  end(vector<ET, OT>& v) noexcept;

template<class ET, class OT> constexpr
@_implementation-defined_@  begin(vector<ET, OT> const& v) noexcept;
template<class ET, class OT> constexpr
@_implementation-defined_@  end(vector<ET, OT> const & v) noexcept;

template<class ET, class OT> constexpr
@_implementation-defined_@  rbegin(vector<ET, OT> const& v) noexcept;
template<class ET, class OT> constexpr
@_implementation-defined_@  rend(vector<ET, OT> const & v) noexcept;

template<class ET, class OT> constexpr
@_implementation-defined_@  cbegin(vector<ET, OT> const& v) noexcept;
template<class ET, class OT> constexpr
@_implementation-defined_@  cend(vector<ET, OT> const & v) noexcept;

template<class ET, class OT> constexpr
@_implementation-defined_@  rbegin(vector<ET, OT>& v) noexcept;
template<class ET, class OT> constexpr
@_implementation-defined_@  rend(vector<ET, OT>& v) noexcept;

template<class ET, class OT> constexpr
@_implementation-defined_@  crbegin(vector<ET, OT> const& v) noexcept;
template<class ET, class OT> constexpr
@_implementation-defined_@  crend(vector<ET, OT> const & v) noexcept;

//- Traits pertaining to addition.
//
template<class T1, class T2>                struct matrix_addition_element_traits;
template<class OT, class ET1, class ET2>    struct matrix_addition_engine_traits;
template<class OT, class OP1, class OP2>    struct matrix_addition_arithmetic_traits;

//- Traits pertaining to subtraction.
//
template<class T1, class T2>                struct matrix_subtraction_element_traits;
template<class OT, class ET1, class ET2>    struct matrix_subtraction_engine_traits;
template<class OT, class OP1, class OP2>    struct matrix_subtraction_arithmetic_traits;

//- Traits pertaining to multiplication.
//
template<class T1, class T2>                struct matrix_multiplication_element_traits;
template<class OT, class ET1, class ET2>    struct matrix_multiplication_engine_traits;
template<class OT, class OP1, class OP2>    struct matrix_multiplication_arithmetic_traits;

//- Traits pertaining to scalar division.
//
template<class T1, class T2>                struct matrix_division_element_traits;
template<class OT, class ET1, class ET2>    struct matrix_division_engine_traits;
template<class OT, class OP1, class OP2>    struct matrix_division_arithmetic_traits;

//- Alias templates used to obtain results of element, engine, and operation 
//  traits promotion.
//
template<class OT, class T1, class T2>
using select_matrix_addition_element_t = @(_see below_)@;

template<class OT, class ET1, class ET2>
using select_matrix_addition_engine_t = @(_see below_)@;

template<class OT, class OP1, class OP2>
using select_matrix_addition_arithmetic_t = @(_see below_)@;

template<class OT, class T1, class T2>
using select_matrix_subtraction_element_t = @(_see below_)@;

template<class OT, class ET1, class ET2>
using select_matrix_subtraction_engine_t = @(_see below_)@;

template<class OT, class OP1, class OP2>
using select_matrix_subtraction_arithmetic_t = @(_see below_)@;

template<class OT, class T1, class T2>
using select_matrix_multiplication_element_t = @(_see below_)@;

template<class OT, class ET1, class ET2>
using select_matrix_multiplication_engine_t = @(_see below_)@;

template<class OT, class OP1, class OP2>
using select_matrix_multiplication_arithmetic_t = @(_see below_)@;

template<class OT, class T1, class T2>
using select_matrix_division_element_t = @(_see below_)@;

template<class OT, class ET1, class ET2>
using select_matrix_division_engine_t = @(_see below_)@;

template<class OT, class OP1, class OP2>
using select_matrix_division_arithmetic_t = @(_see below_)@;

//- A traits type that chooses between two operation traits types in the binary 
//  arithmetic operators and free functions that act like binary operators. 
//  This traits class is a customization point.
//
template<class OT1, class OT2>  struct matrix_operation_traits_selector;

//- Addition operators
//
template<class ET1, class OT1, class ET2, class OT2>
constexpr @(_see below_)@   operator +(vector<ET1, OT1> const& v1, vector<ET2, OT2> const& v2);

template<class ET1, class OT1, class ET2, class OT2>
constexpr @(_see below_)@   operator +(matrix<ET1, OT1> const& m1, matrix<ET2, OT2> const& m2);

//- Subtraction operators
//
template<class ET1, class OT1, class ET2, class OT2>
constexpr @(_see below_)@   operator -(vector<ET1, OT1> const& v1, vector<ET2, OT2> const& v2);

template<class ET1, class OT1, class ET2, class OT2>
constexpr @(_see below_)@   operator -(matrix<ET1, OT1> const& m1, matrix<ET2, OT2> const& m2);

//- Multiplication operators
//
template<class ET1, class OT1, class S2>
constexpr @(_see below_)@   operator *(vector<ET1, OT1> const& v1, S2 const& s2);

template<class S1, class ET2, class OT2>
constexpr @(_see below_)@   operator *(S1 const& s1, vector<ET2, OT2> const& v2);

template<class ET1, class OT1, class S2>
constexpr @(_see below_)@   operator *(matrix<ET1, OT1> const& m1, S2 const& s2);

template<class S1, class ET2, class OT2>
constexpr @(_see below_)@   operator *(S1 const& s1, matrix<ET2, OT2> const& m2);

template<class ET1, class OT1, class ET2, class OT2>
constexpr @(_see below_)@   operator *(vector<ET1, OT1> const& v1, matrix<ET2, OT2> const& m2);

template<class ET1, class OT1, class ET2, class OT2>
constexpr @(_see below_)@   operator *(matrix<ET1, OT1> const& m1, vector<ET2, OT2> const& v2);

template<class ET1, class OT1, class ET2, class OT2>
constexpr @(_see below_)@   operator *(vector<ET1, OT1> const& v1, vector<ET2, OT2> const& v2);

template<class ET1, class OT1, class ET2, class OT2>
constexpr @(_see below_)@   operator *(matrix<ET1, OT1> const& m1, matrix<ET2, OT2> const& m2);

//- Scalar division operators
//
template<class ET1, class OT1, class S2>
constexpr @(_see below_)@   operator /(vector<ET1, OT1> const& v1, S2 const& s2);

template<class ET1, class OT1, class S2>
constexpr @(_see below_)@   operator /(matrix<ET1, OT1> const& m1, S2 const& s2);

template<class ET1, class OT1, class ET2, class OT2>
auto  operator /(vector<ET1, OT1> const& v1, vector<ET2, OT2> const& v2) = delete;

template<class ET1, class OT1, class ET2, class OT2>
auto  operator /(vector<ET1, OT1> const& v1, matrix<ET2, OT2> const& v2) = delete;

template<class ET1, class OT1, class ET2, class OT2>
auto  operator /(matrix<ET1, OT1> const& v1, vector<ET2, OT2> const& v2) = delete;

template<class ET1, class OT1, class ET2, class OT2>
auto  operator /(matrix<ET1, OT1> const& v1, matrix<ET2, OT2> const& v2) = delete;

//- Related free functions.
//
template<class ET1, class OT1, class ET2, class OT2>
constexpr @(_see below_)@  inner_product(vector<ET1, OT1> const& v1, vector<ET2, OT2> const& v2);

template<class ET1, class OT1, class ET2, class OT2>
constexpr @(_see below_)@  outer_product(vector<ET1, OT1> const& v1, vector<ET2, OT2> const& v2);

//- Alias templates for vector and matrix objects based on dynamically-resizable engines.
//
template<class T, class AT = allocator<T>>
using dyn_vector = vector<dr_vector_engine<T, AT>, matrix_operation_traits>;
 
template<class T, class AT = allocator<T>>
using dyn_matrix = matrix<dr_matrix_engine<T, AT>, matrix_operation_traits>;
 
//- Alias templates for vector and matrix objects based on fixed-size engines.
//
template<class T, ptrdiff_t N>
using fs_vector = vector<fs_vector_engine<T, N>, matrix_operation_traits>;
 
template<class T, ptrdiff_t R, ptrdiff_t C>
using fs_matrix = matrix<fs_matrix_engine<T, R, C>, matrix_operation_traits>;

}   //- Namespace std::math
~~~~


## Engine types

The over-arching purpose of the engine types is to perform resource management on behalf of 
an associated *MathObj* instance that owns the engine.  At a minimum, all of the engine types 
provide a basic interface for const element indexing, determining row and column sizes, 
determining row and column capacities, returning an equivalent `mdspan` object, and swapping. 
They also export various type aliases which specify their element type and other important 
properties.

It is important to note that an engine's resource management duties are primarily related to 
element access and secondarily to storage.  To that end, an engine may own the storage it 
manages and control its lifetime, or it may be non-owning and represent a view of storage 
owned by some other engine.

One can also imagine engines that manage resources related to execution.  This is an area of 
ongoing work and not yet addressed in this proposal.

### Engine category tag types

The various engine kinds (scalar, vector, matrix) their corresponding interface categories 
(readable, writable, initable, and resizable) are represented by the following nine engine
category type tags.

#### `scalar_engine_tag`

~~~~c++
struct scalar_engine_tag {  @_implementation-defined_@ };
~~~~

Struct `scalar_engine_tag` is used by struct template `scalar_engine` to denote that engines's
category.  As the underlying object represented by `scalar_engine` is intended to be treated 
as scalar, there are no levels of interface to distinguish.

#### `readable_vector_engine_tag`

~~~~c++
struct readable_vector_engine_tag { @_implementation-defined_@ };
~~~~

Struct `readable_vector_engine_tag` is used by vector engine types that implement the readable
vector engine interface.  Such engine types will have a public nested type alias `engine_category`
set equal to this tag type.

#### `writable_vector_engine_tag`

~~~~c++
struct writable_vector_engine_tag { @_implementation-defined_@ };
~~~~

Struct `writable_vector_engine_tag` is used by vector engine types that implement the writable
vector engine interface.  Such engine types will have a public nested type alias `engine_category`
set equal to this tag type.

#### `initable_vector_engine_tag`

~~~~c++
struct initable_vector_engine_tag { @_implementation-defined_@ };
~~~~

Struct `initable_vector_engine_tag` is used by vector engine types that implement the initable
vector engine interface.  Such engine types will have a public nested type alias `engine_category`
set equal to this tag type.

#### `resizable_vector_engine_tag`

~~~~c++
struct resizable_vector_engine_tag { @_implementation-defined_@ };
~~~~

Struct `resizable_vector_engine_tag` is used by vector engine types that implement the resizable
vector engine interface.  Such engine types will have a public nested type alias `engine_category`
set equal to this tag type.

#### `readable_matrix_engine_tag`

~~~~c++
struct readable_matrix_engine_tag { @_implementation-defined_@ };
~~~~

Struct `readable_matrix_engine_tag` is used by matrix engine types that implement the readable
matrix engine interface.  Such engine types will have a public nested type alias `engine_category`
set equal to this tag type.

#### `writable_matrix_engine_tag`

~~~~c++
struct writable_matrix_engine_tag { @_implementation-defined_@ };
~~~~

Struct `writable_matrix_engine_tag` is used by matrix engine types that implement the writable
matrix engine interface.  Such engine types will have a public nested type alias `engine_category`
set equal to this tag type.

#### `initable_matrix_engine_tag`

~~~~c++
struct initable_matrix_engine_tag { @_implementation-defined_@ };
~~~~

Struct `initable_matrix_engine_tag` is used by matrix engine types that implement the initable
matrix engine interface.  Such engine types will have a public nested type alias `engine_category`
set equal to this tag type.

#### `resizable_matrix_engine_tag`

~~~~c++
struct resizable_matrix_engine_tag { @_implementation-defined_@ };
~~~~

Struct `resizable_matrix_engine_tag` is used by matrix engine types that implement the resizable
matrix engine interface.  Such engine types will have a public nested type alias `engine_category`
set equal to this tag type.


### Variable templates pertaining to engine category tag properties

The following set of variable templates, all of which are parametrized by an engine category
tag type (`CT`), are used to determine whether or not a tag type represents certain interface 
properties.

~~~~c++
template<class CT> inline constexpr
bool    is_scalar_engine_tag_v = @_implementation-defined_@;
~~~~

Variable template `is_scalar_engine_tag_v` is equal to `true` if its template parameter `CT` is 
equal to `scalar_engine_tag`.

~~~~c++
template<class CT> inline constexpr
bool    is_vector_engine_tag_v = @_implementation-defined_@;
~~~~

Variable template `is_vector_engine_tag_v` is equal to `true` if its template parameter `CT` is 
equal to `readable_vector_engine_tag`, `writable_vector_engine_tag`, `initable_vector_engine_tag`,
or `resizable_vector_engine_tag`.

~~~~c++
template<class CT> inline constexpr
bool    is_matrix_engine_tag_v = @_implementation-defined_@;
~~~~

Variable template `is_matrix_engine_tag_v` is equal to `true` if its template parameter `CT` is 
equal to `readable_matrix_engine_tag`, `writable_matrix_engine_tag`, `initable_matrix_engine_tag`,
or `resizable_matrix_engine_tag`.

~~~~c++
template<class CT> inline constexpr
bool    is_readable_engine_tag_v = @_implementation-defined_@;
~~~~

Variable template `is_readable_engine_tag_v` is equal to `true` if either 
`is_vector_engine_v<CT> == true` or `is_matrix_engine<CT> == true`.

~~~~c++
template<class CT> inline constexpr
bool    is_writable_engine_tag_v = @_implementation-defined_@;
~~~~

Variable template `is_writable_engine_tag_v` is equal to `true` if its template parameter `CT` is 
equal to `writable_vector_engine_tag`, `writable_matrix_engine_tag`, `initable_vector_engine_tag`, 
`initable_matrix_engine_tag`, `resizable_vector_engine_tag` or `resizable_matrix_engine_tag`.

~~~~c++
template<class CT> inline constexpr
bool    is_initable_engine_tag_v = @_implementation-defined_@;
~~~~

Variable template `is_initable_engine_tag_v` is equal to `true` if its template parameter `CT` is 
equal to `initable_vector_engine_tag`, `initable_matrix_engine_tag`, `resizable_vector_engine_tag` 
or `resizable_matrix_engine_tag`.

~~~~c++
template<class CT> inline constexpr
bool    is_resizable_engine_tag_v = @_implementation-defined_@;
~~~~

Variable template `is_resizable_engine_tag_v` is equal to `true` if its template parameter `CT` is 
equal to `resizable_vector_engine_tag` or `resizable_matrix_engine_tag`.


### Variable templates pertaining to engine properties

The following set of variable templates, all of which are parametrized by an engine type
(`ET`, `ET1`, `ET2`), are used to determine whether or not en engine type represents certain 
interface properties.

~~~~c++
template<class ET> inline constexpr
bool    is_engine_v = @_implementation-defined_@;
~~~~

Variable template `is_engine_v` is equal to `true` if its template parameter `ET` has 
a nested public type alias `ET::engine_category` and that type alias is equal to one of
the nine engine category tag types described above.

~~~~c++
template<class ET> inline constexpr
bool    is_scalar_engine_v = @_implementation-defined_@;
~~~~

Variable template `is_scalar_engine_v` is equal to `true` if its template parameter `ET` has 
a nested public type alias `ET::engine_category` and that type alias is equal to 
`scalar_engine_tag`.

~~~~c++
template<class ET> inline constexpr
bool    is_vector_engine_v = @_implementation-defined_@;
~~~~

Variable template `is_vector_engine_v` is equal to `true` if its template parameter `ET` has a 
nested public type alias `ET::engine_category` and `is_vector_engine_tag_v<ET::engine_category> == true`.

~~~~c++
template<typename ET> inline constexpr
bool    is_matrix_engine_v = @_implementation-defined_@;
~~~~

Variable template `is_matrix_engine_v` is equal to `true` if its template parameter `ET` has a 
nested public type alias `ET::engine_category` and `is_matrix_engine_tag_v<ET::engine_category> == true`.

~~~~c++
template<class ET> inline constexpr
bool    is_readable_engine_v = @_implementation-defined_@;
~~~~

Variable template `is_readable_engine_v` is equal to `true` if its template parameter `ET` has a 
nested public type alias `ET::engine_category` and `is_readable_engine_tag_v<ET::engine_category> == true`.

~~~~c++
template<class ET> inline constexpr
bool    is_writable_engine_v = @_implementation-defined_@;
~~~~

Variable template `is_writable_engine_v` is equal to `true` if its template parameter `ET` has a 
nested public type alias `ET::engine_category` and `is_writable_engine_tag_v<ET::engine_category> == true`.

~~~~c++
template<class ET> inline constexpr
bool    is_initable_engine_v = @_implementation-defined_@;
~~~~

Variable template `is_initable_engine_v` is equal to `true` if its template parameter `ET` has a 
nested public type alias `ET::engine_category` and `is_initable_engine_tag_v<ET::engine_category> == true`.

~~~~c++
template<class ET> inline constexpr
bool    is_resizable_engine_v = @_implementation-defined_@;
~~~~

Variable template `is_resizable_engine_v` is equal to `true` if its template parameter `ET` has a 
nested public type alias `ET::engine_category` and `is_resizable_engine_tag_v<ET::engine_category> == true`.

~~~~c++
template<class ET1, class ET2> inline constexpr
bool    engines_are_similar_v = @_implementation-defined_@;
~~~~

Variable template `engines_are_similar_v` is equal to `true` if `is_vector_engine_v<ET1> == true &&
is_vector_engine_v<ET2> == true` or if `is_matrix_engine_v<ET1> == true && is_matrix_engine_v<ET2> == true`.



### Variable templates pertaining to engine properties

The following set of variable templates, all of which are parametrized by an engine type
(`ET`), are used to determine whether or not that type implements certain interface 
properties.


### `scalar_engine<T>`

Class template `scalar_engine<T>` is used to denote a type `T` that acts like a scalar for 
purposes of scalar multiplication and scalar division.

~~~~c++
template<class T>
struct scalar_engine
{
    using engine_category = scalar_engine_tag;
};
~~~~


### `fs_vector_engine<T, N>`

Class template `fs_vector_engine<T, N>` implements a fixed-size, fixed-capacity engine for 
vectors having `N` elements.  It implements the initable vector engine interface, providing 
member functions for mutable element indexing, swapping engine contents, and swapping 
individual elements.

~~~~c++
template<class T, ptrdiff_t N>
class fs_vector_engine
{
  public:
    using engine_category = initable_vector_engine_tag;
    using element_type    = T;
    using value_type      = remove_cv_t<T>;
    using pointer         = element_type*;
    using const_pointer   = element_type const*;
    using reference       = element_type&;
    using const_reference = element_type const&;
    using difference_type = ptrdiff_t;
    using ptrdiff_type    = ptrdiff_t;
    using span_type       = mdspan<element_type, N>;
    using const_span_type = mdspan<element_type const, N>;

    //- Construct/copy/destroy
    //
    ~fs_vector_engine() noexcept = default;

    constexpr fs_vector_engine();
    constexpr fs_vector_engine(fs_vector_engine&&) noexcept = default;
    constexpr fs_vector_engine(fs_vector_engine const&) = default;

    template<class U>
    constexpr fs_vector_engine(fs_vector_engine<U, N> const& src);              @(_see below_)@
    template<class ET2>
    constexpr fs_vector_engine(ET2 const& src);                                 @(_see below_)@
    template<class U> 
    constexpr fs_vector_engine(initializer_list<U> rhs);                        @(_see below_)@

    constexpr fs_vector_engine&   operator =(fs_vector_engine&&) noexcept = default;
    constexpr fs_vector_engine&   operator =(fs_vector_engine const&) = default;

    template<class U>
    constexpr fs_vector_engine&   operator =(fs_vector_engine<U, N> const& rhs);  @(_see below_)@
    template<class ET2>
    constexpr fs_vector_engine&   operator =(ET2 const& rhs);                     @(_see below_)@
    template<class U>
    constexpr fs_vector_engine&   operator =(initializer_list<U> rhs);            @(_see below_)@

    //- Capacity
    //
    static constexpr index_type capacity() noexcept;
    static constexpr index_type size() noexcept;

    //- Element access
    //
    constexpr reference         operator ()(index_type i);
    constexpr const_reference   operator ()(index_type i) const;

    //- Data access
    //
    constexpr span_type         span() noexcept;
    constexpr const_span_type   span() const noexcept;

    //- Modifiers
    //
    constexpr void  swap(fs_vector_engine& rhs) noexcept;
    constexpr void  swap_elements(index_type i, index_type j) noexcept;
};
~~~~

1. Parameterized constructor `fs_vector_engine(fs_vector_engine<U, N> const&)` participates 
in overload resolution only if `is_convertible_v<U, T> == true`.

1. Parameterized constructor `dr_vector_engine(ET2 const&)` participates in overload resolution
only if `is_vector_engine_v<ET2> == true` and `is_convertible_v<U, T> == true`.

1. Parameterized constructor `dr_vector_engine(initializer_list<U>)` participates in overload 
resolution only if `is_convertible_v<U, T> == true`.

1. Parameterized assignment operator `operator=(fs_vector_engine<U, N> const&)` participates 
in overload resolution only if `is_convertible_v<U, T> == true`.

1. Parameterized constructor `operator=(ET2 const&)` participates in overload resolution only
if `is_vector_engine_v<ET2> == true` and `is_convertible_v<U, T> == true`.

1. Parameterized assignment operator `operator=(initializer_list<U>)` participates in overload 
resolution only if `is_convertible_v<U, T> == true`.


### `fs_matrix_engine<T, R, C>`

Class template `fs_matrix_engine<T, R, C>` implements a fixed-size, 
fixed-capacity engine for matrices having `R` rows and `C` columns. 
In addition to the basic engine interface, it provides member functions 
for mutable element indexing, swapping engine contents, swapping columns, 
and swapping rows.

~~~~c++
template<class T, ptrdiff_t R, ptrdiff_t C>
class fs_matrix_engine
{
  public:
    //- Types
    //
    using engine_category  = initable_matrix_engine_tag;
    using value_type       = T;
    using element_type     = value_type;
    using pointer          = element_type*;
    using const_pointer    = element_type const*;
    using reference        = element_type&;
    using const_reference  = element_type const&;
    using difference_type  = ptrdiff_t;
    using index_type       = ptrdiff_t;
    using index_tuple_type = tuple<index_type, index_type>;
    using span_type        = mdspan<element_type, R, C>;
    using const_span_type  = mdspan<element_type const, R, C>;

    //- Construct/copy/destroy
    //
    ~fs_matrix_engine() noexcept = default;

    constexpr fs_matrix_engine();
    constexpr fs_matrix_engine(fs_matrix_engine&&) noexcept = default;
    constexpr fs_matrix_engine(fs_matrix_engine const&) = default;

    template<class U>
    constexpr fs_matrix_engine(fs_matrix_engine<U, R, C> const& rhs);           @(_see below_)@
    template<class ET2>
    constexpr fs_matrix_engine(ET2 const& rhs);                                 @(_see below_)@
    template<class U>
    constexpr fs_matrix_engine(initializer_list<initializer_list<U>> rhs);      @(_see below_)@

    constexpr fs_matrix_engine&   operator =(fs_matrix_engine&&) noexcept = default;
    constexpr fs_matrix_engine&   operator =(fs_matrix_engine const&) = default;

    template<class U>
    constexpr fs_matrix_engine&   operator =(fs_matrix_engine<U, R, C> const& rhs);       @(_see below_)@
    template<class ET2>
    constexpr fs_matrix_engine&   operator =(ET2 const& rhs);                             @(_see below_)@
    template<class U>
    constexpr fs_matrix_engine&   operator =(initializer_list<initializer_list<U>> rhs);  @(_see below_)@

    //- Size and capacity
    //
    static constexpr index_type         columns()noexcept;
    static constexpr index_type         rows() noexcept;
    static constexpr index_tuple_type   size() noexcept;

    static constexpr index_type         column_capacity() noexcept;
    static constexpr index_type         row_capacity() noexcept;
    static constexpr index_tuple_type   capacity() noexcept;

    //- Element access
    //
    constexpr reference         operator ()(index_type i, index_type j);
    constexpr const_reference   operator ()(index_type i, index_type j) const;

    //- Data access
    //
    constexpr fs_matrix_engine&         owning_engine() noexcept;
    constexpr fs_matrix_engine const&   owning_engine() const noexcept;

    constexpr span_type                 span() noexcept;
    constexpr const_span_type           span() const noexcept;

    //- Modifiers
    //
    constexpr void      swap(fs_matrix_engine& rhs) noexcept;
    constexpr void      swap_columns(index_type j1, index_type j2) noexcept;
    constexpr void      swap_rows(index_type i1, index_type i2) noexcept;
};
~~~~

Notes regarding member functions:

1. Parameterized constructor `fs_matrix_engine(fs_matrix_engine<U, R, C> const&)` participates 
in overload resolution only if `is_convertible_v<U, T> == true`.

1. Parameterized constructor `dr_matrix_engine(ET2 const&)` participates in overload resolution
only if `is_matrix_engine_v<ET2> == true` and `is_convertible_v<U, T> == true`.

1. Parameterized constructor `dr_matrix_engine(initializer_list<initializer_list<U>>)` participates 
in overload resolution only if `is_convertible_v<U, T> == true`.

1. Parameterized assignment operator `operator=(fs_matrix_engine<U, R, C> const&)` participates 
in overload resolution only if `is_convertible_v<U, T> == true`.

1. Parameterized constructor `operator=(ET2 const&)` participates in overload resolution only
if `is_matrix_engine_v<ET2> == true` and `is_convertible_v<U, T> == true`.

1. Parameterized assignment operator `operator=(initializer_list<initializer_list<U>>)`  
participates in overload resolution only if `is_convertible_v<U, T> == true`.


### `dr_vector_engine<T, AT>`

Class template `dr_vector_engine<T, AT>` implements an engine for vectors whose sizes and 
capacities can be changed at runtime. It exhibits the resizable vector engine interface, 
providing member functions for mutable element indexing, swapping engine contents, 
swapping individual elements, resizing, and reserving excess capacity.

~~~~c++
template<class T, class AT>
class dr_vector_engine
{
  public:
    //- Types
    //
    using engine_category = resizable_vector_engine_tag;
    using value_type      = T;
    using allocator_type  = AT;
    using element_type    = value_type;
    using pointer         = typename allocator_traits<AT>::pointer;
    using const_pointer   = typename allocator_traits<AT>::const_pointer;
    using reference       = element_type&;
    using const_reference = element_type const&;
    using difference_type = ptrdiff_t;
    using index_type      = ptrdiff_t;
    using span_type       = mdspan<element_type, dynamic_extent>;
    using const_span_type = mdspan<element_type const, dynamic_extent>;

    //- Construct/copy/destroy
    //
    ~dr_vector_engine() noexcept;

    dr_vector_engine();
    dr_vector_engine(dr_vector_engine&& rhs) noexcept;
    dr_vector_engine(dr_vector_engine const& rhs);
    dr_vector_engine(index_type elems);
    dr_vector_engine(index_type elems, index_type elem_cap);

    template<class ET2>
    dr_vector_engine(ET2 const& rhs);                                           @(_see below_)@
    template<class T2>
    dr_vector_engine(initializer_list<T2> rhs);                                 @(_see below_)@

    dr_vector_engine&   operator =(dr_vector_engine&& rhs) noexcept;
    dr_vector_engine&   operator =(dr_vector_engine const& rhs);

    template<class ET2>
    dr_vector_engine&   operator =(ET2 const& rhs);                             @(_see below_)@
    template<class T2>
    dr_vector_engine&   operator =(initializer_list<T2> rhs);                   @(_see below_)@

    //- Capacity
    //
    index_type      capacity() const noexcept;
    index_type      size() const noexcept;
    void            reserve(index_type cap);
    void            resize(index_type elems);
    void            resize(index_type elems, index_type cap);

    //- Element access
    //
    reference       operator ()(index_type i);
    const_reference operator ()(index_type i) const;

    //- Data access
    //
    span_type       span() noexcept;
    const_span_type span() const noexcept;

    //- Modifiers
    //
    void    swap(dr_vector_engine& rhs) noexcept;
    void    swap_elements(index_type i, index_type j) noexcept;
};
~~~~

Notes regarding member functions:

1. Parameterized constructor `dr_vector_engine(ET2 const&)` participates in overload resolution
only if `is_vector_engine_v<ET2> == true` and `is_convertible_v<U, T> == true`.

1. Parameterized constructor `dr_vector_engine(initializer_list<U>)` participates in overload 
resolution only if `is_convertible_v<U, T> == true`.

1. Parameterized constructor `operator=(ET2 const&)` participates in overload resolution only
if `is_vector_engine_v<ET2> == true` and `is_convertible_v<U, T> == true`.

1. Parameterized assignment operator `operator=(initializer_list<U>)`  participates in overload 
resolution only if `is_convertible_v<U, T> == true`.


### `dr_matrix_engine<T, AT>`

Class template `dr_matrix_engine<T, AT>` implements an owning engine for matrices whose sizes 
and capacities can be changed at runtime.  It exhibits the resizable matrix engine interface, 
providing member functions for mutable element indexing, swapping engine contents, swapping 
columns, swapping rows, resizing, and reserving excess capacity.

~~~~c++
template<class T, class AT>
class dr_matrix_engine
{
  public:
    //- Types
    //
    using engine_category = resizable_matrix_engine_tag;
    using value_type      = T;
    using allocator_type  = AT;
    using element_type    = value_type;
    using pointer         = typename allocator_traits<AT>::pointer;
    using const_pointer   = typename allocator_traits<AT>::const_pointer;
    using reference       = element_type&;
    using const_reference = element_type const&;
    using difference_type = ptrdiff_t;
    using index_type      = ptrdiff_t;
    using size_tuple      = tuple<index_type, index_type>;
    using span_type       = basic_mdspan<T, extents<dynamic_extent, dynamic_extent>>;
    using const_span_type = basic_mdspan<T const, extents<dynamic_extent, dynamic_extent>>;

    //- Construct/copy/destroy
    //
    ~dr_matrix_engine() noexcept;

    dr_matrix_engine();
    dr_matrix_engine(dr_matrix_engine&& rhs) noexcept;
    dr_matrix_engine(dr_matrix_engine const& rhs);
    dr_matrix_engine(index_type rows, index_type cols);
    dr_matrix_engine(index_type rows, index_type cols, 
                     index_type rowcap, index_type colcap);

    template<class ET2> 
    dr_matrix_engine(ET2 const& rhs);                                           @(_see below_)@
    template<class U>
    dr_matrix_engine(initializer_list<initializer_list<U>> rhs);                @(_see below_)@

    dr_matrix_engine&   operator =(dr_matrix_engine&&) noexcept;
    dr_matrix_engine&   operator =(dr_matrix_engine const&);

    template<class ET2>
    dr_matrix_engine&   operator =(ET2 const& rhs);                             @(_see below_)@
    template<class U>
    dr_matrix_engine&   operator =(initializer_list<initializer_list<U>> rhs);  @(_see below_)@

    //- Capacity
    //
    index_type  columns() const noexcept;
    index_type  rows() const noexcept;
    size_tuple  size() const noexcept;

    index_type  column_capacity() const noexcept;
    index_type  row_capacity() const noexcept;
    size_tuple  capacity() const noexcept;

    void        reserve(index_type rowcap, index_type colcap);
    void        resize(index_type rows, index_type cols);
    void        resize(index_type rows, index_type cols, 
                       index_type rowcap, index_type colcap);

    //- Element access
    //
    reference       operator ()(index_type i, index_type j);
    const_reference operator ()(index_type i, index_type j) const;

    //- Data access
    //
    span_type       span() noexcept;
    const_span_type span() const noexcept;

    //- Modifiers
    //
    void    swap(dr_matrix_engine& other) noexcept;
    void    swap_columns(index_type c1, index_type c2) noexcept;
    void    swap_rows(index_type r1, index_type r2) noexcept;
};
~~~~

Notes regarding member functions:

1. Parameterized constructor `dr_matrix_engine(ET2 const&)` participates in overload resolution
only if `is_matrix_engine_v<ET2> == true` and `is_convertible_v<U, T> == true`.

1. Parameterized constructor `dr_matrix_engine(initializer_list<initializer_list<U>>)` participates 
in overload resolution only if `is_convertible_v<U, T> == true`.

1. Parameterized constructor `operator=(ET2 const&)` participates in overload resolution only
if `is_matrix_engine_v<ET2> == true` and `is_convertible_v<U, T> == true`.

1. Parameterized assignment operator `operator=(initializer_list<initializer_list<U>>)`  
participates in overload resolution only if `is_convertible_v<U, T> == true`.


### `vector_view_engine<ET, VCT, VFT>`

Class template `vector_view_engine<ET, VCT, VFT>` implements a non-owning engine that implements 
at least the readable vector engine interface, and possibly the writable vector engine interface, 
depending on the underlying engine type `ET`, the view category tag type `VCT`, and the view
function tag type `VFT`.  Its purpose is to provide a view of a vector with an element 
transformation specifed by `VFT`.  The possible transformations are negation, hermitian 
(conjugate transpose), subset (subvector), column, and row.

~~~~c++
template<class ET, class VCT, class VFT>
class vector_view_engine
{
  public:
    //- Type aliases pertaining to the underlying engine type.
    //
    using engine_type        = ET;                                              (@_see below_@)
    using owning_engine_type = (@_see below_@);

    //- Type aliases pertaining to this view engine type.
    //
    using engine_category  = VCT;
    using element_type     = typename ET::element_type;
    using value_type       = typename ET::value_type;
    using pointer          = (@_see below_@);
    using const_pointer    = typename ET::const_pointer;
    using reference        = (@_see below_@);
    using const_reference  = typename ET::const_reference;
    using difference_type  = typename ET::difference_type;
    using index_type       = typename ET::index_type;
    using index_tuple_type = typename ET::index_tuple_type;
    using span_type        = (@_see below_@);
    using const_span_type  = (@_see below_@);

    //- Construct/copy/destroy
    //
    ~vector_view_engine() noexcept = default;

    constexpr vector_view_engine() noexcept;                                    (@_see below_@)
    constexpr vector_view_engine(vector_view_engine&&) noexcept = default;
    constexpr vector_view_engine(vector_view_engine const&) noexcept = default;

    explicit constexpr vector_view_engine(engine_type const& eng);
    explicit constexpr vector_view_engine(owning_engine_type const& eng);       (@_see below_@)

    constexpr vector_view_engine(engine_type& eng,                              (@_see below_@)
                                 index_type i, index_type n);
    constexpr vector_view_engine(engine_type const& eng,                        (@_see below_@)
                                 index_type i, index_type n);

    template<class ET2
    constexpr vector_view_engine&     operator =(ET2 const& rhs);               (@_see below_@)
    template<class U> 
    constexpr vector_view_engine&     operator =(initializer_list<U> rhs);      (@_see below_@)

    //- Capacity
    //
    constexpr size_type     capacity() const noexcept;
    constexpr size_type     size() const noexcept;

    //- Element access
    //
    constexpr reference     operator ()(size_type i) const;                     (@_see below_@)

    //- Data access
    //
    constexpr span_type     span() const noexcept;                              (@_see below_@)

    //- Modifiers
    //
    constexpr void          swap(vector_view_engine& rhs);
};
~~~~

Notes regarding template parameters:

1. The program is ill-formed if `is_matrix_engine_v<ET> == false` and `is_vector_engine<ET> == false`.

1. Only the following combinations of engine properties, vector view category tag (`VCT`) and 
vector view function tag (`VFT`) are permitted; otherwise, the program is ill-formed:

--------------------------------------------------------------------------------------------------------------------------------------
 `ET` is Writable    `ET` Implements    View Category Tag (`VCT`)       View Function Tag (`VFT`)   Purpose
------------------  -----------------  ------------------------------  ---------------------------  ----------------------------------
  `true`/`false`     vector engine      `readable_vector_engine_tag`    `negation_view_tag`         Read-only view of the negation of 
                                                                                                    represented elements

  `true`/`false`     vector engine      `readable_vector_engine_tag`    `hermitian_view_tag`        Read-only view of the conjugate 
                                                                                                    transpose of represented elements

  `true`/`false`     vector engine      `readable_vector_engine_tag`    `subset_view_tag`           Read-only view of a subset of 
                                                                                                    its represented elements
 
 `true`              vector engine      `writable_vector_engine_tag`    `subset_view_tag`           Read-write view of a subset of 
                                                                                                    represented elements

  `true`/`false`     matrix engine      `readable_vector_engine_tag`    `column_view_tag`           Read-only view of a column of
                                                                                                    represented elements

  `true`             matrix engine      `writable_vector_engine_tag`    `column_view_tag`           Read-write view of a column of
                                                                                                    represented elements

  `true`/`false`     matrix engine      `readable_vector_engine_tag`    `row_view_tag`              Read-only view of a row of
                                                                                                    represented elements

  `true`             matrix engine      `writable_vector_engine_tag`    `row_view_tag`              Read-write view of a row of
                                                                                                    represented elements

--------------------------------------------------------------------------------------------------------------------------------------

> In other words, element write-through to the underlying engine object being transformed by
> a view object is possible only if that engine is of a writable type, the category tag for
> the view indicates writability, and the view function type is `subset`, `column`, or
> `row`.  Otherwise, all other possible view types are non-writable.

Notes regarding nested type aliases:

1. For type alias `owning_engine_type`: 

    - if `is_owning_engine_v<ET> == true`, then `owning_engine_type` is equal to `engine_type`; 

    - otherwise it is equal to `engine_type::owning_engine_type`.

1. For type alias `pointer`:

    - if `is_writable_engine_v<ET> == true` and `is_writable_engine_tag_v<VCT> == true`, then 
    `pointer` is equal to `engine_type::pointer`;

    - otherwise, `pointer` is equal to `engine_type::const_pointer`.

1. For type alias `reference`:

    - if `is_writable_engine_v<ET> == true` and `is_writable_engine_tag_v<VCT> == true`, then 
    `reference` is equal to `engine_type::reference`;

    - otherwise, `reference` is equal to `engine_type::const_reference`.

1. For type alias `span_type`: 

    - if type `engine_type::span_type` is defined, then `span_type` is equal to `engine_type::span_type`; 

    - otherwise, `span_type` is equal to `void`.

1. For type alias `const_span_type`: 

    - if type `engine_type::const_span_type` is defined, then `const_span_type` is equal to 
    `engine_type::const_span_type`; 

    - otherwise, `const_span_type` is equal to `void`.

Notes regarding member functions:

1. If `is_same_v<VFT,subset_view_tag> == false`, then constructor `matrix_view_engine()` 
is `= default` .

1. Constructor `vector_view_engine(owning_engine_type const&)` participates in overload 
resolution only if `is_owning_engine_v<ET> == false`.

1. Constructor `vector_view_engine(engine_type const&, index_type, index_type)` 
participates in overload resolution only if `is_same_v<VFT, subset_view_tag> == true`.

1. Constructor `vector_view_engine(engine_type&, index_type, index_type)` 
participates in overload resolution only if `is_writable_engine_v<ET> == true` and 
`is_writable_engine_tag_v<VCT> == true` and `is_same_v<VFT, subset_view_tag> == true`.

1. Parameterized assignment operator `operator=(ET2 const&)` participates in overload resolution 
only if `is_writable_engine_v<ET> == true` and `is_writable_engine_tag_v<VCT> == true`.

1. Parameterized assignment operator `operator=(initializer_list<U>)` participates in overload 
resolution only if `is_writable_engine_v<ET> == true` and `is_writable_engine_tag<VCT> == true`.

1. Member function `span()` participates in overload resolution only if 
`is_same_v<span_type,void> == false`.


### `matrix_view_engine<ET, MCT, VFT>`

Class template `matrix_view_engine<ET, MCT, VFT>` implements a non-owning engine that implements 
at least the readable matrix engine interface, and possibly the writable matrix engine interface, 
depending on the underlying engine type `ET`, the view category tag type `MCT`, and the view
function tag type `VFT`.  Its purpose is to provide a view of a matrix with an element 
transformation specifed by `VFT`.  The possible transformations are negation, transpose, 
hermitian (conjugate transpose), and subset (submatrix).

~~~~c++
template<class ET, class MCT, class VFT>
class matrix_view_engine
{
  public:
    //- Type aliases pertaining to the underlying engine type.
    //
    using engine_type        = ET;                                              (@_see below_@)
    using owning_engine_type = (@_see below_@);

    //- Type aliases pertaining to this view engine type.
    //
    using engine_category  = MCT;
    using element_type     = typename ET::element_type;
    using value_type       = typename ET::value_type;
    using pointer          = (@_see below_@);
    using const_pointer    = typename ET::const_pointer;
    using reference        = (@_see below_@);
    using const_reference  = typename ET::const_reference;
    using difference_type  = typename ET::difference_type;
    using index_type       = typename ET::index_type;
    using index_tuple_type = typename ET::index_tuple_type;
    using span_type        = (@_see below_@);
    using const_span_type  = (@_see below_@);

    //- Construct/copy/destroy
    //
    ~matrix_view_engine() noexcept = default;

    constexpr matrix_view_engine() noexcept;                                    (@_see below_@)
    constexpr matrix_view_engine(matrix_view_engine&&) noexcept = default;
    constexpr matrix_view_engine(matrix_view_engine const&) noexcept = default;

    explicit constexpr matrix_view_engine(engine_type const& eng);
    explicit constexpr matrix_view_engine(owning_engine_type const& eng);       (@_see below_@)

    constexpr matrix_view_engine(engine_type& eng,                              (@_see below_@)
                                 index_type ri, index_type rn, 
                                 index_type ci, index_type cn);
    constexpr matrix_view_engine(engine_type const& eng,                        (@_see below_@)
                                 index_type ri, index_type rn, 
                                 index_type ci, index_type cn);

    template<class ET2
    constexpr matrix_view_engine&     operator =(ET2 const& rhs);               (@_see below_@)
    template<class U> 
    constexpr matrix_view_engine&                                               (@_see below_@)
                    operator =(initializer_list<initializer_list<U>> rhs);

    //- Capacity
    //
    constexpr index_type        columns() const noexcept;
    constexpr index_type        rows() const noexcept;
    constexpr index_tuple_type  size() const noexcept;

    constexpr index_type        column_capacity() const noexcept;
    constexpr index_type        row_capacity() const noexcept;
    constexpr index_tuple_type  capacity() const noexcept;

    //- Element access
    //
    constexpr reference     operator ()(index_type i, index_type j) const;      (@_see below_@)

    //- Data access
    //
    constexpr span_type     span() const noexcept;                              (@_see below_@)

    //- Modifiers
    //
    constexpr void          swap(matrix_view_engine& rhs);
};
~~~~

Notes regarding template parameters:

1. If `is_matrix_engine_v<ET> == false`, the program is ill-formed.

1. Only the following combinations of engine properties, matrix view category tag (`MCT`) and 
matrix view function tag (`VFT`) are permitted; otherwise, the program is ill-formed:

-------------------------------------------------------------------------------------------------------------------------------
 `ET` is Writable    View Category Tag (`MCT`)       View Function Tag (`VFT`)   Purpose
------------------  ------------------------------  ---------------------------  -------------------------------------
 `true`/`false`      `readable_matrix_engine_tag`    `negation_view_tag`         Read-only view of the negation of 
                                                                                 represented elements

 `true`/`false`      `readable_matrix_engine_tag`    `transpose_view_tag`        Read-only view of the transpose of
                                                                                 represented elements

 `true`/`false`      `readable_vector_engine_tag`    `hermitian_view_tag`        Read-only view of the conjugate 
                                                                                 transpose of represented elements

 `true`/`false`      `readable_vector_engine_tag`    `subset_view_tag`           Read-only view of a subset of 
                                                                                 its represented elements
 
 `true`              `writable_vector_engine_tag`    `subset_view_tag`           Read-write view of a subset of 
                                                                                 represented elements

-------------------------------------------------------------------------------------------------------------------------------

> In other words, element write-through to the underlying engine object being transformed by
> a view object is possible only if that engine type is writable, and the engine category tag 
> for the view indicates writability, and the view function type is `subset`.  Otherwise, all
> views are only readable.

Notes regarding nested type aliases:

1. For type alias `owning_engine_type`: 

    - if `is_owning_engine_v<ET> == true`, then `owning_engine_type` is equal to `engine_type`; 

    - otherwise it is equal to `engine_type::owning_engine_type`.

1. For type alias `pointer`:

    - if `is_writable_engine_v<ET> == true` and `is_writable_engine_tag_v<MCT> == true`, then 
    `pointer` is equal to `engine_type::pointer`;

    - otherwise, `pointer` is equal to `engine_type::const_pointer`.

1. For type alias `reference`:

    - if `is_writable_engine_v<ET> == true` and `is_writable_engine_tag_v<MCT> == true`, then 
    `reference` is equal to `engine_type::reference`;

    - otherwise, `reference` is equal to `engine_type::const_reference`.

1. For type alias `span_type`: 

    - if types `engine_type::span_type` and `engine_type::const_span_type` are both defined,
    then `span_type` is equal to `engine_type::span_type`; 

    - otherwise, `span_type` is equal to `void`.

1. For type alias `const_span_type`: 

    - if types `engine_type::const_span_type` and `engine_type::span_type` are both defined, 
    then `const_span_type` is equal to `engine_type::const_span_type`; 

    - otherwise, `const_span_type` is equal to `void`.

Notes regarding member functions:

1. If `is_same_v<VFT,subset_view_tag> == false`, then constructor `matrix_view_engine()` 
is `= default` .

1. Constructor `matrix_view_engine(owning_engine_type const&)` participates in overload 
resolution only if `is_owning_engine_v<ET> == false`.

1. Constructor `matrix_view_engine(engine_type const&, index_type, index_type, index_type, index_type)` 
participates in overload resolution only if `is_same_v<VFT, subset_view_tag> == true`.

1. Constructor `matrix_view_engine(engine_type&, index_type, index_type, index_type, index_type)` 
participates in overload resolution only if `is_writable_engine_v<ET> == true` and 
`is_writable_engine_tag_v<MCT> == true` and `is_same_v<VFT, subset_view_tag> == true`.

1. Parameterized assignment operator `operator=(ET2 const&)` participates in overload resolution 
only if `is_writable_engine_v<ET> == true` and `is_writable_engine_tag_v<MCT> == true`.

1. Parameterized assignment operator `operator=(initializer_list<initializer_list<U>>)` 
participates in overload resolution only if `is_writable_engine_v<ET> == true`
and `is_writable_engine_tag<MCT> == true`.

1. Member function `span()` participates in overload resolution only if 
`is_same_v<span_type,void> == false`.


## Math object types

### `vector<ET, OT>` 

Class template `vector<ET, OT>` represents a vector, with element type and 
resource management implemented by the engine type `ET`, and arithmetic 
operations specified by the operation traits type `OT`.  If the underlying 
engine type provides dynamic resizing, then this class will as well. 

~~~~c++
template<class ET, class OT>
class vector
{
  public:
    //- Types
    //
    using engine_type          = ET;                                            (@_see below_@)
    using owning_engine_type   = (@_see below_@);
    using element_type         = typename engine_type::element_type;
    using value_type           = typename engine_type::value_type;
    using difference_type      = typename engine_type::difference_type;
    using index_type           = typename engine_type::index_type;
    using pointer              = typename engine_type::pointer;
    using const_pointer        = typename engine_type::const_pointer;
    using reference            = typename engine_type::reference;
    using const_reference      = typename engine_type::const_reference;
    using span_type            = (@_see below_@);
    using const_span_type      = (@_see below_@);

    using const_transpose_type = vector const&;
    using const_hermitian_type = (@_see below_@);
    using const_subvector_type = vector<subvector_engine<engine_type, @_see below_@>, OT>;

    //- Construct/copy/destroy
    //
    ~vector() = default;

    constexpr vector();
    constexpr vector(vector&&) noexcept = default;
    constexpr vector(vector const&) = default;

    template<class ET2, class OT2>
    constexpr vector(vector<ET2, OT2> const& src);
    template<class U>
    constexpr vector(initializer_list<U> list);                                 (@_see below_@)
    constexpr vector(index_type elems);                                         (@_see below_@)
    constexpr vector(index_type elems, index_type elemcap);                     (@_see below_@)

    constexpr vector&   operator =(vector&&) noexcept = default;
    constexpr vector&   operator =(vector const&) = default;
    
    template<class ET2, class OT2>
    constexpr vector&   operator =(vector<ET2, OT2> const& rhs);
    template<class U>                                       
    constexpr vector&   operator =(initializer_list<U> rhs);                    (@_see below_@)

    //- Capacity
    //
    constexpr index_type    capacity() const noexcept;
    constexpr index_type    size() const noexcept;

    constexpr void          reserve(index_type elemcap);                        (@_see below_@)
    constexpr void          resize(index_type elems);                           (@_see below_@)
    constexpr void          resize(index_type elems, index_type elemcap);       (@_see below_@)

    //- Element access
    //
    constexpr reference             operator [](index_type i);
    constexpr reference             operator ()(index_type i);
    constexpr const_reference       operator [](index_type i) const;
    constexpr const_reference       operator ()(index_type i) const;

    constexpr const_negation_type   operator -() const;
    constexpr const_transpose_type  t() const;
    constexpr const_hermitian_type  h() const;

    constexpr subvector_type        subvector(index_type i, index_type n) noexcept;
    constexpr const_subvector_type  subvector(index_type i, index_type n) const noexcept;

    //- Data access
    //
    constexpr engine_type&              engine() noexcept;
    constexpr engine_type const&        engine() const noexcept;

    constexpr owing_engine_type&        owning_engine() noexcept;
    constexpr owning_engine_type const& owning_engine() const noexcept;

    constexpr span_type                 span() noexcept;                        (@_see below_@)
    constexpr const_span_type           span() const noexcept;                  (@_see below_@)

    //- Modifiers
    //
    constexpr void      swap(vector& rhs) noexcept;
    constexpr void      swap_elements(index_type i, index_type j) noexcept;     (@_see below_@)
};
~~~~

Notes regarding template parameters:

1. If `is_vector_engine_v<ET> == false`, the program is ill-formed.

Notes regarding nested type aliases:

1. For type alias `owning_engine_type`: 

    - if `is_owning_engine_v<engine_type> == true`, then `owning_engine_type` is equal to 
`engine_type`; 

    - otherwise it is equal to `engine_type::owning_engine_type`.

1. For type alias `span_type`: 

    - if type `engine_type::span_type` is defined, then `span_type` is equal to 
`engine_type::span_type`; 

    - otherwise, `span_type` is equal to `void`.

1. For type alias `const_span_type`: 

    - if type `engine_type::const_span_type` is defined, then `const_span_type` is equal to 
`engine_type::const_span_type`; 

    - otherwise, `const_span_type` is equal to `void`.

1. For type alias `const_hermitian_type`:

    - if, for some type `U`, `element_type` is a specialization of `complex<U>`, then 
`const_hermitian_type` is equal to `matrix<matrix_hermitian_engine<engine_type>, OT>`;

    - otherwise, `const_hermitian_type` is equal to `const_transpose_type`.

1. For type alias `subvector_type`: 

    - if `is_writable_engine_v<engine_type> == true`, then the matrix engine tag type to be used 
as the second template argument to `vector_subset_engine` is `writable_vector_engine_tag`;

    - otherwise, the tag type is `readable_vector_engine_tag`.

Notes regarding member functions:

1. Parameterized constructor `vector(initializer_list<U>)` participates in 
overload resolution only if `is_initable_engine_v<engine_type> == true`.

1. Overloaded constructors with size and capacity parameters participate in overload resolution 
only if `is_resizable_engine_v<engine_type> == true`.

1. Parameterized assignment operator `operator=(initializer_list<U>)`  participates in overload 
resolution only if `is_writable_engine_v<engine_type> == true`.

1. Member function `reserve()` participates in overload resolution only if 
`is_resizable_engine_v<engine_type> == true`;

1. Overloads of member function `resize()` participate in overload resolution only if 
`is_resizable_engine_v<engine_type> == true`;

1. Overloads of member function `span()` participate in overload resolution only if 
`is_same_v<span_type,void> == false && is_same_v<const_span_type,void> == false`.

1. Member function `swap_elements()` participates in overload resolution only if 
`is_writable_engine_v<engine_type> == true`.


### `matrix<ET, OT>` 

Class template `matrix<ET, OT>`represents a matrix, with element type, element access, and 
underlying resource management implemented by the engine type `ET`, and arithmetic operations 
specified by the operation traits type `OT`.  If the underlying  engine type provides dynamic 
resizing, then this class will as well. 

~~~~c++
template<class ET, class OT>
class matrix
{
  public:
    //- Types
    //
    using engine_type          = ET;                                            (@_see below_@)
    using owning_engine_type   = (@_see below_@);
    using element_type         = typename engine_type::element_type;
    using value_type           = typename engine_type::value_type;
    using reference            = typename engine_type::reference;
    using const_reference      = typename engine_type::const_reference;
    using difference_type      = typename engine_type::difference_type;
    using index_type           = typename engine_type::index_type;
    using index_tuple_type     = typename engine_type::index_tuple_type;
    using span_type            = (@_see below_@);
    using const_span_type      = (@_see below_@);

    using const_negation_type  = matrix<matrix_negation_engine<engine_type>, OT>;
    using const_transpose_type = matrix<matrix_transpose_engine<engine_type>, OT>;
    using const_hermitian_type = (@_see below_@);

    using column_type          = vector<matrix_column_engine<engine_type, (@_see below_@)>, OT>;
    using const_column_type    = vector<matrix_column_engine<engine_type, readable_vector_engine_tag>, OT>;
    using row_type             = vector<matrix_row_engine<engine_type, (@_see below_@)>, OT>;
    using const_row_type       = vector<matrix_row_engine<engine_type, readable_vector_engine_tag>, OT>;
    using submatrix_type       = matrix<matrix_subset_engine<engine_type, (@_see below_@)>, OT>;
    using const_submatrix_type = matrix<matrix_subset_engine<engine_type, readable_matrix_engine_tag>, OT>;

    //- Construct/copy/destroy
    //
    ~matrix() noexcept = default;

    constexpr matrix() = default;
    constexpr matrix(matrix&&) noexcept = default;
    constexpr matrix(matrix const&) = default;

    template<class ET2, class OT2>
    constexpr matrix(matrix<ET2, OT2> const& rhs);
    constexpr matrix(initializer_list<initializer_list<U>> rhs);                (@_see below_@)

    explicit constexpr matrix(index_tuple_type size);                           (@_see below_@)
    constexpr matrix(index_type rows, index_type cols);                         (@_see below_@)
    constexpr matrix(index_tuple_type size, index_tuple_type cap);              (@_see below_@)
    constexpr matrix(index_type rows, index_type cols, 
                     index_type rowcap, index_type colcap);                     (@_see below_@)

    constexpr matrix&   operator =(matrix&&) noexcept = default;
    constexpr matrix&   operator =(matrix const&) = default;

    template<class ET2, class OT2>
    constexpr matrix&   operator =(matrix<ET2, OT2> const& rhs);
    template<class U>
    constexpr matrix&   operator =(initializer_list<initializer_list<U>> rhs);  (@_see below_@)

    //- Capacity
    //
    constexpr index_type        columns() const noexcept;
    constexpr index_type        rows() const noexcept;
    constexpr index_tuple_type  size() const noexcept;

    constexpr index_type        column_capacity() const noexcept;
    constexpr index_type        row_capacity() const noexcept;
    constexpr index_tuple_type  capacity() const noexcept;

    constexpr void      reserve(index_tuple_type cap);                          (@_see below_@)
    constexpr void      reserve(index_type rowcap, index_type colcap);          (@_see below_@)

    constexpr void      resize(index_tuple_type size);                          (@_see below_@)
    constexpr void      resize(index_type rows, index_type cols);               (@_see below_@)
    constexpr void      resize(index_tuple_type size, index_tuple_type cap);    (@_see below_@)
    constexpr void      resize(index_type rows, index_type cols, 
                               index_type rowcap, index_type colcap);           (@_see below_@)

    //- Element access
    //
    constexpr reference             operator ()(index_type i, index_type j);
    constexpr const_reference       operator ()(index_type i, index_type j) const;

    constexpr const_negation_type   operator -() const noexcept;
    constexpr const_transpose_type  t() const noexcept;
    constexpr const_hermitian_type  h() const;

    constexpr column_type           column(index_type j) noexcept;
    constexpr const_column_type     column(index_type j) const noexcept;
    constexpr row_type              row(index_type i) noexcept;
    constexpr const_row_type        row(index_type i) const noexcept;
    constexpr submatrix_type        submatrix(index_type ri, index_type rn, 
                                              index_type ci, index_type cn) noexcept;
    constexpr const_submatrix_type  submatrix(index_type ri, index_type rn, 
                                              index_type ci, index_type cn) const noexcept;

    //- Data access
    //
    constexpr engine_type&              engine() noexcept;
    constexpr engine_type const&        engine() const noexcept;

    constexpr owning_engine_type&       owning_engine() noexcept;
    constexpr owning_engine_type const& owning_engine() const noexcept;

    constexpr span_type                 span() noexcept;                        (@_see below_@)
    constexpr const_span_type           span() const noexcept;                  (@_see below_@)

    //- Modifiers
    //
    constexpr void      swap(matrix& rhs) noexcept;
    constexpr void      swap_columns(index_type c1, index_type c2) noexcept;    (@_see below_@)
    constexpr void      swap_rows(index_type r1, index_type r2) noexcept;       (@_see below_@)
};
~~~~

Notes regarding template parameters:

1. If `is_matrix_engine_v<ET> == false`, the program is ill-formed.

Notes regarding nested type aliases:

1. For type alias `owning_engine_type`: 

    - if `is_owning_engine_v<engine_type> == true`, then `owning_engine_type` is equal to 
`engine_type`; 

    - otherwise it is equal to `engine_type::owning_engine_type`.

1. For type alias `span_type`: 

    - if type `engine_type::span_type` is defined, then `span_type` is equal to 
`engine_type::span_type`; 

    - otherwise, `span_type` is equal to `void`.

1. For type alias `const_span_type`: 

    - if type `engine_type::const_span_type` is defined, then `const_span_type` is equal to 
`engine_type::const_span_type`; 

    - otherwise, `const_span_type` is equal to `void`.

1. For type alias `const_hermitian_type`:

    - if, for some type `U`, `element_type` is a specialization of `complex<U>`, then 
`const_hermitian_type` is equal to `matrix<matrix_hermitian_engine<engine_type>, OT>`;

    - otherwise, `const_hermitian_type` is equal to `const_transpose_type`.

1. For type alias `column_type`: 

    - if `is_writable_engine_v<engine_type> == true`, then the matrix engine tag type to be used 
as the second template argument to `matrix_column_engine` is `writable_vector_engine_tag`;

    - otherwise, the tag type is `readable_vector_engine_tag`.

1. For type alias `row_type`: 

    - if `is_writable_engine_v<engine_type> == true`, then the matrix engine tag type to be used 
as the second template argument to `matrix_row_engine` is `writable_vector_engine_tag`;

    - otherwise, the tag type is `readable_vector_engine_tag`.

1. For type alias `submatrix_type`: 

    - if `is_writable_engine_v<engine_type> == true`, then the matrix engine tag type to be used 
as the second template argument to `matrix_subset_engine` is `writable_matrix_engine_tag`;

    - otherwise, the tag type is `readable_matrix_engine_tag`.

Notes regarding member functions:

1. Parameterized constructor `matrix(initializer_list<initializer_list<U>>)` participates in 
overload resolution only if `is_initable_engine_v<engine_type> == true`.

1. Overloaded constructors with size and capacity parameters participate in overload resolution 
only if `is_resizable_engine_v<engine_type> == true`.

1. Parameterized assignment operator `operator=(initializer_list<initializer_list<U>>)` 
participates in overload resolution only if `is_writable_engine_v<engine_type> == true`.

1. Overloads of member function `reserve()` participate in overload resolution only if 
`is_resizable_engine_v<engine_type> == true`;

1. Overloads of member function `resize()` participate in overload resolution only if 
`is_resizable_engine_v<engine_type> == true`;

1. Overloads of member function `span()` participate in overload resolution only if 
`is_same_v<span_type,void> == false && is_same_v<const_span_type,void> == false`.

1. Member function `swap_columns()` participates in overload resolution only if 
`is_writable_engine_v<engine_type> == true`.

1. Member function `swap_rows()` participates in overload resolution only if 
`is_writable_engine_v<engine_type> == true`.


## Operation traits

### `matrix_operation_traits`

Class `matrix_operation_traits` is a traits-style template parameter to 
`vector` and `matrix`.  Its purpose is to associate sets of element promotion
traits, engine promotion traits, and arithmetic traits with a *MathObj* so 
that those traits may be conveyed into an arithmetic operator.

~~~~c++
struct matrix_operation_traits
{
    //- Addition
    //
    template<class T1, class T2>
    using addition_element_traits = matrix_addition_element_traits<T1, T2>;

    template<class OTR, class ET1, class ET2>
    using addition_engine_traits = matrix_addition_engine_traits<OTR, ET1, ET2>;

    template<class OTR, class OP1, class OP2>
    using addition_arithmetic_traits = matrix_addition_arithmetic_traits<OTR, OP1, OP2>;

    //- Subtraction
    //
    template<class T1, class T2>
    using subtraction_element_traits = matrix_subtraction_element_traits<T1, T2>;

    template<class OTR, class ET1, class ET2>
    using subtraction_engine_traits = matrix_subtraction_engine_traits<OTR, ET1, ET2>;

    template<class OTR, class OP1, class OP2>
    using subtraction_arithmetic_traits = matrix_subtraction_arithmetic_traits<OTR, OP1, OP2>;

    //- Multiplication
    //
    template<class T1, class T2>
    using multiplication_element_traits = matrix_multiplication_element_traits<T1, T2>;

    template<class OTR, class ET1, class ET2>
    using multiplication_engine_traits = matrix_multiplication_engine_traits<OTR, ET1, ET2>;

    template<class OTR, class OP1, class OP2>
    using multiplication_arithmetic_traits = matrix_multiplication_arithmetic_traits<OTR, OP1, OP2>;

    //- Division
    //
    template<class T1, class T2>
    using division_element_traits = matrix_division_element_traits<T1, T2>;

    template<class OTR, class T1, class T2>
    using division_engine_traits = matrix_division_engine_traits<OTR, T1, T2>;

    template<class OTR, class T1, class T2>
    using division_arithmetic_traits = matrix_division_arithmetic_traits<OTR, T1, T2>;
};
~~~~

Users may override the default functionality it provides by creating a custom 
operation traits class in their own namespace, and defining only those members 
necessary to implement the desired custom behavior.

### `matrix_operation_traits_selector<OT1, OT2>` 

Class template `matrix_operation_traits_selector<OT1, OT2>` is used by the
binary arithmetic operators to select the operation traits type to be used in
performing an arithmetic operation.  The selection is based on the operation 
traits types of the two operands.

~~~~c++
//- Primary template and standard specializations.
//
template<class T1, class T2>
struct matrix_operation_traits_selector;

template<class T1>
struct matrix_operation_traits_selector<T1, T1>
{
    using traits_type = T1;
};

template<class T1>
struct matrix_operation_traits_selector<T1, matrix_operation_traits>
{
    using traits_type = T1;
};

template<class T1>
struct matrix_operation_traits_selector<matrix_operation_traits, T1>
{
    using traits_type = T1;
};

template<>
struct matrix_operation_traits_selector<matrix_operation_traits, matrix_operation_traits>
{
    using traits_type = matrix_operation_traits;
};

//- Convenience alias.
//
template<class T1, class T2>
using matrix_operation_traits_selector_t = 
        typename matrix_operation_traits_selector<T1, T2>::traits_type;
~~~~

This class is a customization point.  Note that in the set of standard partial 
specializations defined above, user-defined operation traits take precedence
over the standard operation traits.  However, if a situation occurs in which
two different, non-standard operation traits types appear in a arithmetic 
expression, the user must define one or more partial specializations of 
`matrix_operation_traits_selector` that describe which of the two operation
traits are to be used.

## Element promotion traits

Element promotion traits are used by the library to determine the resulting 
element type of an arithmetical expression having one or two *MathObj* operands.


### `matrix_negation_element_traits<T1>` 

Class template `matrix_negation_element_traits<T1>` implements the default
traits type for determining the element type of the *MathObj* instance
resulting from negating a given *MathObj* instance.

Alias template `matrix_negation_element_t<OT, T1, T2>` is used by the library 
to return the nested type `OT::element_negation_traits<T1>`.

~~~~c++
template<class T1>
struct matrix_negation_element_traits
{
    using element_type = decltype(-declval<T1>());
};

template<class OT, class T1>
using matrix_negation_element_t = ...;          //- Implementation-defined
~~~~


### `matrix_addition_element_traits<T1, T2>` 

Class template `matrix_addition_element_traits<T1, T2>` implements the 
default traits type for determining the element type of a *MathObj* instance 
resulting from the addition of two other *MathObj* instances.

Alias template `matrix_addition_element_t<OT, T1, T2>` is used by the library 
to obtain the nested type `OT::element_addition_traits<T1, T2>`.

~~~~c++
template<class T1, class T2>
struct matrix_addition_element_traits
{
    using element_type = decltype(declval<T1>() + declval<T2>());
};

template<class OT, class T1, class T2>
using matrix_addition_element_t = ...;          //- Implementation-defined
~~~~


### `matrix_subtraction_element_traits<T1, T2>` 

Class template `matrix_subtraction_element_traits<T1, T2>` implements the 
default traits type for determining the element type of a *MathObj* instance 
resulting from the subtraction of two other *MathObj* instances.

Alias template `matrix_subtraction_element_t<OT, T1, T2>` is used by the 
library to obtain the nested type `OT::element_subtraction_traits<T1, T2>`.

~~~~c++
template<class T1, class T2>
struct matrix_subtraction_element_traits
{
    using element_type = decltype(declval<T1>() - declval<T2>());
};

template<class OT, class T1, class T2>
using matrix_subtraction_element_t = ...;       //- Implementation-defined
~~~~


### `matrix_multiplication_element_traits<T1, T2>` 

Class template `matrix_multiplication_element_traits<T1, T2>` implements the 
default traits type for determining the element type of a *MathObj* instance 
resulting from the multiplication of two other *MathObj* instances.

Alias template `matrix_multiplication_element_t<OT, T1, T2>` is used by the 
library to obtain the nested type `OT::element_multiplication_traits<T1, T2>`.

~~~~c++
template<class T1, class T2>
struct matrix_multiplication_element_traits
{
    using element_type = decltype(declval<T1>() * declval<T2>());
};

template<class OT, class T1, class T2>
using matrix_multiplication_element_t = ...;    //- Implementation-defined
~~~~


## Engine promotion traits

Engine promotion traits are used by the arithmetic traits to determine
the resulting engine types in an arithmetical expression.


### `matrix_negation_engine_traits<OT, ET1>` 

Class template `matrix_negation_engine_traits<OT, ET1>` implements a traits 
type that determines the resulting engine type when negating a *MathObj*.

Alias template `matrix_negation_engine_t<OT, ET1>` is used by the library 
to obtain the nested type `OT::engine_negation_traits<ET1>`. 

~~~~c++
template<class OT, class ET1>
struct matrix_negation_engine_traits
{
    using element_type = matrix_negation_element_t<OT, typename ET1::element_type>;

    using engine_type  = ...;                   //- Implementation-defined
};

template<class OT, class ET1>
using matrix_negation_engine_t = ...;           //- Implementation-defined
~~~~


### `matrix_addition_engine_traits<OT, ET1, ET2>` 

Class template `matrix_addition_engine_traits<OT, ET1, ET2` implements a
traits type that determines the resulting engine type when adding two
compatible *MathObj*s.

Alias template `matrix_addition_engine_t<OT, ET1, ET2>` is used by the library 
to obtain the nested type `OT::element_addition_traits<ET1, ET2>`.  

~~~~c++
template<class OT, class ET1, class ET2>
struct matrix_addition_engine_traits
{
    using element_type = matrix_addition_element_t<OT, 
                                                   typename ET1::element_type, 
                                                   typename ET2::element_type>;

    using engine_type  = ...;                   //- Implementation-defined
};

template<class OT, class ET1, class ET2>
using matrix_addition_engine_t = detail::engine_add_type_t<OT, ET1, ET2>;
~~~~


### `matrix_subtraction_engine_traits<OT, ET1, ET2>` 

Class template `matrix_subtraction_engine_traits<OT, ET1, ET2` implements a
traits type that determines the resulting engine type when subtracting two
compatible *MathObj*s.

Alias template `matrix_subtraction_engine_t<OT, ET1, ET2>` is used by the library 
to obtain the nested type `OT::element_subtraction_traits<ET1, ET2>`.

~~~~c++
template<class OT, class ET1, class ET2>
struct matrix_subtraction_engine_traits
{
    using element_type = matrix_subtraction_element_t<OT, 
                                                      typename ET1::element_type, 
                                                      typename ET2::element_type>;

    using engine_type  = ...;                   //- Implementation-defined
};

template<class OT, class ET1, class ET2>
using matrix_subtraction_engine_t = ...;        //- Implementation-defined
~~~~

### `matrix_multiplication_engine_traits<OT, ET1, ET2>` 

Class template `matrix_multiplication_engine_traits<OT, ET1, ET2` implements a
traits type that determines the resulting engine type when multiplying two
compatible *MathObj*s.

Alias template `matrix_multiplication_engine_t<OT, ET1, ET2>` is used by the 
library to obtain the nested type `OT::element_multiplication_traits<ET1, ET2>`.  

~~~~c++
template<class OT, class ET1, class ET2>
struct matrix_multiplication_engine_traits
{
    using element_type = matrix_multiplication_element_t<OT,
                                                         typename ET1::element_type, 
                                                         typename ET2::element_type>;

    using engine_type  = ...;                   //- Implementation-defined.
};

template<class OT, class ET1, class ET2>
using matrix_multiplication_engine_t = ...;     //- Implementation-defined
~~~~


## Arithmetic traits

This section defines a set of arithmetic traits types for negation, 
addition, subtraction, and multiplication. The purpose of each of these 
traits types is threefold:

1. to determine the element type of the resulting *MathObj*;

2. to determine the engine type of the resulting *MathObj*; and

3. to carry out the arithmetical operation and return its result.

The idea here is that arithmetic operators (described below) simply forward 
to the appropriate traits type, which does the heavy lifting.


### `matrix_negation_traits<OT, OP1>` 

Class template `matrix_negation_traits<OT, OP1>` is an arithmetic traits 
type that performs the negation of a *MathObj* and returns the result 
in another *MathObj* having an implementation-defined engine type.
There are two partial specializations to support the two overloaded 
negation operators described below.

Alias template `matrix_negation_traits_t<OT, OP1>` is used by the library 
to obtain the nested type `OT::negation_traits<OP1>`. 

~~~~c++
template<class OT, class ET1, class OT1>
struct matrix_negation_traits<OT, vector<ET1, OT1>>
{
    using engine_type = matrix_negation_engine_t<OT, ET1>;
    using op_traits   = OT;
    using result_type = vector<engine_type, op_traits>;

    static result_type  negate(vector<ET1, OT1> const& v1);
};

template<class OT, class ET1, class OT1>
struct matrix_negation_traits<OT, matrix<ET1, OT1>>
{
    using engine_type = matrix_negation_engine_t<OT, ET1>;
    using op_traits   = OT;
    using result_type = matrix<engine_type, op_traits>;

    static result_type  negate(matrix<ET1, OT1> const& m1);
};

template<class OT, class OP1>
using matrix_negation_traits_t = ...;       //- Implementation-defined
~~~~


### `matrix_addition_traits<OT, OP1, OP2>` 

Class template `matrix_addition_traits<OT, OP1, OP2>` is an arithmetic 
traits type that performs the addition of two compatible *MathObj*s and 
returns the result in a *MathObj* having an implementation-defined engine 
type.  There are two partial specializations to support the two overloaded 
addition operators described below.

Alias template `matrix_addition_traits_t<OT, OP1, OP2>` is used by the 
library to obtain the nested type `OT::addition_traits<OP1, OP2>`. 

~~~~c++
template<class OT, class ET1, class OT1, class ET2, class OT2>
struct matrix_addition_traits<OT, vector<ET1, OT1>, vector<ET2, OT2>>
{
    using engine_type = matrix_addition_engine_t<OT, ET1, ET2>;
    using op_traits   = OT;
    using result_type = vector<engine_type, op_traits>;

    static result_type  add(vector<ET1, OT1> const& v1, vector<ET2, OT2> const& v2);
};

template<class OT, class ET1, class OT1, class ET2, class OT2>
struct matrix_addition_traits<OT, matrix<ET1, OT1>, matrix<ET2, OT2>>
{
    using engine_type = matrix_addition_engine_t<OT, ET1, ET2>;
    using op_traits   = OT;
    using result_type = matrix<engine_type, op_traits>;

    static result_type  add(matrix<ET1, OT1> const& m1, matrix<ET2, OT2> const& m2);
};

template<class OT, class OP1, class OP2>
using matrix_addition_traits_t = ...;       //- Implementation-defined
~~~~


### `matrix_subtraction_traits<OT, OP1, OP2>` 

Class template `matrix_subtraction_traits<OT, OP1, OP2>` is an arithmetic 
traits type that performs the subtraction of two compatible *MathObj*s and 
returns the result in a *MathObj* having an implementation-defined engine 
type.  There are two partial specializations to support the two overloaded 
subtraction operators described below.

Alias template `matrix_subtraction_traits_t<OT, OP1, OP2>` is used by the 
library to obtain the nested type `OT::subtraction_traits<OP1, OP2>`. 

~~~~c++
template<class OT, class ET1, class OT1, class ET2, class OT2>
struct matrix_subtraction_traits<OT, vector<ET1, OT1>, vector<ET2, OT2>>
{
    using engine_type = matrix_subtraction_engine_t<OT, ET1, ET2>;
    using op_traits   = OT;
    using result_type = vector<engine_type, op_traits>;

    static result_type  subtract(vector<ET1, OT1> const& v1, vector<ET2, OT2> const& v2);
};

template<class OT, class ET1, class OT1, class ET2, class OT2>
struct matrix_subtraction_traits<OT, matrix<ET1, OT1>, matrix<ET2, OT2>>
{
    using engine_type = matrix_subtraction_engine_t<OT, ET1, ET2>;
    using op_traits   = OT;
    using result_type = matrix<engine_type, op_traits>;

    static result_type  subtract(matrix<ET1, OT1> const& m1, matrix<ET2, OT2> const& m2);
};

template<class OT, class OP1, class OP2>
using matrix_subtraction_traits_t = ...;        //- Implementation-defined
~~~~


### `matrix_multiplication_traits<OT, OP1, OP2>` 

Class template `matrix_multiplication_traits<OT, OP1, OP2>` is an arithmetic 
traits type that performs the multiplication of two compatible *MathObj*s 
and returns the result in a *MathObj* having an implementation-defined 
engine type.  There are eight partial specializations to support the eight 
binary multiplication operators described below.

Alias template `matrix_multiplication_traits_t<OT, OP1, OP2>` is used by the 
library to obtain the nested type `OT::multiplication_traits<OP1, OP2>`. 

~~~~c++
//- vector*scalar
//
template<class OT, class ET1, class OT1, class T2>
struct matrix_multiplication_traits<OT, vector<ET1, OT1>, T2>
{
    using scalar_type = detail::element_tag<T2>;
    using engine_type = matrix_multiplication_engine_t<OT, ET1, scalar_type>;
    using op_traits   = OT;
    using result_type = vector<engine_type, op_traits>;

    static result_type  multiply(vector<ET1, OT1> const& v1, T2 const& s2);
};

//- scalar*vector
//
template<class OT, class T1, class ET2, class OT2>
struct matrix_multiplication_traits<OT, T1, vector<ET2, OT2>>
{
    using scalar_type = detail::element_tag<T1>;
    using engine_type = matrix_multiplication_engine_t<OT, scalar_type, ET2>;
    using op_traits   = OT;
    using result_type = vector<engine_type, op_traits>;

    static result_type  multiply(T1 const& s1, vector<ET2, OT2> const& v2);
};

//- matrix*scalar
//
template<class OT, class ET1, class OT1, class T2>
struct matrix_multiplication_traits<OT, matrix<ET1, OT1>, T2>
{
    using scalar_type = detail::element_tag<T2>;
    using engine_type = matrix_multiplication_engine_t<OT, ET1, scalar_type>;
    using op_traits   = OT;
    using result_type = matrix<engine_type, op_traits>;

    static result_type  multiply(matrix<ET1, OT1> const& m1, T2 const& s2);
};

//- scalar*matrix
//
template<class OT, class T1, class ET2, class OT2>
struct matrix_multiplication_traits<OT, T1, matrix<ET2, OT2>>
{
    using scalar_type = detail::element_tag<T1>;
    using engine_type = matrix_multiplication_engine_t<OT, scalar_type, ET2>;
    using op_traits   = OT;
    using result_type = matrix<engine_type, op_traits>;

    static result_type  multiply(T1 const& s1, matrix<ET2, OT2> const& m2);
};

//- vector*vector
//
template<class OT, class ET1, class OT1, class ET2, class OT2>
struct matrix_multiplication_traits<OT, vector<ET1, OT1>, vector<ET2, OT2>>
{
    //- This specialization returns a scalar, and therefore does not compute an engine type.
    //
    using op_traits   = OT;
    using elem_type_1 = typename vector<ET1, OT1>::element_type;
    using elem_type_2 = typename vector<ET2, OT2>::element_type;
    using result_type = matrix_multiplication_element_t<op_traits, elem_type_1, elem_type_2>;

    static result_type  multiply(vector<ET1, OT1> const& v1, vector<ET2, OT2> const& v2);
};

//- matrix*vector
//
template<class OT, class ET1, class OT1, class ET2, class OT2>
struct matrix_multiplication_traits<OT, matrix<ET1, OT1>, vector<ET2, OT2>>
{
    using engine_type = matrix_multiplication_engine_t<OT, ET1, ET2>;
    using op_traits   = OT;
    using result_type = vector<engine_type, op_traits>;

    static result_type  multiply(matrix<ET1, OT1> const& m1, vector<ET2, OT2> const& m2);
};

//- vector*matrix
//
template<class OT, class ET1, class OT1, class ET2, class OT2>
struct matrix_multiplication_traits<OT, vector<ET1, OT1>, matrix<ET2, OT2>>
{
    using engine_type = matrix_multiplication_engine_t<OT, ET1, ET2>;
    using op_traits   = OT;
    using result_type = vector<engine_type, op_traits>;

    static result_type  multiply(vector<ET1, OT1> const& m1, matrix<ET2, OT2> const& m2);
};

//- matrix*matrix
//
template<class OT, class ET1, class OT1, class ET2, class OT2>
struct matrix_multiplication_traits<OT, matrix<ET1, OT1>, matrix<ET2, OT2>>
{
    using engine_type = matrix_multiplication_engine_t<OT, ET1, ET2>;
    using op_traits   = OT;
    using result_type = matrix<engine_type, op_traits>;

    static result_type  multiply(matrix<ET1, OT1> const& m1, matrix<ET2, OT2> const& m2);
};

template<class OT, class OP1, class OP2>
using matrix_multiplication_traits_t = ...;     //- Implementation-defined
~~~~

## Arithmetic operators

The arithmetic operators provide syntax that mimics common mathematical
notation, with computation executed by an arithmetic traits type 
specified by one of the operands' operation traits template parameters.

Readers will note that the return types of the overloaded operators 
described below are left unspecified.  This is a deliberate choice so
that implementers have the freedom to choose whatever default technique
for evaluating expressions they desire; for example, by returning 
temporary objects, or by using expression templates, or perhaps by 
some hybrid technique.

~~~~c++
//- Negation
//
template<class ET1, class OT1>
inline auto
operator -(vector<ET1, OT1> const& v1)
{
    using op1_type   = vector<ET1, OT1>;
    using op_traits  = OT1;
    using neg_traits = matrix_negation_traits_t<op_traits, op1_type>;

    return neg_traits::negate(v1);
}

template<class ET1, class OT1>
inline auto
operator -(matrix<ET1, OT1> const& m1)
{
    using op1_type   = matrix<ET1, OT1>;
    using op_traits  = OT1;
    using neg_traits = matrix_negation_traits_t<op_traits, op1_type>;

    return neg_traits::negate(m1);
}

//- Addition
//
template<class ET1, class OT1, class ET2, class OT2>
inline auto
operator +(vector<ET1, OT1> const& v1, vector<ET2, OT2> const& v2)
{
    using op_traits  = matrix_operation_traits_selector_t<OT1, OT2>;
    using op1_type   = vector<ET1, OT1>;
    using op2_type   = vector<ET2, OT2>;
    using add_traits = matrix_addition_traits_t<op_traits, op1_type, op2_type>;

    return add_traits::add(v1, v2);
}

template<class ET1, class OT1, class ET2, class OT2>
inline auto
operator +(matrix<ET1, OT1> const& m1, matrix<ET2, OT2> const& m2)
{
    using op_traits  = matrix_operation_traits_selector_t<OT1, OT2>;
    using op1_type   = matrix<ET1, OT1>;
    using op2_type   = matrix<ET2, OT2>;
    using add_traits = matrix_addition_traits_t<op_traits, op1_type, op2_type>;

    return add_traits::add(m1, m2);
}

//- Subtraction
//
template<class ET1, class OT1, class ET2, class OT2>
inline auto
operator -(vector<ET1, OT1> const& v1, vector<ET2, OT2> const& v2)
{
    using op_traits  = matrix_operation_traits_selector_t<OT1, OT2>;
    using op1_type   = vector<ET1, OT1>;
    using op2_type   = vector<ET2, OT2>;
    using sub_traits = matrix_subtraction_traits_t<op_traits, op1_type, op2_type>;

    return sub_traits::subtract(v1, v2);
}

template<class ET1, class OT1, class ET2, class OT2>
inline auto
operator -(matrix<ET1, OT1> const& m1, matrix<ET2, OT2> const& m2)
{
    using op_traits  = matrix_operation_traits_selector_t<OT1, OT2>;
    using op1_type   = matrix<ET1, OT1>;
    using op2_type   = matrix<ET2, OT2>;
    using sub_traits = matrix_subtraction_traits_t<op_traits, op1_type, op2_type>;

    return sub_traits::subtract(m1, m2);
}

//- Multiplication
//- vector*scalar and scalar*vector
//
template<class ET1, class OT1, class S2>
inline auto
operator *(vector<ET1, OT1> const& v1, S2 const& s2)
{
    static_assert(is_matrix_element_v<S2>);

    using op_traits  = OT1;
    using op1_type   = vector<ET1, OT1>;
    using op2_type   = S2;
    using mul_traits = matrix_multiplication_traits_t<op_traits, op1_type, op2_type>;

    return mul_traits::multiply(v1, s2);
}

template<class S1, class ET2, class OT2>
inline auto
operator *(S1 const& s1, vector<ET2, OT2> const& v2)
{
    static_assert(is_matrix_element_v<S1>);

    using op_traits  = OT2;
    using op1_type   = S1;
    using op2_type   = vector<ET2, OT2>;
    using mul_traits = matrix_multiplication_traits_t<op_traits, op1_type, op2_type>;

    return mul_traits::multiply(s1, v2);
}

//- matrix*scalar and scalar*matrix
//
template<class ET1, class OT1, class S2>
inline auto
operator *(matrix<ET1, OT1> const& m1, S2 const& s2)
{
    static_assert(is_matrix_element_v<S2>);

    using op_traits  = OT1;
    using op1_type   = matrix<ET1, OT1>;
    using op2_type   = S2;
    using mul_traits = matrix_multiplication_traits_t<op_traits, op1_type, op2_type>;

    return mul_traits::multiply(m1, s2);
}

template<class S1, class ET2, class OT2>
inline auto
operator *(S1 const& s1, matrix<ET2, OT2> const& m2)
{
    static_assert(is_matrix_element_v<S1>);

    using op_traits  = OT2;
    using op1_type   = S1;
    using op2_type   = matrix<ET2, OT2>;
    using mul_traits = matrix_multiplication_traits_t<op_traits, op1_type, op2_type>;

    return mul_traits::multiply(s1, m2);
}

//- vector*vector
//
template<class ET1, class OT1, class ET2, class OT2>
inline auto
operator *(vector<ET1, OT1> const& v1, vector<ET2, OT2> const& v2)
{
    using op_traits  = matrix_operation_traits_selector_t<OT1, OT2>;
    using op1_type   = vector<ET1, OT1>;
    using op2_type   = vector<ET2, OT2>;
    using mul_traits = matrix_multiplication_traits_t<op_traits, op1_type, op2_type>;

    return mul_traits::multiply(v1, v2);
}

//- matrix*vector
//
template<class ET1, class OT1, class ET2, class OT2>
inline auto
operator *(matrix<ET1, OT1> const& m1, vector<ET2, OT2> const& v2)
{
    using op_traits  = matrix_operation_traits_selector_t<OT1, OT2>;
    using op1_type   = matrix<ET1, OT1>;
    using op2_type   = vector<ET2, OT2>;
    using mul_traits = matrix_multiplication_traits_t<op_traits, op1_type, op2_type>;

    return mul_traits::multiply(m1, v2);
}

//- vector*matrix
//
template<class ET1, class OT1, class ET2, class OT2>
inline auto
operator *(vector<ET1, OT1> const& v1, matrix<ET2, OT2> const& m2)
{
    using op_traits  = matrix_operation_traits_selector_t<OT1, OT2>;
    using op1_type   = vector<ET1, OT1>;
    using op2_type   = matrix<ET2, OT2>;
    using mul_traits = matrix_multiplication_traits_t<op_traits, op1_type, op2_type>;

    return mul_traits::multiply(v1, m2);
}

//- matrix*matrix
//
template<class ET1, class OT1, class ET2, class OT2>
inline auto
operator *(matrix<ET1, OT1> const& m1, matrix<ET2, OT2> const& m2)
{
    using op_traits  = matrix_operation_traits_selector_t<OT1, OT2>;
    using op1_type   = matrix<ET1, OT1>;
    using op2_type   = matrix<ET2, OT2>;
    using mul_traits = matrix_multiplication_traits_t<op_traits, op1_type, op2_type>;

    return mul_traits::multiply(m1, m2);
}
~~~~


# Customization

The library provides for several forms of customization: custom element types,
custom element promotion, custom engines, and custom arithmetical operations.  
The following sections show examples of each.

## Integrating a new element type

Suppose that you have created a new type that models a real number in some
way and you wish for that type to be used as a matrix element:

~~~~c++
class new_num
{
  public:
    new_num();
    new_num(new_num&&) = default;
    new_num(new_num const&) = default;
    template<class U>   new_num(U other);

    new_num&    operator =(new_num&&) = default;
    new_num&    operator =(new_num const&) = default;
    template<class U>   new_num&    operator =(U rhs);

    new_num     operator -() const;
    new_num     operator +() const;

    new_num&    operator +=(new_num rhs);
    new_num&    operator -=(new_num rhs);
    new_num&    operator *=(new_num rhs);
    new_num&    operator /=(new_num rhs);

    template<class U>   new_num&    operator +=(U rhs);
    template<class U>   new_num&    operator -=(U rhs);
    template<class U>   new_num&    operator *=(U rhs);
    template<class U>   new_num&    operator /=(U rhs);

    ...
};

inline bool operator ==(NewNum lhs, NewNum rhs);
template<class U> inline bool operator ==(NewNum lhs, U rhs);
template<class U> inline bool operator ==(U lhs, NewNum rhs);
...
//- other comparison operators...
...
//- other arithmetic operators...
...
                  inline new_num operator *(new_num lhs, new_num rhs);
template<class U> inline new_num operator *(new_num lhs, U rhs);
template<class U> inline new_num operator *(U lhs, new_num rhs);
~~~~

Assuming that this type works as intended, and that all arithmetic 
interactions with other types are handled the set of operator overloads 
that you provide, then all that is required for the library to accept 
`new_num` as an element type is to create a specialization of 
`number_traits`:

~~~~c++
template<>
struct std::math::number_traits<new_num>
{
    using is_field    = true_type;
    using is_nc_ring  = true_type;
    using is_ring     = true_type;
};
~~~~

By stating that `new_num` models at least a non-commutative ring, and by 
ensuring that its arithmetic operators functions as promised, the library's 
traits types will allow compiliation to succeed.  


## Custom element promotion

Suppose that you want the result of adding two `float` elements to be 
`double`.  Then you would create the following custom types in your 
namespace:

~~~~c++
//- Base template for custom element promotion
//
template<class T1, class T2>
struct element_add_traits_tst;

//- Promote any float/float addition to double.
//
template<>
struct element_add_traits_tst<float, float>
{
    using element_type = double;
};

//- Custom operation traits.
//
struct test_add_op_traits_tst
{
     template<class T1, class T2>
     using element_addition_traits = element_add_traits_tst<T1, T2>;
};
~~~~

The new operation traits could be used like this:

~~~~c++
matrix<fs_matrix_engine<float, 2, 3>, add_op_traits_tst>                    m1;
matrix<dr_matrix_engine<float, allocator<float>>, add_op_traits_tst>        m2(2, 3);
matrix<dr_matrix_engine<float, allocator<float>>, matrix_operation_traits>  m3(2, 3);

//- mr1 --> matrix<fs_matrix_engine<double, 2, 3>, add_op_traits_tst>
//
auto mr1 = m1 + m1;

//- mr2 --> matrix<dr_matrix_engine<double, allocator<double>>, add_op_traits_tst>
//
auto mr2 = m1 + m2;

//- mr3 --> matrix<dr_matrix_engine<double, allocator<double>>, add_op_traits_tst>
//
auto mr3 = m1 + m3;
~~~~

Note that this example assumes that an addition operation involving a fixed-size
matrix and a dynamically-resizable matrix, or two dynamically-resizable matrices
results in a dynamically-resizable matrix.

## Integrating a new engine type

Suppose that you want to add a custom fixed-size matrix engine that is
somehow different from `fs_matrix_engine`; perhaps it is instrumented in
some way for debugging, or uses fixed-size storage that is external to
the engine object.  It might look like this:

~~~~c++
template<class T, int32_t R, int32_t C>
class fs_matrix_engine_tst
{
  public:
    using engine_category = std::math::mutable_matrix_engine_tag;
    using element_type    = T;
    using value_type      = T;
    using reference       = T&;
    using pointer         = T*;
    using const_reference = T const&;
    using const_pointer   = T const*;
    using difference_type = std::ptrdiff_t;
    using index_type      = std::int_fast32_t;
    using size_type       = std::int_fast32_t;
    using size_tuple      = std::tuple<size_type, size_type>;

    using is_fixed_size   = std::true_type;
    using is_resizable    = std::false_type;

    using is_column_major = std::false_type;
    using is_dense        = std::true_type;
    using is_rectangular  = std::true_type;
    using is_row_major    = std::true_type;

    using column_view_type    = std::math::column_engine<fs_matrix_engine_tst>;
    using row_view_type       = std::math::row_engine<fs_matrix_engine_tst>;
    using transpose_view_type = std::math::transpose_engine<fs_matrix_engine_tst>;

  public:
    constexpr fs_matrix_engine_tst();
    constexpr fs_matrix_engine_tst(fs_matrix_engine_tst&&) = default;
    constexpr fs_matrix_engine_tst(fs_matrix_engine_tst const&) = default;

    constexpr fs_matrix_engine_tst&     operator =(fs_matrix_engine_tst&&) = default;
    constexpr fs_matrix_engine_tst&     operator =(fs_matrix_engine_tst const&) = default;

    constexpr const_reference   operator ()(index_type i, index_type j) const;

    constexpr index_type    columns() const noexcept;
    constexpr index_type    rows() const noexcept;
    constexpr size_tuple    size() const noexcept;

    constexpr size_type     column_capacity() const noexcept;
    constexpr size_type     row_capacity() const noexcept;
    constexpr size_tuple    capacity() const noexcept;

    constexpr reference     operator ()(index_type i, index_type j);

    constexpr void      assign(fs_matrix_engine_tst const& rhs);
    template<class ET2>
    constexpr void      assign(ET2 const& rhs);

    constexpr void      swap(fs_matrix_engine_tst& rhs) noexcept;
    constexpr void      swap_columns(index_type j1, index_type j2);
    constexpr void      swap_rows(index_type i1, index_type i2);

  private:
    ...         //- Implementation stuff
};
~~~~

For each arithmetic operation in which you expect the new engine type to 
be involved, you will need to provide a specialization 
of the engine promotion traits for that operation.  For example, let's 
assume that you're only interested in addition operations involving two 
operands having the new engine type, or where one operand has the standard 
fixed-size engine and the other has the new engine.  Then your engine 
promotion traits might look like this:

~~~~
//- Goal: Create a new fixed-size engine type and use it in arithmetical expressions.
//
template<class OT, class ET1, class ET2>
struct engine_add_traits_tst;

template<class OT, class T1, int32_t R1, int32_t C1, class T2, int32_t R2, int32_t C2>
struct engine_add_traits_tst<OT,
                             fs_matrix_engine_tst<T1, R1, C1>,
                             fs_matrix_engine_tst<T2, R2, C2>>
{
    using element_type = std::math::matrix_addition_element_t<OT, T1, T2>;
    using engine_type  = fs_matrix_engine_tst<element_type, R1, C1>;
};

template<class OT, class T1, int32_t R1, int32_t C1, class T2, int32_t R2, int32_t C2>
struct engine_add_traits_tst<OT,
                             fs_matrix_engine_tst<T1, R1, C1>,
                             std::math::fs_matrix_engine<T2, R2, C2>>
{
    using element_type = std::math::matrix_addition_element_t<OT, T1, T2>;
    using engine_type  = fs_matrix_engine_tst<element_type, R1, C1>;
};

template<class OT, class T1, int32_t R1, int32_t C1, class T2, int32_t R2, int32_t C2>
struct engine_add_traits_tst<OT,
                             std::math::fs_matrix_engine<T1, R1, C1>,
                             fs_matrix_engine_tst<T2, R2, C2>>
{
    using element_type = std::math::matrix_addition_element_t<OT, T1, T2>;
    using engine_type   = fs_matrix_engine_tst<element_type, R1, C1>;
};

//- This is a custom operation traits type!
//
struct add_op_traits_tst
{
    template<class T1, class T2>
    using element_addition_traits = element_add_traits_tst<T1, T2>;

    template<class T1, class T2>
    using engine_addition_traits = engine_add_traits_tst<T1, T2>;
};
~~~~

As we can see, these custom promotion traits dictate the resulting engine type 
for these particular cases.  Resulting usage might look like this:

~~~~c++
matrix<fs_matrix_engine<float, 2, 3>, matrix_operation_traits>              m1;
matrix<fs_matrix_engine_tst<float, 2, 3>, add_op_traits_tst>                m2;
matrix<dr_matrix_engine<float, allocator<float>>, matrix_operation_traits>  m3(2, 3);

//- mr1 --> matrix<fs_matrix_engine<float, 2, 3>, matrix_operation_traits>
//
auto    mr1 = m1 + m1;

//- mr2 --> matrix<fs_matrix_engine_tst<double, 2, 3>, add_op_traits_tst>
//
auto    mr2 = m2 + m2;

//- mr3 --> matrix<fs_matrix_engine_tst<double, 2, 3>, add_op_traits_tst>
//
auto    mr3 = m1 + m2;

//- mr4 --> matrix<dr_matrix_engine<double, allocator<double>>, add_op_traits_tst>
//
auto    mr4 = m1 + m3;
~~~~

Note that this example also assumes that an addition operation involving a 
fixed-size matrix and a dynamically-resizable matrix, or two 
dynamically-resizable matrices results in a dynamically-resizable matrix.


## Customizing an arithmetic operation

Suppose that you want to specialize the addition function for the addition of
two matrices that employ the custom engine above and whose sizes happen to be
3x4.

~~~~c++
//- Goal: Call a specialized addition function for addition of fixed-size matrix objects
// using the fixed-size test engine and having size 3x4.
//
template<class OT, class OP1, class OP2>
struct addition_traits_tst;

template<class OT>
struct addition_traits_tst<OT,
                           matrix<fs_matrix_engine_tst<double, 3, 4>, OT>,
                           matrix<fs_matrix_engine_tst<double, 3, 4>, OT>>
{
    using op_traits = OT;
    using engine_type = fs_matrix_engine_tst<double, 3, 4>;
    using result_type = matrix<engine_type, op_traits>;

    static result_type  add(matrix<fs_matrix_engine_tst<double, 3, 4>, OT> const& m1,
                            matrix<fs_matrix_engine_tst<double, 3, 4>, OT> const& m2);
};

//- This is a custom operation traits type!
//
struct test_add_op_traits_tst
{
    template<class T1, class T2>
    using element_addition_traits = element_add_traits_tst<T1, T2>;

    template<class OT, class ET1, class ET2>
    using engine_addition_traits = engine_add_traits_tst<OT, ET1, ET2>;

    template<class OT, class OP1, class OP2>
    using addition_traits = addition_traits_tst<OT, OP1, OP2>;
};
~~~~

Actual usage might look like this:

~~~~c++
matrix<fs_matrix_engine_tst<float, 3, 4>, add_op_traits_tst>    m1;
matrix<fs_matrix_engine_tst<double, 3, 4>, add_op_traits_tst>   m2;

//- mr1 --> matrix<fs_matrix_engine_tst<double, 3, 4>, add_op_traits_tst>
//
auto    mr1 = m1 + m1;    //- Calls matrix_addition_traits::add()

//- mr2 --> matrix<fs_matrix_engine_tst<double, 3, 4>, add_op_traits_tst>
//
auto    mr2 = m1 + m2;    //- Calls matrix_addition_traits::add()

//- mr3 --> matrix<fs_matrix_engine_tst<double, 3, 4>, add_op_traits_tst>
//
auto    mr3 = m2 + m2;    //- Calls matrix_addition_traits_tst::add()
~~~~
