<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="mpark/wg21" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="dcterms.date" content="2019-10-07" />
  <title>A proposal to add linear algebra support to the C++ standard library</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style>
code.sourceCode > span { display: inline-block; line-height: 1.25; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  background-color: #f6f8fa; }
@media screen {
code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span. { } /* Normal */
code span.al { color: #ff0000; } /* Alert */
code span.an { } /* Annotation */
code span.at { } /* Attribute */
code span.bn { color: #9f6807; } /* BaseN */
code span.bu { color: #9f6807; } /* BuiltIn */
code span.cf { color: #00607c; } /* ControlFlow */
code span.ch { color: #9f6807; } /* Char */
code span.cn { } /* Constant */
code span.co { color: #008000; font-style: italic; } /* Comment */
code span.cv { color: #008000; font-style: italic; } /* CommentVar */
code span.do { color: #008000; } /* Documentation */
code span.dt { color: #00607c; } /* DataType */
code span.dv { color: #9f6807; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #9f6807; } /* Float */
code span.fu { } /* Function */
code span.im { } /* Import */
code span.in { color: #008000; } /* Information */
code span.kw { color: #00607c; } /* Keyword */
code span.op { color: #af1915; } /* Operator */
code span.ot { } /* Other */
code span.pp { color: #6f4e37; } /* Preprocessor */
code span.re { } /* RegionMarker */
code span.sc { color: #9f6807; } /* SpecialChar */
code span.ss { color: #9f6807; } /* SpecialString */
code span.st { color: #9f6807; } /* String */
code span.va { } /* Variable */
code span.vs { color: #9f6807; } /* VerbatimString */
code span.wa { color: #008000; font-weight: bold; } /* Warning */
code.diff {color: #898887}
code.diff span.va {color: #006e28}
code.diff span.st {color: #bf0303}
  </style>
  <style type="text/css">
body {
margin: 5em;
font-family: serif;

hyphens: auto;
line-height: 1.35;
}
div.wrapper {
max-width: 60em;
margin: auto;
}
ul {
list-style-type: none;
padding-left: 2em;
margin-top: -0.2em;
margin-bottom: -0.2em;
}
a {
text-decoration: none;
color: #4183C4;
}
a.hidden_link {
text-decoration: none;
color: inherit;
}
li {
margin-top: 0.6em;
margin-bottom: 0.6em;
}
h1, h2, h3, h4 {
position: relative;
line-height: 1;
}
a.self-link {
position: absolute;
top: 0;
left: calc(-1 * (3.5rem - 26px));
width: calc(3.5rem - 26px);
height: 2em;
text-align: center;
border: none;
transition: opacity .2s;
opacity: .5;
font-family: sans-serif;
font-weight: normal;
font-size: 83%;
}
a.self-link:hover { opacity: 1; }
a.self-link::before { content: "§"; }
ul > li:before {
content: "\2014";
position: absolute;
margin-left: -1.5em;
}
:target { background-color: #C9FBC9; }
:target .codeblock { background-color: #C9FBC9; }
:target ul { background-color: #C9FBC9; }
.abbr_ref { float: right; }
.folded_abbr_ref { float: right; }
:target .folded_abbr_ref { display: none; }
:target .unfolded_abbr_ref { float: right; display: inherit; }
.unfolded_abbr_ref { display: none; }
.secnum { display: inline-block; min-width: 35pt; }
.header-section-number { display: inline-block; min-width: 35pt; }
.annexnum { display: block; }
div.sourceLinkParent {
float: right;
}
a.sourceLink {
position: absolute;
opacity: 0;
margin-left: 10pt;
}
a.sourceLink:hover {
opacity: 1;
}
a.itemDeclLink {
position: absolute;
font-size: 75%;
text-align: right;
width: 5em;
opacity: 0;
}
a.itemDeclLink:hover { opacity: 1; }
span.marginalizedparent {
position: relative;
left: -5em;
}
li span.marginalizedparent { left: -7em; }
li ul > li span.marginalizedparent { left: -9em; }
li ul > li ul > li span.marginalizedparent { left: -11em; }
li ul > li ul > li ul > li span.marginalizedparent { left: -13em; }
div.footnoteNumberParent {
position: relative;
left: -4.7em;
}
a.marginalized {
position: absolute;
font-size: 75%;
text-align: right;
width: 5em;
}
a.enumerated_item_num {
position: relative;
left: -3.5em;
display: inline-block;
margin-right: -3em;
text-align: right;
width: 3em;
}
div.para { margin-bottom: 0.6em; margin-top: 0.6em; text-align: justify; }
div.section { text-align: justify; }
div.sentence { display: inline; }
span.indexparent {
display: inline;
position: relative;
float: right;
right: -1em;
}
a.index {
position: absolute;
display: none;
}
a.index:before { content: "⟵"; }

a.index:target {
display: inline;
}
.indexitems {
margin-left: 2em;
text-indent: -2em;
}
div.itemdescr {
margin-left: 3em;
}
.bnf {
font-family: serif;
margin-left: 40pt;
margin-top: 0.5em;
margin-bottom: 0.5em;
}
.ncbnf {
font-family: serif;
margin-top: 0.5em;
margin-bottom: 0.5em;
margin-left: 40pt;
}
.ncsimplebnf {
font-family: serif;
font-style: italic;
margin-top: 0.5em;
margin-bottom: 0.5em;
margin-left: 40pt;
background: inherit; 
}
span.textnormal {
font-style: normal;
font-family: serif;
white-space: normal;
display: inline-block;
}
span.rlap {
display: inline-block;
width: 0px;
}
span.descr { font-style: normal; font-family: serif; }
span.grammarterm { font-style: italic; }
span.term { font-style: italic; }
span.terminal { font-family: monospace; font-style: normal; }
span.nonterminal { font-style: italic; }
span.tcode { font-family: monospace; font-style: normal; }
span.textbf { font-weight: bold; }
span.textsc { font-variant: small-caps; }
a.nontermdef { font-style: italic; font-family: serif; }
span.emph { font-style: italic; }
span.techterm { font-style: italic; }
span.mathit { font-style: italic; }
span.mathsf { font-family: sans-serif; }
span.mathrm { font-family: serif; font-style: normal; }
span.textrm { font-family: serif; }
span.textsl { font-style: italic; }
span.mathtt { font-family: monospace; font-style: normal; }
span.mbox { font-family: serif; font-style: normal; }
span.ungap { display: inline-block; width: 2pt; }
span.textit { font-style: italic; }
span.texttt { font-family: monospace; }
span.tcode_in_codeblock { font-family: monospace; font-style: normal; }
span.phantom { color: white; }

span.math { font-style: normal; }
span.mathblock {
display: block;
margin-left: auto;
margin-right: auto;
margin-top: 1.2em;
margin-bottom: 1.2em;
text-align: center;
}
span.mathalpha {
font-style: italic;
}
span.synopsis {
font-weight: bold;
margin-top: 0.5em;
display: block;
}
span.definition {
font-weight: bold;
display: block;
}
.codeblock {
margin-left: 1.2em;
line-height: 127%;
}
.outputblock {
margin-left: 1.2em;
line-height: 127%;
}
div.itemdecl {
margin-top: 2ex;
}
code.itemdeclcode {
white-space: pre;
display: block;
}
span.textsuperscript {
vertical-align: super;
font-size: smaller;
line-height: 0;
}
.footnotenum { vertical-align: super; font-size: smaller; line-height: 0; }
.footnote {
font-size: small;
margin-left: 2em;
margin-right: 2em;
margin-top: 0.6em;
margin-bottom: 0.6em;
}
div.minipage {
display: inline-block;
margin-right: 3em;
}
div.numberedTable {
text-align: center;
margin: 2em;
}
div.figure {
text-align: center;
margin: 2em;
}
table {
border: 1px solid black;
border-collapse: collapse;
margin-left: auto;
margin-right: auto;
margin-top: 0.8em;
text-align: left;
hyphens: none; 
}
td, th {
padding-left: 1em;
padding-right: 1em;
vertical-align: top;
}
td.empty {
padding: 0px;
padding-left: 1px;
}
td.left {
text-align: left;
}
td.right {
text-align: right;
}
td.center {
text-align: center;
}
td.justify {
text-align: justify;
}
td.border {
border-left: 1px solid black;
}
tr.rowsep, td.cline {
border-top: 1px solid black;
}
tr.even, tr.odd {
border-bottom: 1px solid black;
}
tr.capsep {
border-top: 3px solid black;
border-top-style: double;
}
tr.header {
border-bottom: 3px solid black;
border-bottom-style: double;
}
th {
border-bottom: 1px solid black;
}
span.centry {
font-weight: bold;
}
div.table {
display: block;
margin-left: auto;
margin-right: auto;
text-align: center;
width: 90%;
}
span.indented {
display: block;
margin-left: 2em;
margin-bottom: 1em;
margin-top: 1em;
}
ol.enumeratea { list-style-type: none; background: inherit; }
ol.enumerate { list-style-type: none; background: inherit; }

code.sourceCode > span { display: inline; }

div#refs p { padding-left: 32px; text-indent: -32px; }
</style>
  <link href="data:image/vnd.microsoft.icon;base64,AAABAAIAEBAAAAEAIABoBAAAJgAAACAgAAABACAAqBAAAI4EAAAoAAAAEAAAACAAAAABACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAVoJEAN6CRADegkQAWIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wCCRAAAgkQAAIJEAACCRAAsgkQAvoJEAP+CRAD/gkQA/4JEAP+CRADAgkQALoJEAACCRAAAgkQAAP///wD///8AgkQAAIJEABSCRACSgkQA/IJEAP99PQD/dzMA/3czAP99PQD/gkQA/4JEAPyCRACUgkQAFIJEAAD///8A////AHw+AFiBQwDqgkQA/4BBAP9/PxP/uZd6/9rJtf/bybX/upd7/39AFP+AQQD/gkQA/4FDAOqAQgBc////AP///wDKklv4jlEa/3o7AP+PWC//8+3o///////////////////////z7un/kFox/35AAP+GRwD/mVYA+v///wD///8A0Zpk+NmibP+0d0T/8evj///////+/fv/1sKz/9bCs//9/fr//////+/m2/+NRwL/nloA/5xYAPj///8A////ANKaZPjRmGH/5cKh////////////k149/3UwAP91MQD/lmQ//86rhv+USg3/m1YA/5hSAP+bVgD4////AP///wDSmmT4zpJY/+/bx///////8+TV/8mLT/+TVx//gkIA/5lVAP+VTAD/x6B//7aEVv/JpH7/s39J+P///wD///8A0ppk+M6SWP/u2sf///////Pj1f/Nj1T/2KFs/8mOUv+eWhD/lEsA/8aee/+0glT/x6F7/7J8Rvj///8A////ANKaZPjRmGH/48Cf///////+/v7/2qt//82PVP/OkFX/37KJ/86siv+USg7/mVQA/5hRAP+bVgD4////AP///wDSmmT40ppk/9CVXP/69O////////7+/v/x4M//8d/P//7+/f//////9u7n/6tnJf+XUgD/nFgA+P///wD///8A0ppk+NKaZP/RmWL/1qNy//r07///////////////////////+vXw/9akdP/Wnmn/y5FY/6JfFvj///8A////ANKaZFTSmmTo0ppk/9GYYv/Ql1//5cWm//Hg0P/x4ND/5cWm/9GXYP/RmGH/0ppk/9KaZOjVnmpY////AP///wDSmmQA0ppkEtKaZI7SmmT60ppk/9CWX//OkVb/zpFW/9CWX//SmmT/0ppk/NKaZJDSmmQS0ppkAP///wD///8A0ppkANKaZADSmmQA0ppkKtKaZLrSmmT/0ppk/9KaZP/SmmT/0ppkvNKaZCrSmmQA0ppkANKaZAD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkUtKaZNzSmmTc0ppkVNKaZADSmmQA0ppkANKaZADSmmQA////AP5/AAD4HwAA4AcAAMADAACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAMADAADgBwAA+B8AAP5/AAAoAAAAIAAAAEAAAAABACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////AP///wCCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAAyCRACMgkQA6oJEAOqCRACQgkQAEIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wD///8A////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRABigkQA5oJEAP+CRAD/gkQA/4JEAP+CRADqgkQAZoJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAAD///8A////AP///wD///8AgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAA4gkQAwoJEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQAxIJEADyCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAP///wD///8A////AP///wCCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAWgkQAmIJEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAJyCRAAYgkQAAIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wD///8A////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAdIJEAPCCRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAPSCRAB4gkQAAIJEAACCRAAAgkQAAIJEAAD///8A////AP///wD///8AgkQAAIJEAACCRAAAgkQASoJEANKCRAD/gkQA/4JEAP+CRAD/g0YA/39AAP9zLgD/bSQA/2shAP9rIQD/bSQA/3MuAP9/PwD/g0YA/4JEAP+CRAD/gkQA/4JEAP+CRADUgkQAToJEAACCRAAAgkQAAP///wD///8A////AP///wB+PwAAgkUAIoJEAKiCRAD/gkQA/4JEAP+CRAD/hEcA/4BBAP9sIwD/dTAA/5RfKv+viF7/vp56/76ee/+wiF7/lWAr/3YxAP9sIwD/f0AA/4RHAP+CRAD/gkQA/4JEAP+CRAD/gkQArIJEACaBQwAA////AP///wD///8A////AIBCAEBzNAD6f0EA/4NFAP+CRAD/gkQA/4VIAP92MwD/bSUA/6N1Tv/ezsL/////////////////////////////////38/D/6V3Uv9uJgD/dTEA/4VJAP+CRAD/gkQA/4JEAP+BQwD/fUAA/4FDAEj///8A////AP///wD///8AzJRd5qBlKf91NgD/dDUA/4JEAP+FSQD/cy4A/3YyAP/PuKP//////////////////////////////////////////////////////9K7qP94NQD/ciwA/4VJAP+CRAD/fkEA/35BAP+LSwD/mlYA6v///wD///8A////AP///wDdpnL/4qx3/8KJUv+PUhf/cTMA/3AsAP90LgD/4dK+/////////////////////////////////////////////////////////////////+TYxf91MAD/dTIA/31CAP+GRwD/llQA/6FcAP+gWwD8////AP///wD///8A////ANGZY/LSm2X/4ap3/92mcP+wdT3/byQA/8mwj////////////////////////////////////////////////////////////////////////////+LYxv9zLgP/jUoA/59bAP+hXAD/nFgA/5xYAPL///8A////AP///wD///8A0ppk8tKaZP/RmWL/1p9q/9ubXv/XqXj////////////////////////////7+fD/vZyG/6BxS/+gcUr/vJuE//r37f//////////////////////3MOr/5dQBf+dVQD/nVkA/5xYAP+cWAD/nFgA8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/SmWP/yohJ//jo2P//////////////////////4NTG/4JDFf9lGAD/bSQA/20kAP9kGAD/fz8S/+Xb0f//////5NG9/6txN/+LOgD/m1QA/51aAP+cWAD/m1cA/5xYAP+cWADy////AP///wD///8A////ANKaZPLSmmT/0ppk/8+TWf/Unmv//v37//////////////////////+TWRr/VwsA/35AAP+ERgD/g0UA/4JGAP9lHgD/kFga/8KXX/+TRwD/jT4A/49CAP+VTQD/n10A/5xYAP+OQQD/lk4A/55cAPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/y4tO/92yiP//////////////////////8NnE/8eCQP+rcTT/ez0A/3IyAP98PgD/gEMA/5FSAP+USwD/jj8A/5lUAP+JNwD/yqV2/694Mf+HNQD/jkAA/82rf/+laBj/jT4A8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/LiUr/4byY///////////////////////gupX/0I5P/+Wuev/Lklz/l1sj/308AP+QSwD/ol0A/59aAP+aVQD/k0oA/8yoh///////+fXv/6pwO//Lp3v///////Pr4f+oay7y////AP///wD///8A////ANKaZPLSmmT/0ppk/8uJSv/hvJj//////////////////////+G7l//Jhkb/0ppk/96nc//fqXX/x4xO/6dkFP+QSQD/llEA/5xXAP+USgD/yaOA///////38uv/qG05/8ijdv//////8efb/6ZpLPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/zIxO/9yxh///////////////////////7dbA/8iEQf/Sm2X/0Zlj/9ScZv/eqHf/2KJv/7yAQf+XTgD/iToA/5lSAP+JNgD/yKFv/611LP+HNQD/jT8A/8qmeP+kZRT/jT4A8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/Pk1n/1J5q//78+//////////////////+/fv/1aFv/8iEQv/Tm2b/0ppl/9GZY//Wn2z/1pZc/9eldf/Bl2b/kUcA/4w9AP+OQAD/lUwA/59eAP+cWQD/jT8A/5ZOAP+eXADy////AP///wD///8A////ANKaZPLSmmT/0ppk/9KZY//KiEn/8d/P///////////////////////47+f/05tm/8iCP//KiEj/yohJ/8eCP//RmGH//vfy///////n1sP/rXQ7/4k4AP+TTAD/nVoA/5xYAP+cVwD/nFgA/5xYAPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/0ptl/8uLTf/aq37////////////////////////////+/fz/6c2y/961jv/etY7/6Myx//78+v//////////////////////3MWv/5xXD/+ORAD/mFQA/51ZAP+cWAD/nFgA8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/SmmT/0ppk/8mFRP/s1b//////////////////////////////////////////////////////////////////////////////+PD/0JFU/7NzMv+WUQD/kUsA/5tXAP+dWQDy////AP///wD///8A////ANKaZP/SmmT/0ppk/9KaZP/Sm2X/z5NZ/8yMT//z5NX/////////////////////////////////////////////////////////////////9Ofa/8yNUP/UmGH/36p5/8yTWv+qaSD/kksA/5ROAPz///8A////AP///wD///8A0ppk5NKaZP/SmmT/0ppk/9KaZP/TnGf/zY9T/82OUv/t1sD//////////////////////////////////////////////////////+7Yw//OkFX/zI5R/9OcZ//SmmP/26V0/9ymdf/BhUf/ol8R6P///wD///8A////AP///wDSmmQ80ppk9tKaZP/SmmT/0ppk/9KaZP/TnGj/zpFW/8qJSv/dson/8uHS//////////////////////////////////Lj0//etIv/y4lL/86QVf/TnGj/0ppk/9KaZP/RmWP/05xn/9ymdfjUnWdC////AP///wD///8A////ANKaZADSmmQc0ppkotKaZP/SmmT/0ppk/9KaZP/Tm2b/0Zli/8qJSf/NjlH/16Z3/+G8mP/myKr/5siq/+G8mP/Xp3f/zY5S/8qISf/RmGH/05tm/9KaZP/SmmT/0ppk/9KaZP/SmmSm0pljINWdaQD///8A////AP///wD///8A0ppkANKaZADSmmQA0ppkQtKaZMrSmmT/0ppk/9KaZP/SmmT/0ptl/9GYYf/Nj1P/y4lL/8qISP/KiEj/y4lK/82PU//RmGH/0ptl/9KaZP/SmmT/0ppk/9KaZP/SmmTO0ppkRtKaZADSmmQA0ppkAP///wD///8A////AP///wDSmmQA0ppkANKaZADSmmQA0ppkANKaZGzSmmTu0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmTw0ppkcNKaZADSmmQA0ppkANKaZADSmmQA////AP///wD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZBLSmmSQ0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppklNKaZBTSmmQA0ppkANKaZADSmmQA0ppkANKaZAD///8A////AP///wD///8A0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQy0ppkutKaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppkvtKaZDbSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkAP///wD///8A////AP///wDSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkXNKaZODSmmT/0ppk/9KaZP/SmmT/0ppk5NKaZGDSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA////AP///wD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkBtKaZIbSmmTo0ppk6tKaZIrSmmQK0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZAD///8A////AP/8P///+B///+AH//+AAf//AAD//AAAP/AAAA/gAAAHwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA+AAAAfwAAAP/AAAP/8AAP//gAH//+AH///4H////D//" rel="icon" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  
</head>
<body>
<div class="wrapper">
<header id="title-block-header">
<h1 class="title" style="text-align:center">A proposal to add linear algebra support to the C++ standard library</h1>

<table style="border:none;float:right">
  <tr>
    <td>Document #: </td>
    <td>P1385R3</td>
  </tr>
  <tr>
    <td>Date: </td>
    <td>2019-10-07</td>
  </tr>
  <tr>
    <td style="vertical-align:top">Project: </td>
    <td>Programming Language C++<br>
      LEWG, SG14, SG6<br>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top">Reply-to: </td>
    <td>
      Guy Davidson<br>&lt;<a href="mailto:guy@hatcat.com" class="email">guy@hatcat.com</a>&gt;<br>
      Bob Steagall<br>&lt;<a href="mailto:bob.steagall.cpp@gmail.com" class="email">bob.steagall.cpp@gmail.com</a>&gt;<br>
    </td>
  </tr>
</table>

</header>
<div style="clear:both">
<div id="TOC" role="doc-toc">
<h1 id="toctitle">Contents</h1>
<ul>
<li><a href="#abstract">Abstract<span></span></a></li>
<li><a href="#revision-history">Revision history<span></span></a></li>
<li><a href="#open-issues">Open issues<span></span></a></li>
<li><a href="#introduction"><span class="toc-section-number">1</span> Introduction<span></span></a></li>
<li><a href="#goals"><span class="toc-section-number">2</span> Goals<span></span></a></li>
<li><a href="#definitions"><span class="toc-section-number">3</span> Definitions<span></span></a><ul>
<li><a href="#mathematical-terms"><span class="toc-section-number">3.1</span> Mathematical terms<span></span></a></li>
<li><a href="#terms-pertaining-to-c-types"><span class="toc-section-number">3.2</span> Terms pertaining to C++ types<span></span></a></li>
<li><a href="#overloaded-terms"><span class="toc-section-number">3.3</span> Overloaded terms<span></span></a><ul>
<li><a href="#matrix"><span class="toc-section-number">3.3.1</span> Matrix<span></span></a></li>
<li><a href="#vector"><span class="toc-section-number">3.3.2</span> Vector<span></span></a></li>
<li><a href="#dimension"><span class="toc-section-number">3.3.3</span> Dimension<span></span></a></li>
<li><a href="#rank"><span class="toc-section-number">3.3.4</span> Rank<span></span></a></li>
</ul></li>
</ul></li>
<li><a href="#scope"><span class="toc-section-number">4</span> Scope<span></span></a><ul>
<li><a href="#functional-requirements"><span class="toc-section-number">4.1</span> Functional requirements<span></span></a></li>
<li><a href="#considered-but-excluded"><span class="toc-section-number">4.2</span> Considered but excluded<span></span></a></li>
</ul></li>
<li><a href="#design-aspects"><span class="toc-section-number">5</span> Design aspects<span></span></a><ul>
<li><a href="#memory-source"><span class="toc-section-number">5.1</span> Memory source<span></span></a></li>
<li><a href="#addressing-model"><span class="toc-section-number">5.2</span> Addressing model<span></span></a></li>
<li><a href="#memory-ownership"><span class="toc-section-number">5.3</span> Memory ownership<span></span></a></li>
<li><a href="#capacity-and-resizability"><span class="toc-section-number">5.4</span> Capacity and resizability<span></span></a></li>
<li><a href="#element-layout"><span class="toc-section-number">5.5</span> Element layout<span></span></a></li>
<li><a href="#element-access-and-indexing"><span class="toc-section-number">5.6</span> Element access and indexing<span></span></a></li>
<li><a href="#element-type"><span class="toc-section-number">5.7</span> Element type<span></span></a></li>
<li><a href="#mixed-element-type-expressions"><span class="toc-section-number">5.8</span> Mixed-element-type expressions<span></span></a></li>
<li><a href="#mixed-engine-expressions"><span class="toc-section-number">5.9</span> Mixed-engine expressions<span></span></a></li>
<li><a href="#arithmetic-customization"><span class="toc-section-number">5.10</span> Arithmetic customization<span></span></a></li>
<li><a href="#linear-algebra-and-constexpr"><span class="toc-section-number">5.11</span> Linear algebra and <code>constexpr</code><span></span></a></li>
</ul></li>
<li><a href="#interface-description"><span class="toc-section-number">6</span> Interface description<span></span></a><ul>
<li><a href="#overview"><span class="toc-section-number">6.1</span> Overview<span></span></a><ul>
<li><a href="#template-parameter-nomenclature"><span class="toc-section-number">6.1.1</span> Template parameter nomenclature<span></span></a></li>
</ul></li>
<li><a href="#stdmath-namespace"><span class="toc-section-number">6.2</span> <code>std::math</code> namespace<span></span></a></li>
<li><a href="#header-linear_algebra-synopsis"><span class="toc-section-number">6.3</span> Header <code>&lt;linear_algebra&gt;</code> synopsis<span></span></a></li>
<li><a href="#numeric-traits"><span class="toc-section-number">6.4</span> Numeric traits<span></span></a><ul>
<li><a href="#number_traitst"><span class="toc-section-number">6.4.1</span> <code>number_traits&lt;T&gt;</code><span></span></a></li>
<li><a href="#is_complext"><span class="toc-section-number">6.4.2</span> <code>is_complex&lt;T&gt;</code><span></span></a></li>
<li><a href="#is_fieldt"><span class="toc-section-number">6.4.3</span> <code>is_field&lt;T&gt;</code><span></span></a></li>
<li><a href="#is_ringt"><span class="toc-section-number">6.4.4</span> <code>is_ring&lt;T&gt;</code><span></span></a></li>
<li><a href="#is_nc_ringt"><span class="toc-section-number">6.4.5</span> <code>is_nc_ring&lt;T&gt;</code><span></span></a></li>
<li><a href="#is_matrix_elementt"><span class="toc-section-number">6.4.6</span> <code>is_matrix_element&lt;T&gt;</code><span></span></a></li>
</ul></li>
<li><a href="#engine-types"><span class="toc-section-number">6.5</span> Engine Types<span></span></a><ul>
<li><a href="#matrix_column_viewet"><span class="toc-section-number">6.5.1</span> <code>matrix_column_view&lt;ET&gt;</code><span></span></a></li>
<li><a href="#matrix_row_viewet"><span class="toc-section-number">6.5.2</span> <code>matrix_row_view&lt;ET&gt;</code><span></span></a></li>
<li><a href="#matrix_transpose_viewet"><span class="toc-section-number">6.5.3</span> <code>matrix_transpose_view&lt;ET&gt;</code><span></span></a></li>
<li><a href="#fs_vector_enginet-n"><span class="toc-section-number">6.5.4</span> <code>fs_vector_engine&lt;T, N&gt;</code><span></span></a></li>
<li><a href="#fs_matrix_enginet-r-c"><span class="toc-section-number">6.5.5</span> <code>fs_matrix_engine&lt;T, R, C&gt;</code><span></span></a></li>
<li><a href="#dr_vector_enginet-at"><span class="toc-section-number">6.5.6</span> <code>dr_vector_engine&lt;T, AT&gt;</code><span></span></a></li>
<li><a href="#dr_matrix_enginet-at"><span class="toc-section-number">6.5.7</span> <code>dr_matrix_engine&lt;T, AT&gt;</code><span></span></a></li>
</ul></li>
<li><a href="#math-object-types"><span class="toc-section-number">6.6</span> Math object types<span></span></a><ul>
<li><a href="#vectoret-ot"><span class="toc-section-number">6.6.1</span> <code>vector&lt;ET, OT&gt;</code><span></span></a></li>
<li><a href="#matrixet-ot"><span class="toc-section-number">6.6.2</span> <code>matrix&lt;ET, OT&gt;</code><span></span></a></li>
</ul></li>
<li><a href="#operation-traits"><span class="toc-section-number">6.7</span> Operation traits<span></span></a><ul>
<li><a href="#matrix_operation_traits"><span class="toc-section-number">6.7.1</span> <code>matrix_operation_traits</code><span></span></a></li>
<li><a href="#matrix_operation_traits_selectorot1-ot2"><span class="toc-section-number">6.7.2</span> <code>matrix_operation_traits_selector&lt;OT1, OT2&gt;</code><span></span></a></li>
</ul></li>
<li><a href="#element-promotion-traits"><span class="toc-section-number">6.8</span> Element promotion traits<span></span></a><ul>
<li><a href="#matrix_negation_element_traitst1"><span class="toc-section-number">6.8.1</span> <code>matrix_negation_element_traits&lt;T1&gt;</code><span></span></a></li>
<li><a href="#matrix_addition_element_traitst1-t2"><span class="toc-section-number">6.8.2</span> <code>matrix_addition_element_traits&lt;T1, T2&gt;</code><span></span></a></li>
<li><a href="#matrix_subtraction_element_traitst1-t2"><span class="toc-section-number">6.8.3</span> <code>matrix_subtraction_element_traits&lt;T1, T2&gt;</code><span></span></a></li>
<li><a href="#matrix_multiplication_element_traitst1-t2"><span class="toc-section-number">6.8.4</span> <code>matrix_multiplication_element_traits&lt;T1, T2&gt;</code><span></span></a></li>
</ul></li>
<li><a href="#engine-promotion-traits"><span class="toc-section-number">6.9</span> Engine promotion traits<span></span></a><ul>
<li><a href="#matrix_negation_engine_traitsot-et1"><span class="toc-section-number">6.9.1</span> <code>matrix_negation_engine_traits&lt;OT, ET1&gt;</code><span></span></a></li>
<li><a href="#matrix_addition_engine_traitsot-et1-et2"><span class="toc-section-number">6.9.2</span> <code>matrix_addition_engine_traits&lt;OT, ET1, ET2&gt;</code><span></span></a></li>
<li><a href="#matrix_subtraction_engine_traitsot-et1-et2"><span class="toc-section-number">6.9.3</span> <code>matrix_subtraction_engine_traits&lt;OT, ET1, ET2&gt;</code><span></span></a></li>
<li><a href="#matrix_multiplication_engine_traitsot-et1-et2"><span class="toc-section-number">6.9.4</span> <code>matrix_multiplication_engine_traits&lt;OT, ET1, ET2&gt;</code><span></span></a></li>
</ul></li>
<li><a href="#arithmetic-traits"><span class="toc-section-number">6.10</span> Arithmetic traits<span></span></a><ul>
<li><a href="#matrix_negation_traitsot-op1"><span class="toc-section-number">6.10.1</span> <code>matrix_negation_traits&lt;OT, OP1&gt;</code><span></span></a></li>
<li><a href="#matrix_addition_traitsot-op1-op2"><span class="toc-section-number">6.10.2</span> <code>matrix_addition_traits&lt;OT, OP1, OP2&gt;</code><span></span></a></li>
<li><a href="#matrix_subtraction_traitsot-op1-op2"><span class="toc-section-number">6.10.3</span> <code>matrix_subtraction_traits&lt;OT, OP1, OP2&gt;</code><span></span></a></li>
<li><a href="#matrix_multiplication_traitsot-op1-op2"><span class="toc-section-number">6.10.4</span> <code>matrix_multiplication_traits&lt;OT, OP1, OP2&gt;</code><span></span></a></li>
</ul></li>
<li><a href="#arithmetic-operators"><span class="toc-section-number">6.11</span> Arithmetic operators<span></span></a></li>
</ul></li>
<li><a href="#customization"><span class="toc-section-number">7</span> Customization<span></span></a><ul>
<li><a href="#integrating-a-new-element-type"><span class="toc-section-number">7.1</span> Integrating a new element type<span></span></a></li>
<li><a href="#custom-element-promotion"><span class="toc-section-number">7.2</span> Custom element promotion<span></span></a></li>
<li><a href="#integrating-a-new-engine-type"><span class="toc-section-number">7.3</span> Integrating a new engine type<span></span></a></li>
<li><a href="#customizing-an-arithmetic-operation"><span class="toc-section-number">7.4</span> Customizing an arithmetic operation<span></span></a></li>
</ul></li>
<li><a href="#meeting-feedback"><span class="toc-section-number">8</span> Meeting feedback<span></span></a><ul>
<li><a href="#cologne-2019"><span class="toc-section-number">8.1</span> Cologne 2019<span></span></a></li>
<li><a href="#kona-2019"><span class="toc-section-number">8.2</span> Kona 2019<span></span></a><ul>
<li><a href="#lewgi-polls-and-feedback-wednesday-2019-02-20"><span class="toc-section-number">8.2.1</span> LEWG(I) Polls and Feedback (Wednesday 2019-02-20)<span></span></a></li>
<li><a href="#feedback-from-joint-sg14sg19-session-friday-2019-02-22"><span class="toc-section-number">8.2.2</span> Feedback From Joint SG14/SG19 Session (Friday 2019-02-22)<span></span></a></li>
<li><a href="#other-suggestions-gathered-at-the-meeting"><span class="toc-section-number">8.2.3</span> Other Suggestions Gathered at the Meeting<span></span></a></li>
</ul></li>
</ul></li>
</ul>
</div>
<h1 id="abstract" class="unnumbered">Abstract<a href="#abstract" class="self-link"></a></h1>
<p>This document proposes a set of fundamental linear algebra types and functions for the standard C++ library. The facilities described herein are pure addtions, requiring no changes to existing implementations,</p>
<h1 id="revision-history" class="unnumbered">Revision history<a href="#revision-history" class="self-link"></a></h1>
<table>
<colgroup>
<col style="width: 12%"></col>
<col style="width: 87%"></col>
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;"><div style="text-align:center">
<strong>Version</strong>
</div></th>
<th style="text-align: left;"><div style="text-align:center">
<strong>Description</strong>
</div></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">R0</td>
<td style="text-align: left;">Initial version for pre-Kona mailing.</td>
</tr>
<tr class="even">
<td style="text-align: center;">D1</td>
<td style="text-align: left;">Update for presentation at Kona; includes operation traits.</td>
</tr>
<tr class="odd">
<td style="text-align: center;">R1</td>
<td style="text-align: left;">Update for post-Kona mailing; includes feedback from LEWG(I) and joint SG14/SG19 session.</td>
</tr>
<tr class="even">
<td style="text-align: center;">R2</td>
<td style="text-align: left;"><p>Update for Cologne meeting; includes feedback from Kona and monthly SIG conference calls.</p>
<ul>
<li>Emphasized proposed <code>std::math</code> namespace</li>
<li>Replaced <code>row_vector</code> and <code>column_vector</code> types with a single <code>vector</code> type to represent both.</li>
<li>Removed discussion regarding 0-based or 1-based indexing in favor of 0-based.</li>
<li>Reduced number of customization points within namespace <code>std</code> to two.</li>
</ul></td>
</tr>
<tr class="odd">
<td style="text-align: center;">D3</td>
<td style="text-align: left;"><p>Last-minute update for Cologne meeting.</p>
<ul>
<li>Remove erroneous references to <code>row_vector</code> and <code>column_vector</code> in the R2 text.</li>
</ul></td>
</tr>
<tr class="even">
<td style="text-align: center;">R3</td>
<td style="text-align: left;"><p>Update for Belfast meeting.</p>
<ul>
<li>Remove more erroneous references to <code>row_vector</code> and <code>column_vector</code>.</li>
</ul></td>
</tr>
</tbody>
</table>
<h1 id="open-issues" class="unnumbered">Open issues<a href="#open-issues" class="self-link"></a></h1>
<ol type="1">
<li><p>Explore how to specify concepts for numerical types.</p></li>
<li><p>Explore use of boolean <code>true</code>/<code>false</code> vs. <code>std::true_type</code>/<code>std::false_type</code> for nested property predicates in math types.</p></li>
<li><p>Employ <code>mdspan</code> as a component for implementation and as a medium of information exchange with other libraries / facilities.</p></li>
<li><p>Explore interface designs to support distributed/parallel/multithreaded arithmetic.</p></li>
<li><p>Explore value-based and expression-based approaches to the arithmetic operators.</p></li>
<li><p>Add type requirements tables.</p></li>
<li><p>Add a Gor table.</p></li>
<li><p>Develop tutorial materials and examples.</p></li>
<li><p>Formulate wording.</p></li>
</ol>
<h1 id="introduction"><span class="header-section-number">1</span> Introduction<a href="#introduction" class="self-link"></a></h1>
<p>Linear algebra is a mathematical discipline of ever-increasing importance, with direct application to a wide variety of problem domains, such as signal processing, computer graphics, medical imaging, scientific simulations, machine learning, analytics, financial modeling, and high-performance computing. And yet, despite the relevance of linear algebra to so many aspects of modern computing, the C++ standard library does not include a set of linear algebra facilities. This paper proposes to remedy this deficit for C++23.</p>
<p>This paper should be read after P1166, in which we describe a high-level set of expectations for what a linear algebra library should contain.</p>
<h1 id="goals"><span class="header-section-number">2</span> Goals<a href="#goals" class="self-link"></a></h1>
<p>We expect that typical users of a standard linear algebra library are likely to value two features above all else: ease-of-use (including expressiveness), and high performance out of the box. This set of users will expect the ability to compose arithmetical expressions of linear algebra objects similar to what one might find in a textbook; indeed, this has been deemed a “must-have” feature by several participants in recent SG14 Linear Algebra SIG conference calls. And for a given arithmetical expression, they will expect run-time computational performance that is close to what they could obtain with an equivalent sequence of function calls to a more “traditional” linear algebra library, such as <em>LAPCK</em>, <em>Blaze</em>, <em>Eigen</em>, etc.</p>
<p>There also exists a set of linear algebra “super-users” who will value most highly a third feature – the ability to customize underlying infrastructure in order to maximize performance for specific problems and computing platforms. These users seek the highest possible run-time performance, and to achieve it, require the ability to customize any and every portion of the library’s computational infrastructure.</p>
<p>With these high-level user requirements in mind, in this paper we propose an interface specification intended to achieve the following goals:</p>
<ol type="1">
<li><p>To provide a set of vocabulary types for representing the mathematical objects and operations that are relevant to linear algebra;</p></li>
<li><p>To provide a public interface for linear algebra operations that is intuitive, teachable, and mimics the expressiveness of mathematical notation to the greatest <em>reasonable</em> extent;</p></li>
<li><p>To exhibit out-of-the-box performance in the neighborhood of that of that exhibited by an equivalent sequence of function calls to a more traditional linear algebra library, such as <em>LAPACK</em>, <em>Blaze</em>, <em>Eigen</em>, etc.;</p></li>
<li><p>To provide a set of building blocks that manage the source, ownership, lifetime, layout, and access of the memory required to represent the linear algebra vocabulary types, with the requirement that some of these building blocks are also suitable for (eventually) representing other interesting mathematical entities, such as quaternions, octonions, and tensors;</p></li>
<li><p>To provide straightforward facilities and techniques for customization that enable users to optimize performance for their specific problem domain on their specific hardware; and,</p></li>
<li><p>To provide a <em>reasonable</em> level of granularity for customization so that developers only have to implement a minimum set of types and functions to integrate their performance enhancements with the rest of the linear algebra facilities described here.</p></li>
</ol>
<h1 id="definitions"><span class="header-section-number">3</span> Definitions<a href="#definitions" class="self-link"></a></h1>
<p>When discussing linear algebra and related topics for a proposal such as this, it is important to note that there are several overloaded terms (such as <em>matrix</em>, <em>vector</em>, <em>dimension</em>, and <em>rank</em>) which must be defined and disambiguated if such discussions are to be productive. These terms have specific meanings in mathematics, as well as different, but confusingly similar, meanings to C++ programmers.</p>
<p>In the following sections we provide definitions for relevant mathematical concepts, C++ type design concepts, and describe how this proposal employs those overloaded terms in various contexts.</p>
<h2 id="mathematical-terms"><span class="header-section-number">3.1</span> Mathematical terms<a href="#mathematical-terms" class="self-link"></a></h2>
<p>In order to facilitate subsequent discussion, we first provide the following <em>informal</em> set of definitions for important mathematical concepts:</p>
<ol type="1">
<li><p>A <strong>vector space</strong> is a collection of <strong>vectors</strong>, where vectors are objects that may be added together and multiplied by scalars. Euclidean vectors are an example of a vector space, typically used to represent displacements, as well as physical quantities such as force or momentum. Linear algebra is concerned primarily with the study of vector spaces.</p></li>
<li><p>The <strong>dimension</strong> of a vector space is the minimum number of coordinates required to specify any point within the space.</p></li>
<li><p>A <strong>matrix</strong> is a rectangular array of numbers, symbols, or expressions, arranged in rows and columns. A matrix having <em>m</em> rows and <em>n</em> columns is said to have size <em>m</em> x <em>n</em>. Although matrices can be used solve systems of simultaneous linear equations, they are most commonly used to represent linear transformations, solve linear least squares problems, and to explore and/or manipulate the properties of vector spaces.</p></li>
<li><p>The <strong>rank</strong> of a matrix is the dimension of the vector space spanned by its columns, which is equal to the dimension of the vector space spanned by its rows. The rank is also equal to the maximum number of linearly-independent columns and rows.</p></li>
<li><p>An <strong>element</strong> of a matrix is an individual member (number, symbol, expression) of the rectangular array comprising the matrix, lying at the intersection of a single row and a single column. In traditional mathematical notation, row and column indexing is 1-based, where rows are indexed from 1 to <em>m</em> and columns are indexed from 1 to <em>n</em>. Given some matrix <em>A</em>, element <em>a</em><sub><em>11</em></sub> refers to the element in the upper left-hand corner of the array and element <em>a</em><sub><em>mn</em></sub> refers to the element in the lower right-hand corner.</p></li>
<li><p>A <strong>row vector</strong> is a matrix containing a single row; in other words, a matrix of size <em>1</em> x <em>n</em>. In many applications of linear algebra, row vectors represent spatial vectors.</p></li>
<li><p>A <strong>column vector</strong> is a matrix containing a single column; in other words, a matrix of size <em>m</em> x <em>1</em>. In many applications of linear algebra, column vectors represent spatial vectors.</p></li>
<li><p><strong>Element transforms</strong> are non-arithmetical operations that modify the relative positions of elements in a matrix, such as transpose, column exchange, and row exchange.</p></li>
<li><p><strong>Element arithmetic</strong> refers to arithmetical operations that read or modify the values of individual elements independently of other elements, such assigning a value to a specific element or multiplying a row by some value.</p></li>
<li><p><strong>Matrix arithmetic</strong> refers to the assignment, addition, subtraction, negation, multiplication, and determinant operations defined for matrices, row vectors, and column vectors as wholes.</p></li>
<li><p>A <strong>rectangular matrix</strong> is a matrix requiring a full <em>m</em> x <em>n</em> representation; that is, a matrix not possessing a special form, such as identity, triangular, band, etc.</p></li>
<li><p>The <strong>identity matrix</strong> is a square matrix where all elements on the diagonal are equal to one and all off-diagonal elements are equal to zero.</p></li>
<li><p>A <strong>triangular matrix</strong> is a matrix where all elements above or below the diagonal are zero; those with non-zero elements above the diagonal are called <em>upper triangular</em>, while those with non-zero elements below the diagonal are called <em>lower triangular</em>.</p></li>
<li><p>A <strong>band matrix</strong> is a sparse matrix whose non-zero entries are confined to a diagonal band, lying on the main diagonal and zero or more diagonals on either side.</p></li>
<li><p><strong>Decompositions</strong> are complex sequences of arithmetic operations, element arithmetic, and element transforms performed upon a matrix that expose important mathematical properties of that matrix. Several types of decomposition are often performed in solving least-squares problems.</p></li>
<li><p><strong>Eigen-decompositions</strong> are decompositions performed upon a symmetric matrix in order to compute the eigenvalues and eigenvectors of that matrix; this is often performed when solving problems involving linear dynamic systems.</p></li>
</ol>
<h2 id="terms-pertaining-to-c-types"><span class="header-section-number">3.2</span> Terms pertaining to C++ types<a href="#terms-pertaining-to-c-types" class="self-link"></a></h2>
<p>The following are terms used in this proposal that describe various aspects of how the mathematical concepts described above in Section 3.1 might be implemented:</p>
<ol type="1">
<li><p>An <strong>array</strong> is a data structure representing an indexable collection of objects (elements) such that each element is identified by at least one index. An array is said to be <em>one-dimensional</em> array if its elements are accessible with a single index; a <em>multi-dimensional</em> array is an array for which more than one index is required to access its elements.</p></li>
<li><p>The <strong>dimension</strong> of an array refers to the number of indices required to access an element of that array. The <strong>rank</strong> of an array is a synonym for its dimension.</p></li>
<li><p>This proposal uses the term <strong>MathObj</strong> to refer generically to one of the C++ types described herein representing matrices and vectors (i.e., <code>matrix</code> and <code>vector</code>). These are the public-facing types developers will use in their code.</p></li>
<li><p>An <strong>engine</strong> is an implementation type that manages the resources associated with a <em>MathObj</em> instance. This includes, at a minumum, the storage-related aspects of, and access to, the elements of a <em>MathObj</em>. It could also include execution-related aspects, such as an execution context. In this proposal, an engine object is a private member of a <em>MathObj</em>. Other than as a template parameter, engines are not part of a <em>MathObj</em>’s public interface.</p></li>
<li><p>The adjective <strong>dense</strong> refers to a <em>MathObj</em> representation where storage is allocated for every element.</p></li>
<li><p>The adjective <strong>sparse</strong> refers to a <em>MathObj</em> representation where storage is allocated only for non-zero elements;</p></li>
<li><p><strong>Storage</strong> is used by this proposal as a synonym for memory.</p></li>
<li><p><strong>Traits</strong> refers to a stateless class template that provides some set of services, normalizing those services over its set of template parameters.</p></li>
<li><p><strong>Row size</strong> and <strong>column size</strong> refer to the number of rows and columns, respectively, that a <em>MathObj</em> represents, which must be less than or equal to its row and column capacities, defined below.</p></li>
<li><p><strong>Row capacity</strong> and <strong>column capacity</strong> refer to the maximum number of rows and columns, respectively, that a <em>MathObj</em> can possibly represent.</p></li>
<li><p><strong>Fixed-size</strong> (FS) refers to an engine type whose row and column sizes are fixed at instantiation time and constant thereafter.</p></li>
<li><p><strong>Fixed-capacity</strong> (FC) refers to an engine type whose row and column capacities are fixed at instantiation time and constant thereafter.</p></li>
<li><p><strong>Dynamically re-sizable</strong> (DR) refers to an engine type whose row and column sizes and capacities may be changed at run time.</p></li>
</ol>
<h2 id="overloaded-terms"><span class="header-section-number">3.3</span> Overloaded terms<a href="#overloaded-terms" class="self-link"></a></h2>
<p>This section describes how we use certain overloaded terms in this proposal and in future works.</p>
<h3 id="matrix"><span class="header-section-number">3.3.1</span> Matrix<a href="#matrix" class="self-link"></a></h3>
<p>The term <em>matrix</em> is frequently used by C++ programmers to mean a general-purpose array of arbitrary size. For example, one of the authors worked at a company where it was common practice to refer to 4-dimensional arrays as “4-dimensional matrices.”</p>
<p>In this proposal, we use the word <em>array</em> only to mean a data structure whose elements are accessible using one or more indices, and which has no invariants pertaining to higher-level or mathematical meaning.</p>
<p>We use <em>matrix</em> to mean the mathematical object as defined above in Section 3.1, and <code>matrix</code> (in monospaced font) to mean the C++ class template that implements the mathematical object. We sometimes use <code>MathObj</code> (in monospaced font) in some of the component interface code and text below to generically refer to a <code>matrix</code> or <code>vector</code> object.</p>
<h3 id="vector"><span class="header-section-number">3.3.2</span> Vector<a href="#vector" class="self-link"></a></h3>
<p>Likewise, many C++ programmers incorrectly use the term <em>vector</em> as a synonym for “dynamically re-sizable array.” This bad habit is reinforced by the unfortunate naming of <code>std::vector</code>.</p>
<p>This proposal uses the term <em>vector</em> to mean an element of a vector space, per Section 3.1 above. Further, we also mean <em>vector</em> generically to have both of the meanings set out in 3.1, and <code>vector</code> (in monospaced font) is the C++ class template implementing those mathematical objects. We sometimes use <code>MathObj</code> (in monospaced font) in some of the component code interface code and test below to generically refer to a <code>vector</code> or <code>matrix</code> object.</p>
<h3 id="dimension"><span class="header-section-number">3.3.3</span> Dimension<a href="#dimension" class="self-link"></a></h3>
<p>In linear algebra, a vector space <em>V</em> is said to be of <em>dimension n</em>, or be <em>n-dimensional</em>, if there exist <em>n</em> linearly independent vectors which span <em>V</em>. This is another way of saying that <em>n</em> is the minimum number of coordinates required to specify any point in <em>V</em>. However, in common programming parlance, <em>dimension</em> refers to the number of indices used to access an element in an array.</p>
<p>We use the term dimension both ways in this proposal, but try to do so consistently and in a way that is clear from the context. For example, a rotation matrix used by a game engine is two-dimensional data structure composed of three-dimensional row and column vectors. A vector describing an electric field is an example of a one-dimensional data structure that could be implemented as a three-dimensional column vector.</p>
<h3 id="rank"><span class="header-section-number">3.3.4</span> Rank<a href="#rank" class="self-link"></a></h3>
<p>The <em>rank</em> of a matrix is the dimension of the vector space spanned by its columns (or rows), which corresponds to the maximal number of linearly independent columns (or rows) of that matrix. Rank also has another meaning in tensor analysis, where it is commonly used as a synonym for a tensor’s <em>order</em>.</p>
<p>However, rank also has a meaning in computer science where it is used as a synonym for dimension. In the C++ standard at [<em>meta.unary.prop.query</em>], rank is described as the number of dimensions of <code>T</code> if <code>T</code> names an array, otherwise it is zero.</p>
<p>We avoid using the term <em>rank</em> in this proposal in the context of linear algebra, except as a quantity that might result from performing certain decompositions wherein the mathematical rank of a matrix is computed.</p>
<h1 id="scope"><span class="header-section-number">4</span> Scope<a href="#scope" class="self-link"></a></h1>
<p>We contend that the best approach for standardizing a set of linear algebra components for C++23 will be one that is layered, iterative, and incremental. This paper is quite deliberately a “basic linear algebra-only” proposal; it describes what we believe is a foundational layer providing the minimum set of components and arithmetic operations necessary to provide a reasonable, basic level of functionality.</p>
<p>Higher-level functionality can be specified in terms of the interfaces described here, and we encourage succession papers to explore this possibility.</p>
<h2 id="functional-requirements"><span class="header-section-number">4.1</span> Functional requirements<a href="#functional-requirements" class="self-link"></a></h2>
<p>The foundational layer, as described here, should include the minimal set of types and functions required to perform matrix arithmetic in finite dimensional spaces. This includes:</p>
<ul>
<li><p>Matrix and vector class templates;</p></li>
<li><p>Arithmetic operations for addition, subtraction, negation, and multiplication of matrices and vectors;</p></li>
<li><p>Arithmetic operations for scalar multiplication of matrices and vectors;</p></li>
<li><p>Well-defined facilities for integrating new element types;</p></li>
<li><p>Well-defined facilities for creating and integrating custom engines; and,</p></li>
<li><p>Well-defined facilities for creating and integrating custom arithmetic operations.</p></li>
</ul>
<h2 id="considered-but-excluded"><span class="header-section-number">4.2</span> Considered but excluded<a href="#considered-but-excluded" class="self-link"></a></h2>
<p><strong>Tensors</strong></p>
<p>There has been a great deal of interest expressed in specifying an interface for general-purpose tensor processing in which linear algebra facilities fall out as a special case. We exclude this idea from this proposal for two reasons. First, given the practical realities of standardization work, the enormous scope of such an effort would very likely delay introduction of linear algebra facilities until C++26 or later.</p>
<p>Second, and more importantly, implementing matrices as derived types or specializations of a general-purpose tensor type is bad type design. Consider the following: a tensor is (informally) an array of mathematical objects (numbers or functions) such that its elements transform according to certain rules under a coordinate system change. In a <em>p</em>-dimensional space, a tensor of rank <em>n</em> will have <em>p</em><sup><em>n</em></sup> elements. In particular, a rank-2 tensor in a <em>p</em>-dimensional space may be represented by a <em>p</em> x <em>p</em> matrix having certain invariants related to coordinate transformation not possessed by all <em>p</em> x <em>p</em> matrices.</p>
<p>These defining characteristics of a tensor lead us to the crux of the issue: every rank-2 tensor can be represented by a square matrix, but not every square matrix represents a tensor. As one quickly realizes, only a small fraction of all possible matrices are representations of rank-2 tensors.</p>
<p>All of this is a long way of saying that the class invariants governing a matrix type are quite different from those governing a tensor type, and as such, the public interfaces of such types will also differ substantially.</p>
<p>From this we conclude that matrices are not Liskov-substitutable for rank-2 tensors, and therefore as matter of good type design, matrices and tensors should be implemented as distinct types, perhaps with appropriate inter-conversion operations.</p>
<p>This situation is analogous to the age-old object-oriented design question: when designing a group of classes that represent geometric shapes, is a square a kind of rectangle? In other words, should class <code>square</code> be publicly derived from class <code>rectangle</code>? Mathematically, yes, a square <em>is</em> a rectangle. But from the perspective of good interface design, class <code>square</code> is not substitutable for class <code>rectangle</code> and is usually best implemented as a distinct type having no IS-A relationship with <code>rectangle</code>.</p>
<p><strong>Quaternions and octonions</strong></p>
<p>There has also been interest expressed in including other useful mathematical objects, such as quaternions and octonions, as part of a standard linear algebra library. Although element storage for these types might be implemented using the engines described in this proposal, quaternions and octonions represent mathematical concepts that are fundamentally different from those of matrices and vectors.</p>
<p>As with tensors, the class invariants and public interfaces for quaternions and octonions would be substantially different from that of the linear algebra components. Liskov substitutability would not be possible, and therefore quaternions and octonions should be implemented as types distinct from the linear algebra types.</p>
<h1 id="design-aspects"><span class="header-section-number">5</span> Design aspects<a href="#design-aspects" class="self-link"></a></h1>
<p>The following describe several important aspects of the problem domain affecting the design of the proposed interface. Importantly, these aspects are orthogonal, and are addressable through judicious combinations of template parameters and implementation type design.</p>
<h2 id="memory-source"><span class="header-section-number">5.1</span> Memory source<a href="#memory-source" class="self-link"></a></h2>
<p>Perhaps the first question to be answered is that of the source of memory in which elements will reside. One can easily imagine multiple sources of memory:</p>
<ul>
<li><p>Elements reside in an external buffer allocated from the global heap.</p></li>
<li><p>Elements reside in an external buffer allocated by a custom allocator and/or specialized heap.</p></li>
<li><p>Elements reside in an external fixed-size buffer that exists independently of the <em>MathObj</em>, not allocated from a heap, and which has a lifetime greater than that of the <em>MathObj</em>.</p></li>
<li><p>Elements reside in a fixed-size buffer that is a member of the <em>MathObj</em> itself.</p></li>
<li><p>Elements reside collectively in a set of buffers distributed across multiple machines.</p></li>
</ul>
<h2 id="addressing-model"><span class="header-section-number">5.2</span> Addressing model<a href="#addressing-model" class="self-link"></a></h2>
<p>It is also possible that the memory used by a <em>MathObj</em> might be addressed using what the standard calls a <em>pointer-like type</em>, also known as a <em>fancy pointer</em>.</p>
<p>For example, consider an element buffer existing in a shared memory segment managed by a custom allocator. In this case, the allocator might employ a fancy pointer type that performs location-independent addressing based on a segment index and an offset into that segment.</p>
<p>One can also imagine a fancy pointer that is a handle to a memory resource existing somewhere on a network, and addressing operations require first mapping that resource into the local address space, perhaps by copying over the network or by some magic sequence of RPC invocations.</p>
<h2 id="memory-ownership"><span class="header-section-number">5.3</span> Memory ownership<a href="#memory-ownership" class="self-link"></a></h2>
<p>The next important questions pertain to memory ownership. Should the memory in which elements reside be deallocated, and if so, what object is responsible for performing the deallocation?</p>
<p>A <em>MathObj</em> might own the memory in which it stores its elements, or it might employ some non-owning view type, like <code>mdspan</code>, to manipulate elements owned by some other object.</p>
<h2 id="capacity-and-resizability"><span class="header-section-number">5.4</span> Capacity and resizability<a href="#capacity-and-resizability" class="self-link"></a></h2>
<p>As with <code>std::string</code> and <code>std::vector</code>, it is occasionally useful for a <em>MathObj</em> to have excess storage capacity in order to reduce the number of re-allocations required by anticipated future resizing operations. Some linear algebra libraries, like LAPACK, account for the fact that a <em>MathObj</em>’s capacity may be different than its size. This capability was of critical importance to the success of one author’s prior work in functional MRI image analysis.</p>
<p>In other problem domains, like computer graphics, <em>MathObj</em>s are small and always of the same size. In this case, the size and capacity are equal, and there is no need for a <em>MathObj</em> to maintain or manage excess capacity.</p>
<h2 id="element-layout"><span class="header-section-number">5.5</span> Element layout<a href="#element-layout" class="self-link"></a></h2>
<p>There are many ways to arrange the elements of a matrix in memory, the most common in C++ being row-major dense rectangular. In Fortran-based libraries, the two-dimensional arrays used to represent matrices are usually column-major. There are also special arrangements of elements for upper/lower triangular and banded diagonal matrices that are both row-major and column-major. These arrangements of elements have been well-known for many years, and libraries like LAPACK in the hands of a knowledgeable user can use them to implement code that is optimal in both time and space.</p>
<h2 id="element-access-and-indexing"><span class="header-section-number">5.6</span> Element access and indexing<a href="#element-access-and-indexing" class="self-link"></a></h2>
<p>In keeping with the goal of supporting a natural syntax, and in analogy with the indexing operations provided by the random-access standard library containers, it seems reasonable to provide both const and non-const indexing for reading and writing individual elements.</p>
<h2 id="element-type"><span class="header-section-number">5.7</span> Element type<a href="#element-type" class="self-link"></a></h2>
<p>C++ supports a relatively narrow range of arithmetic types, lacking direct support for arbitrary precision numbers and fixed-point numbers, among others. Libraries exist to implement these types, and they should not be precluded from use in a standard linear algebra library. It is possible that individual elements of a <em>MathObj</em> may allocate memory, and therefore an implementation cannot assume that element types have trivial constructors or destructors.</p>
<h2 id="mixed-element-type-expressions"><span class="header-section-number">5.8</span> Mixed-element-type expressions<a href="#mixed-element-type-expressions" class="self-link"></a></h2>
<p>In general, when multiple built-in arithmetic types are present in an arithmetical expression, the resulting type will have a precision greater than or equal to that of the type with greatest precision in the expression. In other words, to the greatest reasonable extent, information is preserved.</p>
<p>We contend that a similar principal should apply to expressions involving <em>MathObj</em>s where more than one element type is present. Arithmetic operations involving <em>MathObj</em>s should, to the greatest reasonable extent, preserve element-wise information.</p>
<p>For example, just as the result of multiplying a <code>float</code> by a <code>double</code> is a <code>double</code>, the result multiplying a matrix-of-<code>float</code> by a matrix-of-<code>double</code> should be a matrix-of-<code>double</code>. We call the process of determining the resulting element type <em>element promotion</em>.</p>
<h2 id="mixed-engine-expressions"><span class="header-section-number">5.9</span> Mixed-engine expressions<a href="#mixed-engine-expressions" class="self-link"></a></h2>
<p>In analogy with element type, <em>MathObj</em> expressions may include mixed storage management strategies, as implemented by their corresponding engine types. For example, consider the case of a fixed-size matrix multiplied by a dynamically-resizable matrix. What is the engine type of the resulting matrix?</p>
<p>Expression involving mixed engine types should not limit the availability of basic arithmetic operations. This means that there should be a mechanism for determining the engine type of the resulting from such expressions. We call the process of determining the resulting engine type <em>engine promotion</em>.</p>
<p>We contend that in most cases, the resulting engine type should be at least as “general” as the most “general” of the two engine types. For example, one could make the argument that a dynamically-resizable engine is more general that a fixed-size engine, and therefore an the resulting engine type in an expression involving both these engine types should be a dynamically-resizable engine.</p>
<p>However, there are cases in which it may be possible to choose a more performant engine at compile time. For example, consider the case adding a fixed-size matrix and a dynamically-resizable matrix. Although size checking must be performed at run time, the resulting engine might be specified as fixed-size.</p>
<h2 id="arithmetic-customization"><span class="header-section-number">5.10</span> Arithmetic customization<a href="#arithmetic-customization" class="self-link"></a></h2>
<p>In pursuit of optimal performance, developers may want to customize specific arithmetic operations, such as matrix-matrix or matrix-vector multiplication. Customization might be based on things like element layout in memory, fixed-size -vs- dynamically resizable, special hardware capabilities, etc.</p>
<p>One such possible optimization is the use of multiple cores, perhaps distributed across a network, to carry out multiplication on very large pairs of matrices, particularly in situations where the operation is used to produce a third matrix rather than modify one of the operands; the matrix multiplication operation is particularly amenable to this approach.</p>
<p>Developers may also wish to make use of SIMD intrinsics to enable parallel evaluation of matrix multiplication. This is common in game development environments where programs are written for very specific platforms, where the make and model of processor is well defined. This would impact on element layout and storage. Such work has already been demonstrated in paper N4454.</p>
<p>It is possible that two operands may be associated with different arithmetic customizations. We call the process of determining which of those two customizations to employ when performing the actual arithmetic operations <em>operation traits promotion</em>.</p>
<h2 id="linear-algebra-and-constexpr"><span class="header-section-number">5.11</span> Linear algebra and <code>constexpr</code><a href="#linear-algebra-and-constexpr" class="self-link"></a></h2>
<p>The fundamental set of operations for linear algebra can all be implemented in terms of a subset of the algorithms defined in the <code>&lt;algorithm&gt;</code> header, all of which are marked <code>constexpr</code> since C++20. Matrix and vector initialization is of course also possible at compile time.</p>
<p>The arrival of <code>std::is_constant_evaluated</code> in C++20 makes it possible to offer a <code>constexpr</code> implementation of the operations, allowing customizations to defer to them in <code>constexpr</code> evaluations while taking the customization’s notionally superior run-time path in alternate situations.</p>
<h1 id="interface-description"><span class="header-section-number">6</span> Interface description<a href="#interface-description" class="self-link"></a></h1>
<p>In this section, we describe the various types, operators, and functions comprising the proposed interface. The reader should note that the descriptions below are by no means ready for wording; rather, they are intended to foster further discussions and refinements, and to serve as a guide for hardy souls attempting to build implementations from this specification.</p>
<h2 id="overview"><span class="header-section-number">6.1</span> Overview<a href="#overview" class="self-link"></a></h2>
<p>At the highest level, the interface is divided into three broad categories:</p>
<ol type="1">
<li><p><strong>Engines</strong>, which are implementation types that manage the resources associated with a <em>MothObj</em> instance, including memory ownership and lifetime, as well as element access; and,</p></li>
<li><p><strong>MathObjs</strong>, which provide a unified interface intended to model a corresponding mathematical abstraction (i.e., <code>vector</code>, <code>matrix</code>);</p></li>
<li><p><strong>Operators</strong>, which provide the desired mathematical syntax and carry out the promised arithmetic.</p></li>
</ol>
<p>At a lower level, and somewhat behind the scenes, are a number of supporting traits types employed by the operators to determine the return type of the operator and perform the corresponding arithmetic operation. There are several such traits types:</p>
<ul>
<li><p><strong>Numeric traits</strong> specify and test the properties of matrix element types. The proposed traits class template <code>std::math::number_traits</code> is one of two suggested customization points.</p></li>
<li><p><strong>Element promotion traits</strong> determine the resulting element type of an arithmetic operation involving two <em>elements</em>.</p></li>
<li><p><strong>Engine promotion traits</strong> determine the resulting engine type of an arithmetic operation involving <em>matrix</em> and/or <em>vector</em> objects. As part of that process, this traits type uses the element promotion traits to determine the element type of the resulting engine.</p></li>
<li><p><strong>Arithmetic traits</strong> determine the type and value of a <em>MathObj</em> resulting from an arithmetical operation. As part of that process, this traits type uses the engine promotion traits to determine the engine type of the resulting <em>MathObj</em>. Having determined the result type, the arithmetic traits also have a member function that carries out the actual computations.</p></li>
<li><p><strong>Operation traits</strong> act as a “container” for element promotion, engine promotion, and arithmetic traits. This traits type is a template parameter to the <em>MathObj</em> types, and provides a way to inform an operator of the set of available arithmetic traits to be used when deciding how to perform an arithmetic operation.</p></li>
<li><p><strong>Operation selector traits</strong> provide the means by which an arithmetic operator selects the operation traits that will perform the arithmetic. In the case where each operand has the same operation traits, the decision simple. However, it is possible that the operands may be instantiated with different operation traits types, and so the operator uses the operation selector traits to decide which operation traits type to use for computing its result. The proposed traits class <code>std::math::matrix_operation_traits</code> is the second of two suggested customization points.</p></li>
</ul>
<p>The following sections describe the building blocks in more detail, starting at the lowest level, and working upward in order of dependency.</p>
<h3 id="template-parameter-nomenclature"><span class="header-section-number">6.1.1</span> Template parameter nomenclature<a href="#template-parameter-nomenclature" class="self-link"></a></h3>
<p>To avoid excessive visual noise in the code shown in the subsequent sections of this paper, we use the following abbreviation-based naming conventions for template parameters:</p>
<ul>
<li><p>Parameter names <code>T</code>, <code>T1</code>, and <code>T2</code> represent element types.</p></li>
<li><p>Parameter names <code>ET</code>, <code>ET1</code>, and <code>ET2</code> represent engine types.</p></li>
<li><p>Parameter names <code>OT</code>, <code>OT1</code>, and <code>OT2</code> represent operation traits types.</p></li>
<li><p>Parameter names <code>OP</code>, <code>OP1</code>, and <code>OP2</code> represent the operand types deduced by an arithmetic operator.</p></li>
<li><p>Parameter names <code>AT</code>, <code>AT1</code>, and <code>AT2</code> represent allocator types.</p></li>
<li><p>Parameter names <code>N</code>, <code>N1</code>, and <code>N2</code> represent the number of elements in a fixed-size vector.</p></li>
<li><p>Parameter names <code>C</code>, <code>C1</code>, and <code>C2</code> represent the number of columns in a fixed-size matrix.</p></li>
<li><p>Parameter names <code>R</code>, <code>R1</code>, and <code>R2</code> represent the number of rows in a fixed-size matrix.</p></li>
</ul>
<h2 id="stdmath-namespace"><span class="header-section-number">6.2</span> <code>std::math</code> namespace<a href="#stdmath-namespace" class="self-link"></a></h2>
<p>We propose adding the new namespace <code>std::math</code> to the standard library to contain the linear algebra facilities described in this paper. There are two reasons for this: first, in order to group a related set of mathematical facilities in a meaningful and orderly fashion; and second, to distinguish the mathematical vector type described in this proposal, <code>std::math::vector</code>, from the general-purpose container <code>std::vector</code>.</p>
<h2 id="header-linear_algebra-synopsis"><span class="header-section-number">6.3</span> Header <code>&lt;linear_algebra&gt;</code> synopsis<a href="#header-linear_algebra-synopsis" class="self-link"></a></h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1"></a><span class="pp">#include </span><span class="im">&lt;cstdint&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="pp">#include </span><span class="im">&lt;complex&gt;</span></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="pp">#include </span><span class="im">&lt;initializer_list&gt;</span></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="pp">#include </span><span class="im">&lt;memory&gt;</span></span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="pp">#include </span><span class="im">&lt;numeric&gt;</span></span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="pp">#include </span><span class="im">&lt;tuple&gt;</span></span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="pp">#include </span><span class="im">&lt;type_traits&gt;</span></span>
<span id="cb1-9"><a href="#cb1-9"></a></span>
<span id="cb1-10"><a href="#cb1-10"></a><span class="kw">namespace</span> std<span class="op">::</span>math <span class="op">{</span></span>
<span id="cb1-11"><a href="#cb1-11"></a></span>
<span id="cb1-12"><a href="#cb1-12"></a><span class="co">//- Some tags for specifying how engines should behave.</span></span>
<span id="cb1-13"><a href="#cb1-13"></a><span class="co">//</span></span>
<span id="cb1-14"><a href="#cb1-14"></a><span class="kw">using</span> scalar_engine_tag           <span class="op">=</span> integral_constant<span class="op">&lt;</span><span class="dt">int</span>, <span class="dv">0</span><span class="op">&gt;</span>;</span>
<span id="cb1-15"><a href="#cb1-15"></a></span>
<span id="cb1-16"><a href="#cb1-16"></a><span class="kw">using</span> const_vector_engine_tag     <span class="op">=</span> integral_constant<span class="op">&lt;</span><span class="dt">int</span>, <span class="dv">1</span><span class="op">&gt;</span>;</span>
<span id="cb1-17"><a href="#cb1-17"></a><span class="kw">using</span> mutable_vector_engine_tag   <span class="op">=</span> integral_constant<span class="op">&lt;</span><span class="dt">int</span>, <span class="dv">2</span><span class="op">&gt;</span>;</span>
<span id="cb1-18"><a href="#cb1-18"></a><span class="kw">using</span> resizable_vector_engine_tag <span class="op">=</span> integral_constant<span class="op">&lt;</span><span class="dt">int</span>, <span class="dv">3</span><span class="op">&gt;</span>;</span>
<span id="cb1-19"><a href="#cb1-19"></a></span>
<span id="cb1-20"><a href="#cb1-20"></a><span class="kw">using</span> const_matrix_engine_tag     <span class="op">=</span> integral_constant<span class="op">&lt;</span><span class="dt">int</span>, <span class="dv">4</span><span class="op">&gt;</span>;</span>
<span id="cb1-21"><a href="#cb1-21"></a><span class="kw">using</span> mutable_matrix_engine_tag   <span class="op">=</span> integral_constant<span class="op">&lt;</span><span class="dt">int</span>, <span class="dv">5</span><span class="op">&gt;</span>;</span>
<span id="cb1-22"><a href="#cb1-22"></a><span class="kw">using</span> resizable_matrix_engine_tag <span class="op">=</span> integral_constant<span class="op">&lt;</span><span class="dt">int</span>, <span class="dv">6</span><span class="op">&gt;</span>;</span>
<span id="cb1-23"><a href="#cb1-23"></a></span>
<span id="cb1-24"><a href="#cb1-24"></a><span class="co">//- A traits type that supplies important information about a numerical type. </span></span>
<span id="cb1-25"><a href="#cb1-25"></a><span class="co">//  This traits class is a customization point.</span></span>
<span id="cb1-26"><a href="#cb1-26"></a><span class="co">//</span></span>
<span id="cb1-27"><a href="#cb1-27"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span>   <span class="kw">struct</span> number_traits;</span>
<span id="cb1-28"><a href="#cb1-28"></a></span>
<span id="cb1-29"><a href="#cb1-29"></a><span class="co">//- Traits for verifying appropriate matrix element types.</span></span>
<span id="cb1-30"><a href="#cb1-30"></a><span class="co">//</span></span>
<span id="cb1-31"><a href="#cb1-31"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span> <span class="kw">struct</span> is_complex;</span>
<span id="cb1-32"><a href="#cb1-32"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span> <span class="kw">struct</span> is_field;</span>
<span id="cb1-33"><a href="#cb1-33"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span> <span class="kw">struct</span> is_nc_ring;</span>
<span id="cb1-34"><a href="#cb1-34"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span> <span class="kw">struct</span> is_ring;</span>
<span id="cb1-35"><a href="#cb1-35"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span> <span class="kw">struct</span> is_matrix_element;</span>
<span id="cb1-36"><a href="#cb1-36"></a></span>
<span id="cb1-37"><a href="#cb1-37"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span> <span class="kw">inline</span> <span class="kw">constexpr</span> <span class="dt">bool</span> is_complex_v <span class="op">=</span> is_complex<span class="op">&lt;</span>T<span class="op">&gt;::</span>value;</span>
<span id="cb1-38"><a href="#cb1-38"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span> <span class="kw">inline</span> <span class="kw">constexpr</span> <span class="dt">bool</span> is_field_v   <span class="op">=</span> is_field<span class="op">&lt;</span>T<span class="op">&gt;::</span>value;</span>
<span id="cb1-39"><a href="#cb1-39"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span> <span class="kw">inline</span> <span class="kw">constexpr</span> <span class="dt">bool</span> is_ring_v    <span class="op">=</span> is_ring<span class="op">&lt;</span>T<span class="op">&gt;::</span>value;</span>
<span id="cb1-40"><a href="#cb1-40"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span> <span class="kw">inline</span> <span class="kw">constexpr</span> <span class="dt">bool</span> is_nc_ring_v <span class="op">=</span> is_nc_ring<span class="op">&lt;</span>T<span class="op">&gt;::</span>value;</span>
<span id="cb1-41"><a href="#cb1-41"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span> <span class="kw">inline</span> <span class="kw">constexpr</span> <span class="dt">bool</span> is_matrix_element_v <span class="op">=</span> is_matrix_element<span class="op">&lt;</span>T<span class="op">&gt;::</span>value;</span>
<span id="cb1-42"><a href="#cb1-42"></a></span>
<span id="cb1-43"><a href="#cb1-43"></a><span class="co">//- Non-owning view-style engines.</span></span>
<span id="cb1-44"><a href="#cb1-44"></a><span class="co">//</span></span>
<span id="cb1-45"><a href="#cb1-45"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> ET<span class="op">&gt;</span>  <span class="kw">class</span> matrix_column_view;</span>
<span id="cb1-46"><a href="#cb1-46"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> ET<span class="op">&gt;</span>  <span class="kw">class</span> matrix_row_view;</span>
<span id="cb1-47"><a href="#cb1-47"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> ET<span class="op">&gt;</span>  <span class="kw">class</span> matrix_transpose_view;</span>
<span id="cb1-48"><a href="#cb1-48"></a></span>
<span id="cb1-49"><a href="#cb1-49"></a><span class="co">//- Owning engines with fixed-size internal storage.</span></span>
<span id="cb1-50"><a href="#cb1-50"></a><span class="co">//</span></span>
<span id="cb1-51"><a href="#cb1-51"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T, <span class="dt">int32_t</span> N<span class="op">&gt;</span>            <span class="kw">class</span> fs_vector_engine;</span>
<span id="cb1-52"><a href="#cb1-52"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T, <span class="dt">int32_t</span> R, <span class="dt">int32_t</span> C<span class="op">&gt;</span> <span class="kw">class</span> fs_matrix_engine;</span>
<span id="cb1-53"><a href="#cb1-53"></a></span>
<span id="cb1-54"><a href="#cb1-54"></a><span class="co">//- Owning engines with dynamically-allocated external storage.</span></span>
<span id="cb1-55"><a href="#cb1-55"></a><span class="co">//</span></span>
<span id="cb1-56"><a href="#cb1-56"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T, <span class="kw">class</span> AT<span class="op">&gt;</span>  <span class="kw">class</span> dr_vector_engine;</span>
<span id="cb1-57"><a href="#cb1-57"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T, <span class="kw">class</span> AT<span class="op">&gt;</span>  <span class="kw">class</span> dr_matrix_engine;</span>
<span id="cb1-58"><a href="#cb1-58"></a></span>
<span id="cb1-59"><a href="#cb1-59"></a><span class="co">//- The default element promotion, engine promotion, and arithmetic operation </span></span>
<span id="cb1-60"><a href="#cb1-60"></a><span class="co">//  traits for the four basic arithmetic operations.</span></span>
<span id="cb1-61"><a href="#cb1-61"></a><span class="co">//</span></span>
<span id="cb1-62"><a href="#cb1-62"></a><span class="kw">struct</span> matrix_operation_traits;</span>
<span id="cb1-63"><a href="#cb1-63"></a></span>
<span id="cb1-64"><a href="#cb1-64"></a><span class="co">//- Primary math object types.</span></span>
<span id="cb1-65"><a href="#cb1-65"></a><span class="co">//</span></span>
<span id="cb1-66"><a href="#cb1-66"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> ET, <span class="kw">class</span> OT<span class="op">=</span>matrix_operation_traits<span class="op">&gt;</span> <span class="kw">class</span> vector;</span>
<span id="cb1-67"><a href="#cb1-67"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> ET, <span class="kw">class</span> OT<span class="op">=</span>matrix_operation_traits<span class="op">&gt;</span> <span class="kw">class</span> matrix;</span>
<span id="cb1-68"><a href="#cb1-68"></a></span>
<span id="cb1-69"><a href="#cb1-69"></a><span class="co">//- Math object element promotion traits, per arithmetical operation.</span></span>
<span id="cb1-70"><a href="#cb1-70"></a><span class="co">//</span></span>
<span id="cb1-71"><a href="#cb1-71"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T1<span class="op">&gt;</span>            <span class="kw">struct</span> matrix_negation_element_traits;</span>
<span id="cb1-72"><a href="#cb1-72"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T1, <span class="kw">class</span> T2<span class="op">&gt;</span>  <span class="kw">struct</span> matrix_addition_element_traits;</span>
<span id="cb1-73"><a href="#cb1-73"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T1, <span class="kw">class</span> T2<span class="op">&gt;</span>  <span class="kw">struct</span> matrix_subtraction_element_traits;</span>
<span id="cb1-74"><a href="#cb1-74"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T1, <span class="kw">class</span> T2<span class="op">&gt;</span>  <span class="kw">struct</span> matrix_multiplication_element_traits;</span>
<span id="cb1-75"><a href="#cb1-75"></a></span>
<span id="cb1-76"><a href="#cb1-76"></a><span class="co">//- Math object engine promotion traits, per arithmetical operation.</span></span>
<span id="cb1-77"><a href="#cb1-77"></a><span class="co">//</span></span>
<span id="cb1-78"><a href="#cb1-78"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> OT, <span class="kw">class</span> ET1<span class="op">&gt;</span>             <span class="kw">struct</span> matrix_negation_engine_traits;</span>
<span id="cb1-79"><a href="#cb1-79"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> OT, <span class="kw">class</span> ET1, <span class="kw">class</span> ET2<span class="op">&gt;</span>  <span class="kw">struct</span> matrix_addition_engine_traits;</span>
<span id="cb1-80"><a href="#cb1-80"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> OT, <span class="kw">class</span> ET1, <span class="kw">class</span> ET2<span class="op">&gt;</span>  <span class="kw">struct</span> matrix_subtraction_engine_traits;</span>
<span id="cb1-81"><a href="#cb1-81"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> OT, <span class="kw">class</span> ET1, <span class="kw">class</span> ET2<span class="op">&gt;</span>  <span class="kw">struct</span> matrix_multiplication_engine_traits;</span>
<span id="cb1-82"><a href="#cb1-82"></a></span>
<span id="cb1-83"><a href="#cb1-83"></a><span class="co">//- Math object arithmetic traits.</span></span>
<span id="cb1-84"><a href="#cb1-84"></a><span class="co">//</span></span>
<span id="cb1-85"><a href="#cb1-85"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> OT, <span class="kw">class</span> OP1<span class="op">&gt;</span>             <span class="kw">struct</span> matrix_negation_traits;</span>
<span id="cb1-86"><a href="#cb1-86"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> OT, <span class="kw">class</span> OP1, <span class="kw">class</span> OP2<span class="op">&gt;</span>  <span class="kw">struct</span> matrix_addition_traits;</span>
<span id="cb1-87"><a href="#cb1-87"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> OT, <span class="kw">class</span> OP1, <span class="kw">class</span> OP2<span class="op">&gt;</span>  <span class="kw">struct</span> matrix_subtraction_traits;</span>
<span id="cb1-88"><a href="#cb1-88"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> OT, <span class="kw">class</span> OP1, <span class="kw">class</span> OP2<span class="op">&gt;</span>  <span class="kw">struct</span> matrix_multiplication_traits;</span>
<span id="cb1-89"><a href="#cb1-89"></a></span>
<span id="cb1-90"><a href="#cb1-90"></a><span class="co">//- A traits type that chooses between two operation traits types in the binary </span></span>
<span id="cb1-91"><a href="#cb1-91"></a><span class="co">//  arithmetic operators and free functions that act like binary operators </span></span>
<span id="cb1-92"><a href="#cb1-92"></a><span class="co">//  (e.g., outer_product()).  This traits class is a customization point.</span></span>
<span id="cb1-93"><a href="#cb1-93"></a><span class="co">//</span></span>
<span id="cb1-94"><a href="#cb1-94"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> OT1, <span class="kw">class</span> OT2<span class="op">&gt;</span>  <span class="kw">struct</span> matrix_operation_traits_selector;</span>
<span id="cb1-95"><a href="#cb1-95"></a></span>
<span id="cb1-96"><a href="#cb1-96"></a><span class="co">//- Addition operators</span></span>
<span id="cb1-97"><a href="#cb1-97"></a><span class="co">//</span></span>
<span id="cb1-98"><a href="#cb1-98"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> ET1, <span class="kw">class</span> OT1, <span class="kw">class</span> ET2, <span class="kw">class</span> OT2<span class="op">&gt;</span></span>
<span id="cb1-99"><a href="#cb1-99"></a><span class="kw">auto</span>  <span class="kw">operator</span> <span class="op">+(</span>vector<span class="op">&lt;</span>ET1, OT1<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> v1, vector<span class="op">&lt;</span>ET2, OT2<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> v2<span class="op">)</span>;</span>
<span id="cb1-100"><a href="#cb1-100"></a></span>
<span id="cb1-101"><a href="#cb1-101"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> ET1, <span class="kw">class</span> OT1, <span class="kw">class</span> ET2, <span class="kw">class</span> OT2<span class="op">&gt;</span></span>
<span id="cb1-102"><a href="#cb1-102"></a><span class="kw">auto</span>  <span class="kw">operator</span> <span class="op">+(</span>matrix<span class="op">&lt;</span>ET1, OT1<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> m1, matrix<span class="op">&lt;</span>ET2, OT2<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> m2<span class="op">)</span>;</span>
<span id="cb1-103"><a href="#cb1-103"></a></span>
<span id="cb1-104"><a href="#cb1-104"></a><span class="co">//- Subtraction operators</span></span>
<span id="cb1-105"><a href="#cb1-105"></a><span class="co">//</span></span>
<span id="cb1-106"><a href="#cb1-106"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> ET1, <span class="kw">class</span> OT1, <span class="kw">class</span> ET2, <span class="kw">class</span> OT2<span class="op">&gt;</span></span>
<span id="cb1-107"><a href="#cb1-107"></a><span class="kw">auto</span>  <span class="kw">operator</span> <span class="op">-(</span>vector<span class="op">&lt;</span>ET1, OT1<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> v1, vector<span class="op">&lt;</span>ET2, OT2<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> v2<span class="op">)</span>;</span>
<span id="cb1-108"><a href="#cb1-108"></a></span>
<span id="cb1-109"><a href="#cb1-109"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> ET1, <span class="kw">class</span> OT1, <span class="kw">class</span> ET2, <span class="kw">class</span> OT2<span class="op">&gt;</span></span>
<span id="cb1-110"><a href="#cb1-110"></a><span class="kw">auto</span>  <span class="kw">operator</span> <span class="op">-(</span>matrix<span class="op">&lt;</span>ET1, OT1<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> m1, matrix<span class="op">&lt;</span>ET2, OT2<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> m2<span class="op">)</span>;</span>
<span id="cb1-111"><a href="#cb1-111"></a></span>
<span id="cb1-112"><a href="#cb1-112"></a><span class="co">//- Negation operators</span></span>
<span id="cb1-113"><a href="#cb1-113"></a><span class="co">//</span></span>
<span id="cb1-114"><a href="#cb1-114"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> ET1, <span class="kw">class</span> OT1<span class="op">&gt;</span></span>
<span id="cb1-115"><a href="#cb1-115"></a><span class="kw">auto</span>  <span class="kw">operator</span> <span class="op">-(</span>vector<span class="op">&lt;</span>ET1, OT1<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> v1<span class="op">)</span>;</span>
<span id="cb1-116"><a href="#cb1-116"></a></span>
<span id="cb1-117"><a href="#cb1-117"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> ET1, <span class="kw">class</span> OT1, <span class="kw">class</span> ET2, <span class="kw">class</span> OT2<span class="op">&gt;</span></span>
<span id="cb1-118"><a href="#cb1-118"></a><span class="kw">auto</span>  <span class="kw">operator</span> <span class="op">-(</span>matrix<span class="op">&lt;</span>ET1, OT1<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> m1<span class="op">)</span>;</span>
<span id="cb1-119"><a href="#cb1-119"></a></span>
<span id="cb1-120"><a href="#cb1-120"></a><span class="co">//- Vector*Scalar multiplication operators</span></span>
<span id="cb1-121"><a href="#cb1-121"></a><span class="co">//</span></span>
<span id="cb1-122"><a href="#cb1-122"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> ET1, <span class="kw">class</span> OT1, <span class="kw">class</span> S2<span class="op">&gt;</span></span>
<span id="cb1-123"><a href="#cb1-123"></a><span class="kw">auto</span>  <span class="kw">operator</span> <span class="op">*(</span>vector<span class="op">&lt;</span>ET1, OT1<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> v1, S2 <span class="kw">const</span><span class="op">&amp;</span> s2<span class="op">)</span>;</span>
<span id="cb1-124"><a href="#cb1-124"></a> </span>
<span id="cb1-125"><a href="#cb1-125"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> S1, <span class="kw">class</span> ET2, <span class="kw">class</span> OT2<span class="op">&gt;</span></span>
<span id="cb1-126"><a href="#cb1-126"></a><span class="kw">auto</span>    <span class="kw">operator</span> <span class="op">*(</span>S1 <span class="kw">const</span><span class="op">&amp;</span> s1, vector<span class="op">&lt;</span>ET2, OT2<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> v2<span class="op">)</span>;</span>
<span id="cb1-127"><a href="#cb1-127"></a> </span>
<span id="cb1-128"><a href="#cb1-128"></a><span class="co">//- Matrix*Scalar multiplication operators</span></span>
<span id="cb1-129"><a href="#cb1-129"></a><span class="co">//</span></span>
<span id="cb1-130"><a href="#cb1-130"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> ET1, <span class="kw">class</span> OT1, <span class="kw">class</span> S2<span class="op">&gt;</span></span>
<span id="cb1-131"><a href="#cb1-131"></a><span class="kw">auto</span>  <span class="kw">operator</span> <span class="op">*(</span>matrix<span class="op">&lt;</span>ET1, OT1<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> m1, S2 <span class="kw">const</span><span class="op">&amp;</span> s2<span class="op">)</span>;</span>
<span id="cb1-132"><a href="#cb1-132"></a> </span>
<span id="cb1-133"><a href="#cb1-133"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> S1, <span class="kw">class</span> ET2, <span class="kw">class</span> OT2<span class="op">&gt;</span></span>
<span id="cb1-134"><a href="#cb1-134"></a><span class="kw">auto</span>  <span class="kw">operator</span> <span class="op">*(</span>S1 <span class="kw">const</span><span class="op">&amp;</span> s1, matrix<span class="op">&lt;</span>ET2, OT2<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> m2<span class="op">)</span>;</span>
<span id="cb1-135"><a href="#cb1-135"></a></span>
<span id="cb1-136"><a href="#cb1-136"></a><span class="co">//- Vector*Matrix multiplication operator</span></span>
<span id="cb1-137"><a href="#cb1-137"></a><span class="co">//</span></span>
<span id="cb1-138"><a href="#cb1-138"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> ET1, <span class="kw">class</span> OT1, <span class="kw">class</span> ET2, <span class="kw">class</span> OT2<span class="op">&gt;</span></span>
<span id="cb1-139"><a href="#cb1-139"></a><span class="kw">auto</span>  <span class="kw">operator</span> <span class="op">*(</span>vector<span class="op">&lt;</span>ET1, OT1<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> v1, matrix<span class="op">&lt;</span>ET2, OT2<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> m2<span class="op">)</span>;</span>
<span id="cb1-140"><a href="#cb1-140"></a> </span>
<span id="cb1-141"><a href="#cb1-141"></a><span class="co">//- Matrix*Vector multiplication operator</span></span>
<span id="cb1-142"><a href="#cb1-142"></a><span class="co">//</span></span>
<span id="cb1-143"><a href="#cb1-143"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> ET1, <span class="kw">class</span> OT1, <span class="kw">class</span> ET2, <span class="kw">class</span> OT2<span class="op">&gt;</span></span>
<span id="cb1-144"><a href="#cb1-144"></a><span class="kw">auto</span>  <span class="kw">operator</span> <span class="op">*(</span>matrix<span class="op">&lt;</span>ET1, OT1<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> m1, vector<span class="op">&lt;</span>ET2, OT2<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> v2<span class="op">)</span>;</span>
<span id="cb1-145"><a href="#cb1-145"></a></span>
<span id="cb1-146"><a href="#cb1-146"></a><span class="co">//- Vector*Vector multiplication operator</span></span>
<span id="cb1-147"><a href="#cb1-147"></a><span class="co">//</span></span>
<span id="cb1-148"><a href="#cb1-148"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> ET1, <span class="kw">class</span> OT1, <span class="kw">class</span> ET2, <span class="kw">class</span> OT2<span class="op">&gt;</span> </span>
<span id="cb1-149"><a href="#cb1-149"></a><span class="kw">auto</span>  <span class="kw">operator</span> <span class="op">*(</span>vector<span class="op">&lt;</span>ET1, OT1<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> v1, vector<span class="op">&lt;</span>ET2, OT2<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> v2<span class="op">)</span>;</span>
<span id="cb1-150"><a href="#cb1-150"></a></span>
<span id="cb1-151"><a href="#cb1-151"></a><span class="co">//- Matrix*Matrix multiplication operator</span></span>
<span id="cb1-152"><a href="#cb1-152"></a><span class="co">//</span></span>
<span id="cb1-153"><a href="#cb1-153"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> ET1, <span class="kw">class</span> OT1, <span class="kw">class</span> ET2, <span class="kw">class</span> OT2<span class="op">&gt;</span></span>
<span id="cb1-154"><a href="#cb1-154"></a><span class="kw">auto</span>  <span class="kw">operator</span> <span class="op">*(</span>matrix<span class="op">&lt;</span>ET1, OT1<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> m1, matrix<span class="op">&lt;</span>ET2, OT2<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> m2<span class="op">)</span>;</span>
<span id="cb1-155"><a href="#cb1-155"></a></span>
<span id="cb1-156"><a href="#cb1-156"></a><span class="co">//- Convenience aliases for vector and matrix objects based on </span></span>
<span id="cb1-157"><a href="#cb1-157"></a><span class="co">//  dynamically-resizable engines.</span></span>
<span id="cb1-158"><a href="#cb1-158"></a><span class="co">//</span></span>
<span id="cb1-159"><a href="#cb1-159"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T, <span class="kw">class</span> AT <span class="op">=</span> allocator<span class="op">&lt;</span>T<span class="op">&gt;&gt;</span></span>
<span id="cb1-160"><a href="#cb1-160"></a><span class="kw">using</span> dyn_vector <span class="op">=</span> vector<span class="op">&lt;</span>dr_vector_engine<span class="op">&lt;</span>T, AT<span class="op">&gt;</span>, matrix_operation_traits<span class="op">&gt;</span>;</span>
<span id="cb1-161"><a href="#cb1-161"></a> </span>
<span id="cb1-162"><a href="#cb1-162"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T, <span class="kw">class</span> AT <span class="op">=</span> allocator<span class="op">&lt;</span>T<span class="op">&gt;&gt;</span></span>
<span id="cb1-163"><a href="#cb1-163"></a><span class="kw">using</span> dyn_matrix <span class="op">=</span> matrix<span class="op">&lt;</span>dr_matrix_engine<span class="op">&lt;</span>T, AT<span class="op">&gt;</span>, matrix_operation_traits<span class="op">&gt;</span>;</span>
<span id="cb1-164"><a href="#cb1-164"></a> </span>
<span id="cb1-165"><a href="#cb1-165"></a><span class="co">//- Convenience aliases for vector and matrix objects based on fixed-size engines.</span></span>
<span id="cb1-166"><a href="#cb1-166"></a><span class="co">//</span></span>
<span id="cb1-167"><a href="#cb1-167"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T, <span class="dt">int32_t</span> N<span class="op">&gt;</span></span>
<span id="cb1-168"><a href="#cb1-168"></a><span class="kw">using</span> fs_vector <span class="op">=</span> vector<span class="op">&lt;</span>fs_vector_engine<span class="op">&lt;</span>T, N<span class="op">&gt;</span>, matrix_operation_traits<span class="op">&gt;</span>;</span>
<span id="cb1-169"><a href="#cb1-169"></a> </span>
<span id="cb1-170"><a href="#cb1-170"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T, <span class="dt">int32_t</span> R, <span class="dt">int32_t</span> C<span class="op">&gt;</span></span>
<span id="cb1-171"><a href="#cb1-171"></a><span class="kw">using</span> fs_matrix <span class="op">=</span> matrix<span class="op">&lt;</span>fs_matrix_engine<span class="op">&lt;</span>T, R, C<span class="op">&gt;</span>, matrix_operation_traits<span class="op">&gt;</span>;</span>
<span id="cb1-172"><a href="#cb1-172"></a></span>
<span id="cb1-173"><a href="#cb1-173"></a><span class="op">}</span></span></code></pre></div>
<h2 id="numeric-traits"><span class="header-section-number">6.4</span> Numeric traits<a href="#numeric-traits" class="self-link"></a></h2>
<h3 id="number_traitst"><span class="header-section-number">6.4.1</span> <code>number_traits&lt;T&gt;</code><a href="#number_traitst" class="self-link"></a></h3>
<p>Traits type <code>number_traits&lt;T&gt;</code> specifies certain properties of numeric types. It is a customization point intended to be specialized by the user when a new user-defined type is to be used with the library.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="kw">struct</span> number_traits</span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="op">{</span></span>
<span id="cb2-4"><a href="#cb2-4"></a>    <span class="kw">using</span> is_field     <span class="op">=</span> <span class="op">...</span>;   <span class="co">//- Implementation-defined</span></span>
<span id="cb2-5"><a href="#cb2-5"></a>    <span class="kw">using</span> is_nc_ring   <span class="op">=</span> <span class="op">...</span>;   <span class="co">//- Implementation-defined</span></span>
<span id="cb2-6"><a href="#cb2-6"></a>    <span class="kw">using</span> is_ring      <span class="op">=</span> <span class="op">...</span>;   <span class="co">//- Implementation-defined</span></span>
<span id="cb2-7"><a href="#cb2-7"></a><span class="op">}</span>;</span>
<span id="cb2-8"><a href="#cb2-8"></a></span>
<span id="cb2-9"><a href="#cb2-9"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span></span>
<span id="cb2-10"><a href="#cb2-10"></a><span class="kw">struct</span> number_traits<span class="op">&lt;</span>complex<span class="op">&lt;</span>T<span class="op">&gt;&gt;</span> <span class="op">:</span> <span class="kw">public</span> number_traits<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">{}</span>;</span></code></pre></div>
<h3 id="is_complext"><span class="header-section-number">6.4.2</span> <code>is_complex&lt;T&gt;</code><a href="#is_complext" class="self-link"></a></h3>
<p>Traits type <code>is_complex&lt;T&gt;</code> indicates whether its template paramater <code>T</code> is of type <code>std::complex&lt;V&gt;</code> for some (presumably) numeric type <code>V</code>. A possible implementation might be:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span></span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="kw">struct</span> is_complex <span class="op">:</span> <span class="kw">public</span> false_type</span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="op">{}</span>;</span>
<span id="cb3-4"><a href="#cb3-4"></a></span>
<span id="cb3-5"><a href="#cb3-5"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span></span>
<span id="cb3-6"><a href="#cb3-6"></a><span class="kw">struct</span> is_complex<span class="op">&lt;</span>complex<span class="op">&lt;</span>T<span class="op">&gt;&gt;</span> <span class="op">:</span> <span class="kw">public</span> true_type</span>
<span id="cb3-7"><a href="#cb3-7"></a><span class="op">{}</span>;</span></code></pre></div>
<h3 id="is_fieldt"><span class="header-section-number">6.4.3</span> <code>is_field&lt;T&gt;</code><a href="#is_fieldt" class="self-link"></a></h3>
<p>Traits <code>is_field&lt;T&gt;</code> type indicates whether its template parameter <code>T</code> is a type that attemptys to model a mathematical field. This proposal expects that <code>is_field</code> is implemented in terms of <code>number_traits</code>, perhaps as follows:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span></span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="kw">struct</span> is_field <span class="op">:</span> <span class="kw">public</span> number_traits<span class="op">&lt;</span>T<span class="op">&gt;::</span>is_field</span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="op">{}</span>;</span></code></pre></div>
<h3 id="is_ringt"><span class="header-section-number">6.4.4</span> <code>is_ring&lt;T&gt;</code><a href="#is_ringt" class="self-link"></a></h3>
<p>Traits type <code>is_ring&lt;T&gt;</code> indicates whether its template paremater <code>T</code> is a type that models a mathematical ring. This proposal expects that <code>is_ring</code> is implemented in terms of <code>number_traits</code>, perhaps as follows:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span></span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="kw">struct</span> is_ring <span class="op">:</span> <span class="kw">public</span> number_traits<span class="op">&lt;</span>T<span class="op">&gt;::</span>is_ring</span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="op">{}</span>;</span></code></pre></div>
<h3 id="is_nc_ringt"><span class="header-section-number">6.4.5</span> <code>is_nc_ring&lt;T&gt;</code><a href="#is_nc_ringt" class="self-link"></a></h3>
<p>Traits type <code>is_nc_ring&lt;T&gt;</code> indicates whether its template parameter <code>T</code> is a type that models a non-commutative ring. This proposal expects that <code>is_nc_ring</code> is implemented in terms of <code>number_traits</code>, perhaps as follows:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span></span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="kw">struct</span> is_nc_ring <span class="op">:</span> <span class="kw">public</span> number_traits<span class="op">&lt;</span>T<span class="op">&gt;::</span>is_nc_ring</span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="op">{}</span>;</span></code></pre></div>
<h3 id="is_matrix_elementt"><span class="header-section-number">6.4.6</span> <code>is_matrix_element&lt;T&gt;</code><a href="#is_matrix_elementt" class="self-link"></a></h3>
<p>Traits type <code>is_matrix_element&lt;T&gt;</code> indicates whether its template parameter <code>T</code> is a type that is suitable as matrix element type.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span> <span class="kw">struct</span> is_matrix_element;</span></code></pre></div>
<p>The purpose of this type is to constrain the set of element types used to instantiate a <em>MathObj</em> to those types which fulfill at least the requirements of non-commutative rings. For now, the constraint is imposed via static assertion; we expect this to change as experience with concepts is gained and appropriate concepts are developed and integrated into the library.</p>
<h2 id="engine-types"><span class="header-section-number">6.5</span> Engine Types<a href="#engine-types" class="self-link"></a></h2>
<p>The over-arching purpose of the engine types is to perform resource management on behalf of an associated, owning <em>MathObj</em> instance. At a minimum, all of the engine types provide a basic interface for const element indexing, determining row and column sizes, and determining row and column capacities. They also export public type aliases which specify their element type, whether or not they are dense, whether or not they are rectangular, whether or not they are resizable, whether or not their memory layout is row-major, and a 2-tuple for describing sizes and capacities.</p>
<p>It is important to note that an engine’s resource management duties are primarily related to storage. To that end, an engine may own the storage it manages and control its lifetime, or it may be non-owning and represent a view of storage owned by some other object.</p>
<p>One can also imagine engines that manage resources related to execution. This is an area of ongoing work and not yet addressed in this proposal.</p>
<h3 id="matrix_column_viewet"><span class="header-section-number">6.5.1</span> <code>matrix_column_view&lt;ET&gt;</code><a href="#matrix_column_viewet" class="self-link"></a></h3>
<p>Class template <code>matrix_column_view&lt;ET&gt;</code> implements an engine that is a non-owning, const view type implementing the basic vector engine interface.<br />
Its purpose is to provide a view of single column of a <code>matrix</code> object.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> ET<span class="op">&gt;</span></span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="kw">class</span> matrix_column_view</span>
<span id="cb8-3"><a href="#cb8-3"></a><span class="op">{</span></span>
<span id="cb8-4"><a href="#cb8-4"></a>  <span class="kw">public</span><span class="op">:</span></span>
<span id="cb8-5"><a href="#cb8-5"></a>    <span class="kw">using</span> engine_type     <span class="op">=</span> ET;</span>
<span id="cb8-6"><a href="#cb8-6"></a>    <span class="kw">using</span> engine_category <span class="op">=</span> const_vector_engine_tag;</span>
<span id="cb8-7"><a href="#cb8-7"></a>    <span class="kw">using</span> element_type    <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>element_type;</span>
<span id="cb8-8"><a href="#cb8-8"></a>    <span class="kw">using</span> value_type      <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>value_type;</span>
<span id="cb8-9"><a href="#cb8-9"></a>    <span class="kw">using</span> reference       <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>const_reference;</span>
<span id="cb8-10"><a href="#cb8-10"></a>    <span class="kw">using</span> pointer         <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>const_pointer;</span>
<span id="cb8-11"><a href="#cb8-11"></a>    <span class="kw">using</span> const_reference <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>const_reference;</span>
<span id="cb8-12"><a href="#cb8-12"></a>    <span class="kw">using</span> const_pointer   <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>const_pointer;</span>
<span id="cb8-13"><a href="#cb8-13"></a>    <span class="kw">using</span> iterator        <span class="op">=</span> <span class="op">...</span>;                <span class="co">//- Implementation-defined</span></span>
<span id="cb8-14"><a href="#cb8-14"></a>    <span class="kw">using</span> const_iterator  <span class="op">=</span> <span class="op">...</span>;                <span class="co">//- Implementation-defined</span></span>
<span id="cb8-15"><a href="#cb8-15"></a>    <span class="kw">using</span> difference_type <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>difference_type;</span>
<span id="cb8-16"><a href="#cb8-16"></a>    <span class="kw">using</span> index_type      <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>index_type;</span>
<span id="cb8-17"><a href="#cb8-17"></a>    <span class="kw">using</span> size_type       <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>size_type;</span>
<span id="cb8-18"><a href="#cb8-18"></a></span>
<span id="cb8-19"><a href="#cb8-19"></a>    <span class="kw">using</span> is_fixed_size   <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>is_fixed_size;</span>
<span id="cb8-20"><a href="#cb8-20"></a>    <span class="kw">using</span> is_resizable    <span class="op">=</span> false_type;</span>
<span id="cb8-21"><a href="#cb8-21"></a></span>
<span id="cb8-22"><a href="#cb8-22"></a>    <span class="kw">using</span> is_column_major <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>is_row_major;</span>
<span id="cb8-23"><a href="#cb8-23"></a>    <span class="kw">using</span> is_dense        <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>is_dense;</span>
<span id="cb8-24"><a href="#cb8-24"></a>    <span class="kw">using</span> is_rectangular  <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>is_rectangular;</span>
<span id="cb8-25"><a href="#cb8-25"></a>    <span class="kw">using</span> is_row_major    <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>is_column_major;</span>
<span id="cb8-26"><a href="#cb8-26"></a></span>
<span id="cb8-27"><a href="#cb8-27"></a>  <span class="kw">public</span><span class="op">:</span></span>
<span id="cb8-28"><a href="#cb8-28"></a>    <span class="kw">constexpr</span> matrix_column_view<span class="op">()</span>;</span>
<span id="cb8-29"><a href="#cb8-29"></a>    <span class="kw">constexpr</span> matrix_column_view<span class="op">(</span>engine_type <span class="kw">const</span><span class="op">&amp;</span> eng, index_type col<span class="op">)</span>;</span>
<span id="cb8-30"><a href="#cb8-30"></a>    <span class="kw">constexpr</span> matrix_column_view<span class="op">(</span>matrix_column_view<span class="op">&amp;&amp;)</span> <span class="kw">noexcept</span> <span class="op">=</span> <span class="cf">default</span>;</span>
<span id="cb8-31"><a href="#cb8-31"></a>    <span class="kw">constexpr</span> matrix_column_view<span class="op">(</span>matrix_column_view <span class="kw">const</span><span class="op">&amp;)</span> <span class="op">=</span> <span class="cf">default</span>;</span>
<span id="cb8-32"><a href="#cb8-32"></a></span>
<span id="cb8-33"><a href="#cb8-33"></a>    <span class="kw">constexpr</span> matrix_column_view<span class="op">&amp;</span>   <span class="kw">operator</span> <span class="op">=(</span>matrix_column_view<span class="op">&amp;&amp;)</span> <span class="kw">noexcept</span> <span class="op">=</span> <span class="cf">default</span>;</span>
<span id="cb8-34"><a href="#cb8-34"></a>    <span class="kw">constexpr</span> matrix_column_view<span class="op">&amp;</span>   <span class="kw">operator</span> <span class="op">=(</span>matrix_column_view <span class="kw">const</span><span class="op">&amp;)</span> <span class="op">=</span> <span class="cf">default</span>;</span>
<span id="cb8-35"><a href="#cb8-35"></a></span>
<span id="cb8-36"><a href="#cb8-36"></a>    <span class="kw">constexpr</span> const_reference   <span class="kw">operator</span> <span class="op">()(</span>index_type i<span class="op">)</span> <span class="kw">const</span>;</span>
<span id="cb8-37"><a href="#cb8-37"></a>    <span class="kw">constexpr</span> const_iterator    begin<span class="op">()</span> <span class="kw">const</span> <span class="kw">noexcept</span>;</span>
<span id="cb8-38"><a href="#cb8-38"></a>    <span class="kw">constexpr</span> const_iterator    end<span class="op">()</span> <span class="kw">const</span> <span class="kw">noexcept</span>;</span>
<span id="cb8-39"><a href="#cb8-39"></a>    <span class="kw">constexpr</span> size_type         capacity<span class="op">()</span> <span class="kw">const</span> <span class="kw">noexcept</span>;</span>
<span id="cb8-40"><a href="#cb8-40"></a>    <span class="kw">constexpr</span> size_type         elements<span class="op">()</span> <span class="kw">const</span> <span class="kw">noexcept</span>;</span>
<span id="cb8-41"><a href="#cb8-41"></a></span>
<span id="cb8-42"><a href="#cb8-42"></a>    <span class="kw">constexpr</span> <span class="dt">void</span>      assign<span class="op">(</span>matrix_column_view <span class="kw">const</span><span class="op">&amp;</span> rhs<span class="op">)</span>;</span>
<span id="cb8-43"><a href="#cb8-43"></a><span class="op">}</span>;</span></code></pre></div>
<h3 id="matrix_row_viewet"><span class="header-section-number">6.5.2</span> <code>matrix_row_view&lt;ET&gt;</code><a href="#matrix_row_viewet" class="self-link"></a></h3>
<p>Class template <code>matrix_row_view&lt;ET&gt;</code> implements an engine that is a non-owning, const view type implementing the basic vector engine interface.<br />
Its purpose is to provide a view of single row of a <code>matrix</code> object.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> ET<span class="op">&gt;</span></span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="kw">class</span> matrix_row_view</span>
<span id="cb9-3"><a href="#cb9-3"></a><span class="op">{</span></span>
<span id="cb9-4"><a href="#cb9-4"></a>  <span class="kw">public</span><span class="op">:</span></span>
<span id="cb9-5"><a href="#cb9-5"></a>    <span class="kw">using</span> engine_type     <span class="op">=</span> ET;</span>
<span id="cb9-6"><a href="#cb9-6"></a>    <span class="kw">using</span> engine_category <span class="op">=</span> const_vector_engine_tag;</span>
<span id="cb9-7"><a href="#cb9-7"></a>    <span class="kw">using</span> element_type    <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>element_type;</span>
<span id="cb9-8"><a href="#cb9-8"></a>    <span class="kw">using</span> value_type      <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>value_type;</span>
<span id="cb9-9"><a href="#cb9-9"></a>    <span class="kw">using</span> reference       <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>const_reference;</span>
<span id="cb9-10"><a href="#cb9-10"></a>    <span class="kw">using</span> pointer         <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>const_pointer;</span>
<span id="cb9-11"><a href="#cb9-11"></a>    <span class="kw">using</span> const_reference <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>const_reference;</span>
<span id="cb9-12"><a href="#cb9-12"></a>    <span class="kw">using</span> const_pointer   <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>const_pointer;</span>
<span id="cb9-13"><a href="#cb9-13"></a>    <span class="kw">using</span> iterator        <span class="op">=</span> <span class="op">...</span>;                <span class="co">//- Implementation-defined</span></span>
<span id="cb9-14"><a href="#cb9-14"></a>    <span class="kw">using</span> const_iterator  <span class="op">=</span> <span class="op">...</span>;                <span class="co">//- Implementation-defined</span></span>
<span id="cb9-15"><a href="#cb9-15"></a>    <span class="kw">using</span> difference_type <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>difference_type;</span>
<span id="cb9-16"><a href="#cb9-16"></a>    <span class="kw">using</span> index_type      <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>index_type;</span>
<span id="cb9-17"><a href="#cb9-17"></a>    <span class="kw">using</span> size_type       <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>size_type;</span>
<span id="cb9-18"><a href="#cb9-18"></a></span>
<span id="cb9-19"><a href="#cb9-19"></a>    <span class="kw">using</span> is_fixed_size   <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>is_fixed_size;</span>
<span id="cb9-20"><a href="#cb9-20"></a>    <span class="kw">using</span> is_resizable    <span class="op">=</span> false_type;</span>
<span id="cb9-21"><a href="#cb9-21"></a></span>
<span id="cb9-22"><a href="#cb9-22"></a>    <span class="kw">using</span> is_column_major <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>is_row_major;</span>
<span id="cb9-23"><a href="#cb9-23"></a>    <span class="kw">using</span> is_dense        <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>is_dense;</span>
<span id="cb9-24"><a href="#cb9-24"></a>    <span class="kw">using</span> is_rectangular  <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>is_rectangular;</span>
<span id="cb9-25"><a href="#cb9-25"></a>    <span class="kw">using</span> is_row_major    <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>is_column_major;</span>
<span id="cb9-26"><a href="#cb9-26"></a></span>
<span id="cb9-27"><a href="#cb9-27"></a>  <span class="kw">public</span><span class="op">:</span></span>
<span id="cb9-28"><a href="#cb9-28"></a>    <span class="kw">constexpr</span> matrix_row_view<span class="op">()</span>;</span>
<span id="cb9-29"><a href="#cb9-29"></a>    <span class="kw">constexpr</span> matrix_row_view<span class="op">(</span>engine_type <span class="kw">const</span><span class="op">&amp;</span> eng, index_type row<span class="op">)</span>;</span>
<span id="cb9-30"><a href="#cb9-30"></a>    <span class="kw">constexpr</span> matrix_row_view<span class="op">(</span>matrix_row_view<span class="op">&amp;&amp;)</span> <span class="kw">noexcept</span> <span class="op">=</span> <span class="cf">default</span>;</span>
<span id="cb9-31"><a href="#cb9-31"></a>    <span class="kw">constexpr</span> matrix_row_view<span class="op">(</span>matrix_row_view <span class="kw">const</span><span class="op">&amp;)</span> <span class="op">=</span> <span class="cf">default</span>;</span>
<span id="cb9-32"><a href="#cb9-32"></a></span>
<span id="cb9-33"><a href="#cb9-33"></a>    <span class="kw">constexpr</span> matrix_row_view<span class="op">&amp;</span>  <span class="kw">operator</span> <span class="op">=(</span>matrix_row_view<span class="op">&amp;&amp;)</span> <span class="kw">noexcept</span> <span class="op">=</span> <span class="cf">default</span>;</span>
<span id="cb9-34"><a href="#cb9-34"></a>    <span class="kw">constexpr</span> matrix_row_view<span class="op">&amp;</span>  <span class="kw">operator</span> <span class="op">=(</span>matrix_row_view <span class="kw">const</span><span class="op">&amp;)</span> <span class="op">=</span> <span class="cf">default</span>;</span>
<span id="cb9-35"><a href="#cb9-35"></a></span>
<span id="cb9-36"><a href="#cb9-36"></a>    <span class="kw">constexpr</span> const_reference   <span class="kw">operator</span> <span class="op">()(</span>index_type j<span class="op">)</span> <span class="kw">const</span>;</span>
<span id="cb9-37"><a href="#cb9-37"></a>    <span class="kw">constexpr</span> const_iterator    begin<span class="op">()</span> <span class="kw">const</span> <span class="kw">noexcept</span>;</span>
<span id="cb9-38"><a href="#cb9-38"></a>    <span class="kw">constexpr</span> const_iterator    end<span class="op">()</span> <span class="kw">const</span> <span class="kw">noexcept</span>;</span>
<span id="cb9-39"><a href="#cb9-39"></a>    <span class="kw">constexpr</span> size_type         capacity<span class="op">()</span> <span class="kw">const</span> <span class="kw">noexcept</span>;</span>
<span id="cb9-40"><a href="#cb9-40"></a>    <span class="kw">constexpr</span> size_type         elements<span class="op">()</span> <span class="kw">const</span> <span class="kw">noexcept</span>;</span>
<span id="cb9-41"><a href="#cb9-41"></a></span>
<span id="cb9-42"><a href="#cb9-42"></a>    <span class="kw">constexpr</span> <span class="dt">void</span>      assign<span class="op">(</span>matrix_row_view <span class="kw">const</span><span class="op">&amp;</span> rhs<span class="op">)</span>;</span>
<span id="cb9-43"><a href="#cb9-43"></a><span class="op">}</span>;</span></code></pre></div>
<h3 id="matrix_transpose_viewet"><span class="header-section-number">6.5.3</span> <code>matrix_transpose_view&lt;ET&gt;</code><a href="#matrix_transpose_viewet" class="self-link"></a></h3>
<p>Class template <code>matrix_transpose_view&lt;ET&gt;</code> implements an engine that is a non-owning, const view type implementing the basic matrix engine interface.<br />
Its purpose is to provide a view of a <code>matrix</code> object that is the transpose of the <code>matrix</code>.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> ET<span class="op">&gt;</span></span>
<span id="cb10-2"><a href="#cb10-2"></a><span class="kw">class</span> matrix_transpose_view</span>
<span id="cb10-3"><a href="#cb10-3"></a><span class="op">{</span></span>
<span id="cb10-4"><a href="#cb10-4"></a>  <span class="kw">public</span><span class="op">:</span></span>
<span id="cb10-5"><a href="#cb10-5"></a>    <span class="kw">using</span> engine_type     <span class="op">=</span> ET;</span>
<span id="cb10-6"><a href="#cb10-6"></a>    <span class="kw">using</span> engine_category <span class="op">=</span> const_matrix_engine_tag;</span>
<span id="cb10-7"><a href="#cb10-7"></a>    <span class="kw">using</span> element_type    <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>element_type;</span>
<span id="cb10-8"><a href="#cb10-8"></a>    <span class="kw">using</span> value_type      <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>value_type;</span>
<span id="cb10-9"><a href="#cb10-9"></a>    <span class="kw">using</span> reference       <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>const_reference;</span>
<span id="cb10-10"><a href="#cb10-10"></a>    <span class="kw">using</span> pointer         <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>const_pointer;</span>
<span id="cb10-11"><a href="#cb10-11"></a>    <span class="kw">using</span> const_reference <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>const_reference;</span>
<span id="cb10-12"><a href="#cb10-12"></a>    <span class="kw">using</span> const_pointer   <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>const_pointer;</span>
<span id="cb10-13"><a href="#cb10-13"></a>    <span class="kw">using</span> difference_type <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>difference_type;</span>
<span id="cb10-14"><a href="#cb10-14"></a>    <span class="kw">using</span> index_type      <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>index_type;</span>
<span id="cb10-15"><a href="#cb10-15"></a>    <span class="kw">using</span> size_type       <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>size_type;</span>
<span id="cb10-16"><a href="#cb10-16"></a>    <span class="kw">using</span> size_tuple      <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>size_tuple;</span>
<span id="cb10-17"><a href="#cb10-17"></a></span>
<span id="cb10-18"><a href="#cb10-18"></a>    <span class="kw">using</span> is_fixed_size   <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>is_fixed_size;</span>
<span id="cb10-19"><a href="#cb10-19"></a>    <span class="kw">using</span> is_resizable    <span class="op">=</span> false_type;</span>
<span id="cb10-20"><a href="#cb10-20"></a></span>
<span id="cb10-21"><a href="#cb10-21"></a>    <span class="kw">using</span> is_column_major <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>is_row_major;</span>
<span id="cb10-22"><a href="#cb10-22"></a>    <span class="kw">using</span> is_dense        <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>is_dense;</span>
<span id="cb10-23"><a href="#cb10-23"></a>    <span class="kw">using</span> is_rectangular  <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>is_rectangular;</span>
<span id="cb10-24"><a href="#cb10-24"></a>    <span class="kw">using</span> is_row_major    <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>is_column_major;</span>
<span id="cb10-25"><a href="#cb10-25"></a></span>
<span id="cb10-26"><a href="#cb10-26"></a>    <span class="kw">using</span> column_view_type    <span class="op">=</span> matrix_column_view<span class="op">&lt;</span>matrix_transpose_view<span class="op">&gt;</span>;</span>
<span id="cb10-27"><a href="#cb10-27"></a>    <span class="kw">using</span> row_view_type       <span class="op">=</span> matrix_row_view<span class="op">&lt;</span>matrix_transpose_view<span class="op">&gt;</span>;</span>
<span id="cb10-28"><a href="#cb10-28"></a>    <span class="kw">using</span> transpose_view_type <span class="op">=</span> matrix_transpose_view<span class="op">&lt;</span>matrix_transpose_view<span class="op">&gt;</span>;</span>
<span id="cb10-29"><a href="#cb10-29"></a></span>
<span id="cb10-30"><a href="#cb10-30"></a>  <span class="kw">public</span><span class="op">:</span></span>
<span id="cb10-31"><a href="#cb10-31"></a>    <span class="kw">constexpr</span> matrix_transpose_view<span class="op">()</span>;</span>
<span id="cb10-32"><a href="#cb10-32"></a>    <span class="kw">constexpr</span> matrix_transpose_view<span class="op">(</span>engine_type <span class="kw">const</span><span class="op">&amp;</span> eng<span class="op">)</span>;</span>
<span id="cb10-33"><a href="#cb10-33"></a>    <span class="kw">constexpr</span> matrix_transpose_view<span class="op">(</span>matrix_transpose_view<span class="op">&amp;&amp;)</span> <span class="kw">noexcept</span> <span class="op">=</span> <span class="cf">default</span>;</span>
<span id="cb10-34"><a href="#cb10-34"></a>    <span class="kw">constexpr</span> matrix_transpose_view<span class="op">(</span>matrix_transpose_view <span class="kw">const</span><span class="op">&amp;)</span> <span class="op">=</span> <span class="cf">default</span>;</span>
<span id="cb10-35"><a href="#cb10-35"></a></span>
<span id="cb10-36"><a href="#cb10-36"></a>    <span class="kw">constexpr</span> matrix_transpose_view<span class="op">&amp;</span> <span class="kw">operator</span> <span class="op">=(</span>matrix_transpose_view<span class="op">&amp;&amp;)</span> <span class="kw">noexcept</span> <span class="op">=</span> <span class="cf">default</span>;</span>
<span id="cb10-37"><a href="#cb10-37"></a>    <span class="kw">constexpr</span> matrix_transpose_view<span class="op">&amp;</span> <span class="kw">operator</span> <span class="op">=(</span>matrix_transpose_view <span class="kw">const</span><span class="op">&amp;)</span> <span class="op">=</span> <span class="cf">default</span>;</span>
<span id="cb10-38"><a href="#cb10-38"></a></span>
<span id="cb10-39"><a href="#cb10-39"></a>    <span class="kw">constexpr</span> const_reference   <span class="kw">operator</span> <span class="op">()(</span>index_type i, index_type j<span class="op">)</span> <span class="kw">const</span>;</span>
<span id="cb10-40"><a href="#cb10-40"></a></span>
<span id="cb10-41"><a href="#cb10-41"></a>    <span class="kw">constexpr</span> size_type     columns<span class="op">()</span> <span class="kw">const</span> <span class="kw">noexcept</span>;</span>
<span id="cb10-42"><a href="#cb10-42"></a>    <span class="kw">constexpr</span> size_type     rows<span class="op">()</span> <span class="kw">const</span> <span class="kw">noexcept</span>;</span>
<span id="cb10-43"><a href="#cb10-43"></a>    <span class="kw">constexpr</span> size_tuple    size<span class="op">()</span> <span class="kw">const</span> <span class="kw">noexcept</span>;</span>
<span id="cb10-44"><a href="#cb10-44"></a></span>
<span id="cb10-45"><a href="#cb10-45"></a>    <span class="kw">constexpr</span> size_type     column_capacity<span class="op">()</span> <span class="kw">const</span> <span class="kw">noexcept</span>;</span>
<span id="cb10-46"><a href="#cb10-46"></a>    <span class="kw">constexpr</span> size_type     row_capacity<span class="op">()</span> <span class="kw">const</span> <span class="kw">noexcept</span>;</span>
<span id="cb10-47"><a href="#cb10-47"></a>    <span class="kw">constexpr</span> size_tuple    capacity<span class="op">()</span> <span class="kw">const</span> <span class="kw">noexcept</span>;</span>
<span id="cb10-48"><a href="#cb10-48"></a></span>
<span id="cb10-49"><a href="#cb10-49"></a>    <span class="kw">constexpr</span> <span class="dt">void</span>  assign<span class="op">(</span>matrix_transpose_view <span class="kw">const</span><span class="op">&amp;</span> rhs<span class="op">)</span>;</span>
<span id="cb10-50"><a href="#cb10-50"></a><span class="op">}</span>;</span></code></pre></div>
<h3 id="fs_vector_enginet-n"><span class="header-section-number">6.5.4</span> <code>fs_vector_engine&lt;T, N&gt;</code><a href="#fs_vector_enginet-n" class="self-link"></a></h3>
<p>Class template <code>fs_vector_engine&lt;T, N&gt;</code> implements a fixed-size, fixed-capacity engine for vectors having <code>N</code> elements. In addition to the basic vector engine interface, it provides member functions for mutable element indexing, swapping engine contents, and swapping individual elements.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T, <span class="dt">int32_t</span> N<span class="op">&gt;</span></span>
<span id="cb11-2"><a href="#cb11-2"></a><span class="kw">class</span> fs_vector_engine</span>
<span id="cb11-3"><a href="#cb11-3"></a><span class="op">{</span></span>
<span id="cb11-4"><a href="#cb11-4"></a>  <span class="kw">public</span><span class="op">:</span></span>
<span id="cb11-5"><a href="#cb11-5"></a>    <span class="kw">using</span> engine_category <span class="op">=</span> mutable_vector_engine_tag;</span>
<span id="cb11-6"><a href="#cb11-6"></a>    <span class="kw">using</span> element_type    <span class="op">=</span> T;</span>
<span id="cb11-7"><a href="#cb11-7"></a>    <span class="kw">using</span> value_type      <span class="op">=</span> T;</span>
<span id="cb11-8"><a href="#cb11-8"></a>    <span class="kw">using</span> reference       <span class="op">=</span> T<span class="op">&amp;</span>;</span>
<span id="cb11-9"><a href="#cb11-9"></a>    <span class="kw">using</span> pointer         <span class="op">=</span> T<span class="op">*</span>;</span>
<span id="cb11-10"><a href="#cb11-10"></a>    <span class="kw">using</span> const_reference <span class="op">=</span> T <span class="kw">const</span><span class="op">&amp;</span>;</span>
<span id="cb11-11"><a href="#cb11-11"></a>    <span class="kw">using</span> const_pointer   <span class="op">=</span> T <span class="kw">const</span><span class="op">*</span>;</span>
<span id="cb11-12"><a href="#cb11-12"></a>    <span class="kw">using</span> iterator        <span class="op">=</span> <span class="op">...</span>;                <span class="co">//- Implementation-defined</span></span>
<span id="cb11-13"><a href="#cb11-13"></a>    <span class="kw">using</span> const_iterator  <span class="op">=</span> <span class="op">...</span>;                <span class="co">//- Implementation-defined</span></span>
<span id="cb11-14"><a href="#cb11-14"></a>    <span class="kw">using</span> difference_type <span class="op">=</span> <span class="dt">ptrdiff_t</span>;</span>
<span id="cb11-15"><a href="#cb11-15"></a>    <span class="kw">using</span> index_type      <span class="op">=</span> <span class="dt">int_fast32_t</span>;</span>
<span id="cb11-16"><a href="#cb11-16"></a>    <span class="kw">using</span> size_type       <span class="op">=</span> <span class="dt">int_fast32_t</span>;</span>
<span id="cb11-17"><a href="#cb11-17"></a></span>
<span id="cb11-18"><a href="#cb11-18"></a>    <span class="kw">using</span> is_fixed_size   <span class="op">=</span> true_type;</span>
<span id="cb11-19"><a href="#cb11-19"></a>    <span class="kw">using</span> is_resizable    <span class="op">=</span> false_type;</span>
<span id="cb11-20"><a href="#cb11-20"></a></span>
<span id="cb11-21"><a href="#cb11-21"></a>    <span class="kw">using</span> is_column_major <span class="op">=</span> true_type;</span>
<span id="cb11-22"><a href="#cb11-22"></a>    <span class="kw">using</span> is_dense        <span class="op">=</span> true_type;</span>
<span id="cb11-23"><a href="#cb11-23"></a>    <span class="kw">using</span> is_rectangular  <span class="op">=</span> true_type;</span>
<span id="cb11-24"><a href="#cb11-24"></a>    <span class="kw">using</span> is_row_major    <span class="op">=</span> true_type;</span>
<span id="cb11-25"><a href="#cb11-25"></a></span>
<span id="cb11-26"><a href="#cb11-26"></a>  <span class="kw">public</span><span class="op">:</span></span>
<span id="cb11-27"><a href="#cb11-27"></a>    <span class="kw">constexpr</span> fs_vector_engine<span class="op">()</span>;</span>
<span id="cb11-28"><a href="#cb11-28"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> U<span class="op">&gt;</span></span>
<span id="cb11-29"><a href="#cb11-29"></a>    <span class="kw">constexpr</span> fs_vector_engine<span class="op">(</span>initializer_list<span class="op">&lt;</span>U<span class="op">&gt;</span> list<span class="op">)</span>;</span>
<span id="cb11-30"><a href="#cb11-30"></a>    <span class="kw">constexpr</span> fs_vector_engine<span class="op">(</span>fs_vector_engine<span class="op">&amp;&amp;)</span> <span class="kw">noexcept</span> <span class="op">=</span> <span class="cf">default</span>;</span>
<span id="cb11-31"><a href="#cb11-31"></a>    <span class="kw">constexpr</span> fs_vector_engine<span class="op">(</span>fs_vector_engine <span class="kw">const</span><span class="op">&amp;)</span> <span class="op">=</span> <span class="cf">default</span>;</span>
<span id="cb11-32"><a href="#cb11-32"></a></span>
<span id="cb11-33"><a href="#cb11-33"></a>    <span class="kw">constexpr</span> fs_vector_engine<span class="op">&amp;</span>     <span class="kw">operator</span> <span class="op">=(</span>fs_vector_engine<span class="op">&amp;&amp;)</span> <span class="kw">noexcept</span> <span class="op">=</span> <span class="cf">default</span>;</span>
<span id="cb11-34"><a href="#cb11-34"></a>    <span class="kw">constexpr</span> fs_vector_engine<span class="op">&amp;</span>     <span class="kw">operator</span> <span class="op">=(</span>fs_vector_engine <span class="kw">const</span><span class="op">&amp;)</span> <span class="op">=</span> <span class="cf">default</span>;</span>
<span id="cb11-35"><a href="#cb11-35"></a></span>
<span id="cb11-36"><a href="#cb11-36"></a>    <span class="kw">constexpr</span> const_reference   <span class="kw">operator</span> <span class="op">()(</span>index_type i<span class="op">)</span> <span class="kw">const</span>;</span>
<span id="cb11-37"><a href="#cb11-37"></a>    <span class="kw">constexpr</span> const_iterator    begin<span class="op">()</span> <span class="kw">const</span> <span class="kw">noexcept</span>;</span>
<span id="cb11-38"><a href="#cb11-38"></a>    <span class="kw">constexpr</span> const_iterator    end<span class="op">()</span> <span class="kw">const</span> <span class="kw">noexcept</span>;</span>
<span id="cb11-39"><a href="#cb11-39"></a></span>
<span id="cb11-40"><a href="#cb11-40"></a>    <span class="kw">constexpr</span> size_type     capacity<span class="op">()</span> <span class="kw">const</span> <span class="kw">noexcept</span>;</span>
<span id="cb11-41"><a href="#cb11-41"></a>    <span class="kw">constexpr</span> index_type    elements<span class="op">()</span> <span class="kw">const</span> <span class="kw">noexcept</span>;</span>
<span id="cb11-42"><a href="#cb11-42"></a>    <span class="kw">constexpr</span> size_type     size<span class="op">()</span> <span class="kw">const</span> <span class="kw">noexcept</span>;</span>
<span id="cb11-43"><a href="#cb11-43"></a></span>
<span id="cb11-44"><a href="#cb11-44"></a>    <span class="kw">constexpr</span> reference     <span class="kw">operator</span> <span class="op">()(</span>index_type i<span class="op">)</span>;</span>
<span id="cb11-45"><a href="#cb11-45"></a>    <span class="kw">constexpr</span> iterator      begin<span class="op">()</span> <span class="kw">noexcept</span>;</span>
<span id="cb11-46"><a href="#cb11-46"></a>    <span class="kw">constexpr</span> iterator      end<span class="op">()</span> <span class="kw">noexcept</span>;</span>
<span id="cb11-47"><a href="#cb11-47"></a></span>
<span id="cb11-48"><a href="#cb11-48"></a>    <span class="kw">constexpr</span> <span class="dt">void</span>  swap<span class="op">(</span>fs_vector_engine<span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">noexcept</span>;</span>
<span id="cb11-49"><a href="#cb11-49"></a>    <span class="kw">constexpr</span> <span class="dt">void</span>  swap_elements<span class="op">(</span>index_type i, index_type j<span class="op">)</span> <span class="kw">noexcept</span>;</span>
<span id="cb11-50"><a href="#cb11-50"></a><span class="op">}</span>;</span></code></pre></div>
<h3 id="fs_matrix_enginet-r-c"><span class="header-section-number">6.5.5</span> <code>fs_matrix_engine&lt;T, R, C&gt;</code><a href="#fs_matrix_enginet-r-c" class="self-link"></a></h3>
<p>Class template <code>fs_matrix_engine&lt;T, R, C&gt;</code> implements a fixed-size, fixed-capacity engine for matrices having <code>R</code> rows and <code>C</code> columns. In addition to the basic engine interface, it provides member functions for mutable element indexing, swapping engine contents, swapping columns, and swapping rows.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T, <span class="dt">size_t</span> R, <span class="dt">size_t</span> C<span class="op">&gt;</span></span>
<span id="cb12-2"><a href="#cb12-2"></a><span class="kw">class</span> fs_matrix_engine</span>
<span id="cb12-3"><a href="#cb12-3"></a><span class="op">{</span></span>
<span id="cb12-4"><a href="#cb12-4"></a>  <span class="kw">public</span><span class="op">:</span></span>
<span id="cb12-5"><a href="#cb12-5"></a>    <span class="kw">using</span> engine_category <span class="op">=</span> mutable_matrix_engine_tag;</span>
<span id="cb12-6"><a href="#cb12-6"></a>    <span class="kw">using</span> element_type    <span class="op">=</span> T;</span>
<span id="cb12-7"><a href="#cb12-7"></a>    <span class="kw">using</span> value_type      <span class="op">=</span> T;</span>
<span id="cb12-8"><a href="#cb12-8"></a>    <span class="kw">using</span> reference       <span class="op">=</span> T<span class="op">&amp;</span>;</span>
<span id="cb12-9"><a href="#cb12-9"></a>    <span class="kw">using</span> pointer         <span class="op">=</span> T<span class="op">*</span>;</span>
<span id="cb12-10"><a href="#cb12-10"></a>    <span class="kw">using</span> const_reference <span class="op">=</span> T <span class="kw">const</span><span class="op">&amp;</span>;</span>
<span id="cb12-11"><a href="#cb12-11"></a>    <span class="kw">using</span> const_pointer   <span class="op">=</span> T <span class="kw">const</span><span class="op">*</span>;</span>
<span id="cb12-12"><a href="#cb12-12"></a>    <span class="kw">using</span> difference_type <span class="op">=</span> <span class="dt">ptrdiff_t</span>;</span>
<span id="cb12-13"><a href="#cb12-13"></a>    <span class="kw">using</span> index_type      <span class="op">=</span> <span class="dt">int_fast32_t</span>;</span>
<span id="cb12-14"><a href="#cb12-14"></a>    <span class="kw">using</span> size_type       <span class="op">=</span> <span class="dt">int_fast32_t</span>;</span>
<span id="cb12-15"><a href="#cb12-15"></a>    <span class="kw">using</span> size_tuple      <span class="op">=</span> tuple<span class="op">&lt;</span>size_type, size_type<span class="op">&gt;</span>;</span>
<span id="cb12-16"><a href="#cb12-16"></a></span>
<span id="cb12-17"><a href="#cb12-17"></a>    <span class="kw">using</span> is_fixed_size   <span class="op">=</span> true_type;</span>
<span id="cb12-18"><a href="#cb12-18"></a>    <span class="kw">using</span> is_resizable    <span class="op">=</span> false_type;</span>
<span id="cb12-19"><a href="#cb12-19"></a></span>
<span id="cb12-20"><a href="#cb12-20"></a>    <span class="kw">using</span> is_column_major <span class="op">=</span> false_type;</span>
<span id="cb12-21"><a href="#cb12-21"></a>    <span class="kw">using</span> is_dense        <span class="op">=</span> true_type;</span>
<span id="cb12-22"><a href="#cb12-22"></a>    <span class="kw">using</span> is_rectangular  <span class="op">=</span> true_type;</span>
<span id="cb12-23"><a href="#cb12-23"></a>    <span class="kw">using</span> is_row_major    <span class="op">=</span> true_type;</span>
<span id="cb12-24"><a href="#cb12-24"></a></span>
<span id="cb12-25"><a href="#cb12-25"></a>    <span class="kw">using</span> column_view_type    <span class="op">=</span> matrix_column_view<span class="op">&lt;</span>fs_matrix_engine<span class="op">&gt;</span>;</span>
<span id="cb12-26"><a href="#cb12-26"></a>    <span class="kw">using</span> row_view_type       <span class="op">=</span> matrix_row_view<span class="op">&lt;</span>fs_matrix_engine<span class="op">&gt;</span>;</span>
<span id="cb12-27"><a href="#cb12-27"></a>    <span class="kw">using</span> transpose_view_type <span class="op">=</span> matrix_transpose_view<span class="op">&lt;</span>fs_matrix_engine<span class="op">&gt;</span>;</span>
<span id="cb12-28"><a href="#cb12-28"></a></span>
<span id="cb12-29"><a href="#cb12-29"></a>  <span class="kw">public</span><span class="op">:</span></span>
<span id="cb12-30"><a href="#cb12-30"></a>    <span class="kw">constexpr</span> fs_matrix_engine<span class="op">()</span>;</span>
<span id="cb12-31"><a href="#cb12-31"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> U<span class="op">&gt;</span></span>
<span id="cb12-32"><a href="#cb12-32"></a>    <span class="kw">constexpr</span> fs_matrix_engine<span class="op">(</span>initializer_list<span class="op">&lt;</span>U<span class="op">&gt;</span> list<span class="op">)</span>;</span>
<span id="cb12-33"><a href="#cb12-33"></a>    <span class="kw">constexpr</span> fs_matrix_engine<span class="op">(</span>fs_matrix_engine<span class="op">&amp;&amp;)</span> <span class="kw">noexcept</span> <span class="op">=</span> <span class="cf">default</span>;</span>
<span id="cb12-34"><a href="#cb12-34"></a>    <span class="kw">constexpr</span> fs_matrix_engine<span class="op">(</span>fs_matrix_engine <span class="kw">const</span><span class="op">&amp;)</span> <span class="op">=</span> <span class="cf">default</span>;</span>
<span id="cb12-35"><a href="#cb12-35"></a></span>
<span id="cb12-36"><a href="#cb12-36"></a>    <span class="kw">constexpr</span> fs_matrix_engine<span class="op">&amp;</span>     <span class="kw">operator</span> <span class="op">=(</span>fs_matrix_engine<span class="op">&amp;&amp;)</span> <span class="kw">noexcept</span> <span class="op">=</span> <span class="cf">default</span>;</span>
<span id="cb12-37"><a href="#cb12-37"></a>    <span class="kw">constexpr</span> fs_matrix_engine<span class="op">&amp;</span>     <span class="kw">operator</span> <span class="op">=(</span>fs_matrix_engine <span class="kw">const</span><span class="op">&amp;)</span> <span class="op">=</span> <span class="cf">default</span>;</span>
<span id="cb12-38"><a href="#cb12-38"></a></span>
<span id="cb12-39"><a href="#cb12-39"></a>    <span class="kw">constexpr</span> const_reference   <span class="kw">operator</span> <span class="op">()(</span>index_type i, index_type j<span class="op">)</span> <span class="kw">const</span>;</span>
<span id="cb12-40"><a href="#cb12-40"></a></span>
<span id="cb12-41"><a href="#cb12-41"></a>    <span class="kw">constexpr</span> index_type    columns<span class="op">()</span> <span class="kw">const</span> <span class="kw">noexcept</span>;</span>
<span id="cb12-42"><a href="#cb12-42"></a>    <span class="kw">constexpr</span> index_type    rows<span class="op">()</span> <span class="kw">const</span> <span class="kw">noexcept</span>;</span>
<span id="cb12-43"><a href="#cb12-43"></a>    <span class="kw">constexpr</span> size_tuple    size<span class="op">()</span> <span class="kw">const</span> <span class="kw">noexcept</span>;</span>
<span id="cb12-44"><a href="#cb12-44"></a></span>
<span id="cb12-45"><a href="#cb12-45"></a>    <span class="kw">constexpr</span> size_type     column_capacity<span class="op">()</span> <span class="kw">const</span> <span class="kw">noexcept</span>;</span>
<span id="cb12-46"><a href="#cb12-46"></a>    <span class="kw">constexpr</span> size_type     row_capacity<span class="op">()</span> <span class="kw">const</span> <span class="kw">noexcept</span>;</span>
<span id="cb12-47"><a href="#cb12-47"></a>    <span class="kw">constexpr</span> size_tuple    capacity<span class="op">()</span> <span class="kw">const</span> <span class="kw">noexcept</span>;</span>
<span id="cb12-48"><a href="#cb12-48"></a></span>
<span id="cb12-49"><a href="#cb12-49"></a>    <span class="kw">constexpr</span> reference     <span class="kw">operator</span> <span class="op">()(</span>index_type i, index_type j<span class="op">)</span>;</span>
<span id="cb12-50"><a href="#cb12-50"></a></span>
<span id="cb12-51"><a href="#cb12-51"></a>    <span class="kw">constexpr</span> <span class="dt">void</span>      assign<span class="op">(</span>fs_matrix_engine <span class="kw">const</span><span class="op">&amp;</span> rhs<span class="op">)</span>;</span>
<span id="cb12-52"><a href="#cb12-52"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> ET2<span class="op">&gt;</span></span>
<span id="cb12-53"><a href="#cb12-53"></a>    <span class="kw">constexpr</span> <span class="dt">void</span>      assign<span class="op">(</span>ET2 <span class="kw">const</span><span class="op">&amp;</span> rhs<span class="op">)</span>;</span>
<span id="cb12-54"><a href="#cb12-54"></a></span>
<span id="cb12-55"><a href="#cb12-55"></a>    <span class="kw">constexpr</span> <span class="dt">void</span>      swap<span class="op">(</span>fs_matrix_engine<span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">noexcept</span>;</span>
<span id="cb12-56"><a href="#cb12-56"></a>    <span class="kw">constexpr</span> <span class="dt">void</span>      swap_columns<span class="op">(</span>index_type j1, index_type j2<span class="op">)</span> <span class="kw">noexcept</span>;</span>
<span id="cb12-57"><a href="#cb12-57"></a>    <span class="kw">constexpr</span> <span class="dt">void</span>      swap_rows<span class="op">(</span>index_type i1, index_type i2<span class="op">)</span> <span class="kw">noexcept</span>;</span>
<span id="cb12-58"><a href="#cb12-58"></a><span class="op">}</span>;</span></code></pre></div>
<h3 id="dr_vector_enginet-at"><span class="header-section-number">6.5.6</span> <code>dr_vector_engine&lt;T, AT&gt;</code><a href="#dr_vector_enginet-at" class="self-link"></a></h3>
<p>Class template <code>dr_vector_engine&lt;T, AT&gt;</code> implements an engine for vectors whose sizes and capacities can be changed at runtime. In addition to the basic engine interface, it provides member functions for mutable element indexing, swapping engine contents, swapping individual elements, and resizing.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T, <span class="kw">class</span> AT<span class="op">=</span>std<span class="op">::</span>allocator<span class="op">&lt;</span>T<span class="op">&gt;&gt;</span></span>
<span id="cb13-2"><a href="#cb13-2"></a><span class="kw">class</span> dr_vector_engine</span>
<span id="cb13-3"><a href="#cb13-3"></a><span class="op">{</span></span>
<span id="cb13-4"><a href="#cb13-4"></a>  <span class="kw">public</span><span class="op">:</span></span>
<span id="cb13-5"><a href="#cb13-5"></a>    <span class="kw">using</span> engine_category <span class="op">=</span> resizable_vector_engine_tag;</span>
<span id="cb13-6"><a href="#cb13-6"></a>    <span class="kw">using</span> element_type    <span class="op">=</span> T;</span>
<span id="cb13-7"><a href="#cb13-7"></a>    <span class="kw">using</span> value_type      <span class="op">=</span> T;</span>
<span id="cb13-8"><a href="#cb13-8"></a>    <span class="kw">using</span> alloc_type      <span class="op">=</span> AT;</span>
<span id="cb13-9"><a href="#cb13-9"></a>    <span class="kw">using</span> reference       <span class="op">=</span> T<span class="op">&amp;</span>;</span>
<span id="cb13-10"><a href="#cb13-10"></a>    <span class="kw">using</span> pointer         <span class="op">=</span> <span class="kw">typename</span> allocator_traits<span class="op">&lt;</span>AT<span class="op">&gt;::</span>pointer;</span>
<span id="cb13-11"><a href="#cb13-11"></a>    <span class="kw">using</span> const_reference <span class="op">=</span> T <span class="kw">const</span><span class="op">&amp;</span>;</span>
<span id="cb13-12"><a href="#cb13-12"></a>    <span class="kw">using</span> const_pointer   <span class="op">=</span> <span class="kw">typename</span> allocator_traits<span class="op">&lt;</span>AT<span class="op">&gt;::</span>const_pointer;</span>
<span id="cb13-13"><a href="#cb13-13"></a>    <span class="kw">using</span> iterator        <span class="op">=</span> <span class="op">...</span>;            <span class="co">//- Implementation-defined</span></span>
<span id="cb13-14"><a href="#cb13-14"></a>    <span class="kw">using</span> const_iterator  <span class="op">=</span> <span class="op">...</span>;            <span class="co">//- Implementation-defined</span></span>
<span id="cb13-15"><a href="#cb13-15"></a>    <span class="kw">using</span> difference_type <span class="op">=</span> <span class="dt">ptrdiff_t</span>;</span>
<span id="cb13-16"><a href="#cb13-16"></a>    <span class="kw">using</span> index_type      <span class="op">=</span> <span class="dt">ptrdiff_t</span>;</span>
<span id="cb13-17"><a href="#cb13-17"></a>    <span class="kw">using</span> size_type       <span class="op">=</span> <span class="dt">ptrdiff_t</span>;</span>
<span id="cb13-18"><a href="#cb13-18"></a></span>
<span id="cb13-19"><a href="#cb13-19"></a>    <span class="kw">using</span> is_fixed_size   <span class="op">=</span> false_type;</span>
<span id="cb13-20"><a href="#cb13-20"></a>    <span class="kw">using</span> is_resizable    <span class="op">=</span> true_type;</span>
<span id="cb13-21"><a href="#cb13-21"></a></span>
<span id="cb13-22"><a href="#cb13-22"></a>    <span class="kw">using</span> is_column_major <span class="op">=</span> true_type;</span>
<span id="cb13-23"><a href="#cb13-23"></a>    <span class="kw">using</span> is_dense        <span class="op">=</span> true_type;</span>
<span id="cb13-24"><a href="#cb13-24"></a>    <span class="kw">using</span> is_rectangular  <span class="op">=</span> true_type;</span>
<span id="cb13-25"><a href="#cb13-25"></a>    <span class="kw">using</span> is_row_major    <span class="op">=</span> true_type;</span>
<span id="cb13-26"><a href="#cb13-26"></a></span>
<span id="cb13-27"><a href="#cb13-27"></a>  <span class="kw">public</span><span class="op">:</span></span>
<span id="cb13-28"><a href="#cb13-28"></a>    <span class="op">~</span>dr_vector_engine<span class="op">()</span> <span class="kw">noexcept</span>;</span>
<span id="cb13-29"><a href="#cb13-29"></a>    dr_vector_engine<span class="op">()</span>;</span>
<span id="cb13-30"><a href="#cb13-30"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> U<span class="op">&gt;</span></span>
<span id="cb13-31"><a href="#cb13-31"></a>    <span class="kw">constexpr</span> dr_vector_engine<span class="op">(</span>initializer_list<span class="op">&lt;</span>U<span class="op">&gt;</span> list<span class="op">)</span>;</span>
<span id="cb13-32"><a href="#cb13-32"></a>    dr_vector_engine<span class="op">(</span>dr_vector_engine<span class="op">&amp;&amp;)</span> <span class="kw">noexcept</span>;</span>
<span id="cb13-33"><a href="#cb13-33"></a>    dr_vector_engine<span class="op">(</span>dr_vector_engine <span class="kw">const</span><span class="op">&amp;)</span>;</span>
<span id="cb13-34"><a href="#cb13-34"></a>    dr_vector_engine<span class="op">(</span>size_type elems<span class="op">)</span>;</span>
<span id="cb13-35"><a href="#cb13-35"></a>    dr_vector_engine<span class="op">(</span>size_type elems, size_type elem_cap<span class="op">)</span>;</span>
<span id="cb13-36"><a href="#cb13-36"></a></span>
<span id="cb13-37"><a href="#cb13-37"></a>    dr_vector_engine<span class="op">&amp;</span> <span class="kw">operator</span> <span class="op">=(</span>dr_vector_engine<span class="op">&amp;&amp;)</span> <span class="kw">noexcept</span>;</span>
<span id="cb13-38"><a href="#cb13-38"></a>    dr_vector_engine<span class="op">&amp;</span> <span class="kw">operator</span> <span class="op">=(</span>dr_vector_engine <span class="kw">const</span><span class="op">&amp;)</span>;</span>
<span id="cb13-39"><a href="#cb13-39"></a></span>
<span id="cb13-40"><a href="#cb13-40"></a>    const_reference <span class="kw">operator</span> <span class="op">()(</span>index_type i<span class="op">)</span> <span class="kw">const</span>;</span>
<span id="cb13-41"><a href="#cb13-41"></a>    const_iterator  begin<span class="op">()</span> <span class="kw">const</span> <span class="kw">noexcept</span>;</span>
<span id="cb13-42"><a href="#cb13-42"></a>    const_iterator  end<span class="op">()</span> <span class="kw">const</span> <span class="kw">noexcept</span>;</span>
<span id="cb13-43"><a href="#cb13-43"></a></span>
<span id="cb13-44"><a href="#cb13-44"></a>    size_type       elements<span class="op">()</span> <span class="kw">const</span> <span class="kw">noexcept</span>;</span>
<span id="cb13-45"><a href="#cb13-45"></a>    size_type       capacity<span class="op">()</span> <span class="kw">const</span> <span class="kw">noexcept</span>;</span>
<span id="cb13-46"><a href="#cb13-46"></a></span>
<span id="cb13-47"><a href="#cb13-47"></a>    reference   <span class="kw">operator</span> <span class="op">()(</span>index_type i<span class="op">)</span>;</span>
<span id="cb13-48"><a href="#cb13-48"></a>    iterator    begin<span class="op">()</span> <span class="kw">noexcept</span>;</span>
<span id="cb13-49"><a href="#cb13-49"></a>    iterator    end<span class="op">()</span> <span class="kw">noexcept</span>;</span>
<span id="cb13-50"><a href="#cb13-50"></a></span>
<span id="cb13-51"><a href="#cb13-51"></a>    <span class="dt">void</span>    assign<span class="op">(</span>dr_vector_engine <span class="kw">const</span><span class="op">&amp;</span> rhs<span class="op">)</span>;</span>
<span id="cb13-52"><a href="#cb13-52"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> ET2<span class="op">&gt;</span></span>
<span id="cb13-53"><a href="#cb13-53"></a>    <span class="dt">void</span>    assign<span class="op">(</span>ET2 <span class="kw">const</span><span class="op">&amp;</span> rhs<span class="op">)</span>;</span>
<span id="cb13-54"><a href="#cb13-54"></a></span>
<span id="cb13-55"><a href="#cb13-55"></a>    <span class="dt">void</span>    reserve<span class="op">(</span>size_type cap<span class="op">)</span>;</span>
<span id="cb13-56"><a href="#cb13-56"></a>    <span class="dt">void</span>    resize<span class="op">(</span>size_type elems<span class="op">)</span>;</span>
<span id="cb13-57"><a href="#cb13-57"></a>    <span class="dt">void</span>    resize<span class="op">(</span>size_type elems, size_type cap<span class="op">)</span>;</span>
<span id="cb13-58"><a href="#cb13-58"></a>    <span class="dt">void</span>    swap<span class="op">(</span>dr_vector_engine<span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">noexcept</span>;</span>
<span id="cb13-59"><a href="#cb13-59"></a>    <span class="dt">void</span>    swap_elements<span class="op">(</span>index_type i, index_type j<span class="op">)</span> <span class="kw">noexcept</span>;</span>
<span id="cb13-60"><a href="#cb13-60"></a><span class="op">}</span>;</span></code></pre></div>
<h3 id="dr_matrix_enginet-at"><span class="header-section-number">6.5.7</span> <code>dr_matrix_engine&lt;T, AT&gt;</code><a href="#dr_matrix_enginet-at" class="self-link"></a></h3>
<p>Class template <code>dr_matrix_engine&lt;T, AT&gt;</code> implements an engine for matrices whose sizes and capacities can be changed at runtime. In addition to the basic engine interface, it provides member functions for mutable element indexing, swapping engine contents, swapping columns, swapping rows, and resizing.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T, <span class="kw">class</span> AT<span class="op">=</span>std<span class="op">::</span>allocator<span class="op">&lt;</span>T<span class="op">&gt;&gt;</span></span>
<span id="cb14-2"><a href="#cb14-2"></a><span class="kw">class</span> dr_matrix_engine</span>
<span id="cb14-3"><a href="#cb14-3"></a><span class="op">{</span></span>
<span id="cb14-4"><a href="#cb14-4"></a>  <span class="kw">public</span><span class="op">:</span></span>
<span id="cb14-5"><a href="#cb14-5"></a>    <span class="kw">using</span> engine_category <span class="op">=</span> resizable_matrix_engine_tag;</span>
<span id="cb14-6"><a href="#cb14-6"></a>    <span class="kw">using</span> element_type    <span class="op">=</span> T;</span>
<span id="cb14-7"><a href="#cb14-7"></a>    <span class="kw">using</span> value_type      <span class="op">=</span> T;</span>
<span id="cb14-8"><a href="#cb14-8"></a>    <span class="kw">using</span> allocator_type  <span class="op">=</span> AT;</span>
<span id="cb14-9"><a href="#cb14-9"></a>    <span class="kw">using</span> reference       <span class="op">=</span> T<span class="op">&amp;</span>;</span>
<span id="cb14-10"><a href="#cb14-10"></a>    <span class="kw">using</span> pointer         <span class="op">=</span> <span class="kw">typename</span> allocator_traits<span class="op">&lt;</span>AT<span class="op">&gt;::</span>pointer;</span>
<span id="cb14-11"><a href="#cb14-11"></a>    <span class="kw">using</span> const_reference <span class="op">=</span> T <span class="kw">const</span><span class="op">&amp;</span>;</span>
<span id="cb14-12"><a href="#cb14-12"></a>    <span class="kw">using</span> const_pointer   <span class="op">=</span> <span class="kw">typename</span> allocator_traits<span class="op">&lt;</span>AT<span class="op">&gt;::</span>const_pointer;</span>
<span id="cb14-13"><a href="#cb14-13"></a>    <span class="kw">using</span> difference_type <span class="op">=</span> <span class="dt">ptrdiff_t</span>;</span>
<span id="cb14-14"><a href="#cb14-14"></a>    <span class="kw">using</span> index_type      <span class="op">=</span> <span class="dt">ptrdiff_t</span>;</span>
<span id="cb14-15"><a href="#cb14-15"></a>    <span class="kw">using</span> size_type       <span class="op">=</span> <span class="dt">ptrdiff_t</span>;</span>
<span id="cb14-16"><a href="#cb14-16"></a>    <span class="kw">using</span> size_tuple      <span class="op">=</span> tuple<span class="op">&lt;</span>size_type, size_type<span class="op">&gt;</span>;</span>
<span id="cb14-17"><a href="#cb14-17"></a></span>
<span id="cb14-18"><a href="#cb14-18"></a>    <span class="kw">using</span> is_fixed_size   <span class="op">=</span> false_type;</span>
<span id="cb14-19"><a href="#cb14-19"></a>    <span class="kw">using</span> is_resizable    <span class="op">=</span> true_type;</span>
<span id="cb14-20"><a href="#cb14-20"></a></span>
<span id="cb14-21"><a href="#cb14-21"></a>    <span class="kw">using</span> is_column_major <span class="op">=</span> false_type;</span>
<span id="cb14-22"><a href="#cb14-22"></a>    <span class="kw">using</span> is_dense        <span class="op">=</span> true_type;</span>
<span id="cb14-23"><a href="#cb14-23"></a>    <span class="kw">using</span> is_rectangular  <span class="op">=</span> true_type;</span>
<span id="cb14-24"><a href="#cb14-24"></a>    <span class="kw">using</span> is_row_major    <span class="op">=</span> true_type;</span>
<span id="cb14-25"><a href="#cb14-25"></a></span>
<span id="cb14-26"><a href="#cb14-26"></a>    <span class="kw">using</span> column_view_type    <span class="op">=</span> matrix_column_view<span class="op">&lt;</span>dr_matrix_engine<span class="op">&gt;</span>;</span>
<span id="cb14-27"><a href="#cb14-27"></a>    <span class="kw">using</span> row_view_type       <span class="op">=</span> matrix_row_view<span class="op">&lt;</span>dr_matrix_engine<span class="op">&gt;</span>;</span>
<span id="cb14-28"><a href="#cb14-28"></a>    <span class="kw">using</span> transpose_view_type <span class="op">=</span> matrix_transpose_view<span class="op">&lt;</span>dr_matrix_engine<span class="op">&gt;</span>;</span>
<span id="cb14-29"><a href="#cb14-29"></a></span>
<span id="cb14-30"><a href="#cb14-30"></a>  <span class="kw">public</span><span class="op">:</span></span>
<span id="cb14-31"><a href="#cb14-31"></a>    <span class="op">~</span>dr_matrix_engine<span class="op">()</span>;</span>
<span id="cb14-32"><a href="#cb14-32"></a>    dr_matrix_engine<span class="op">()</span>;</span>
<span id="cb14-33"><a href="#cb14-33"></a>    dr_matrix_engine<span class="op">(</span>dr_matrix_engine<span class="op">&amp;&amp;</span> rhs<span class="op">)</span> <span class="kw">noexcept</span>;</span>
<span id="cb14-34"><a href="#cb14-34"></a>    dr_matrix_engine<span class="op">(</span>dr_matrix_engine <span class="kw">const</span><span class="op">&amp;</span> rhs<span class="op">)</span>;</span>
<span id="cb14-35"><a href="#cb14-35"></a>    dr_matrix_engine<span class="op">(</span>size_type rows, size_type cols<span class="op">)</span>;</span>
<span id="cb14-36"><a href="#cb14-36"></a>    dr_matrix_engine<span class="op">(</span>size_type rows, size_type cols, </span>
<span id="cb14-37"><a href="#cb14-37"></a>                     size_type rowcap, size_type colcap<span class="op">)</span>;</span>
<span id="cb14-38"><a href="#cb14-38"></a></span>
<span id="cb14-39"><a href="#cb14-39"></a>    dr_matrix_engine<span class="op">&amp;</span> <span class="kw">operator</span> <span class="op">=(</span>dr_matrix_engine<span class="op">&amp;&amp;)</span> <span class="kw">noexcept</span>;</span>
<span id="cb14-40"><a href="#cb14-40"></a>    dr_matrix_engine<span class="op">&amp;</span> <span class="kw">operator</span> <span class="op">=(</span>dr_matrix_engine <span class="kw">const</span><span class="op">&amp;)</span>;</span>
<span id="cb14-41"><a href="#cb14-41"></a></span>
<span id="cb14-42"><a href="#cb14-42"></a>    const_reference     <span class="kw">operator</span> <span class="op">()(</span>index_type i, index_type j<span class="op">)</span> <span class="kw">const</span>;</span>
<span id="cb14-43"><a href="#cb14-43"></a></span>
<span id="cb14-44"><a href="#cb14-44"></a>    size_type   columns<span class="op">()</span> <span class="kw">const</span> <span class="kw">noexcept</span>;</span>
<span id="cb14-45"><a href="#cb14-45"></a>    size_type   rows<span class="op">()</span> <span class="kw">const</span> <span class="kw">noexcept</span>;</span>
<span id="cb14-46"><a href="#cb14-46"></a>    size_tuple  size<span class="op">()</span> <span class="kw">const</span> <span class="kw">noexcept</span>;</span>
<span id="cb14-47"><a href="#cb14-47"></a></span>
<span id="cb14-48"><a href="#cb14-48"></a>    size_type   column_capacity<span class="op">()</span> <span class="kw">const</span> <span class="kw">noexcept</span>;</span>
<span id="cb14-49"><a href="#cb14-49"></a>    size_type   row_capacity<span class="op">()</span> <span class="kw">const</span> <span class="kw">noexcept</span>;</span>
<span id="cb14-50"><a href="#cb14-50"></a>    size_tuple  capacity<span class="op">()</span> <span class="kw">const</span> <span class="kw">noexcept</span>;</span>
<span id="cb14-51"><a href="#cb14-51"></a></span>
<span id="cb14-52"><a href="#cb14-52"></a>    reference   <span class="kw">operator</span> <span class="op">()(</span>index_type i, index_type j<span class="op">)</span>;</span>
<span id="cb14-53"><a href="#cb14-53"></a></span>
<span id="cb14-54"><a href="#cb14-54"></a>    <span class="dt">void</span>    assign<span class="op">(</span>dr_matrix_engine <span class="kw">const</span><span class="op">&amp;</span> rhs<span class="op">)</span>;</span>
<span id="cb14-55"><a href="#cb14-55"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> ET2<span class="op">&gt;</span></span>
<span id="cb14-56"><a href="#cb14-56"></a>    <span class="dt">void</span>    assign<span class="op">(</span>ET2 <span class="kw">const</span><span class="op">&amp;</span> rhs<span class="op">)</span>;</span>
<span id="cb14-57"><a href="#cb14-57"></a></span>
<span id="cb14-58"><a href="#cb14-58"></a>    <span class="dt">void</span>    reserve<span class="op">(</span>size_type rowcap, size_type colcap<span class="op">)</span>;</span>
<span id="cb14-59"><a href="#cb14-59"></a>    <span class="dt">void</span>    resize<span class="op">(</span>size_type rows, size_type cols<span class="op">)</span>;</span>
<span id="cb14-60"><a href="#cb14-60"></a>    <span class="dt">void</span>    resize<span class="op">(</span>size_type rows, size_type cols, </span>
<span id="cb14-61"><a href="#cb14-61"></a>                   size_type rowcap, size_type colcap<span class="op">)</span>;</span>
<span id="cb14-62"><a href="#cb14-62"></a>    <span class="dt">void</span>    swap<span class="op">(</span>dr_matrix_engine<span class="op">&amp;</span> other<span class="op">)</span> <span class="kw">noexcept</span>;</span>
<span id="cb14-63"><a href="#cb14-63"></a>    <span class="dt">void</span>    swap_columns<span class="op">(</span>index_type c1, index_type c2<span class="op">)</span> <span class="kw">noexcept</span>;</span>
<span id="cb14-64"><a href="#cb14-64"></a>    <span class="dt">void</span>    swap_rows<span class="op">(</span>index_type r1, index_type r2<span class="op">)</span> <span class="kw">noexcept</span>;</span>
<span id="cb14-65"><a href="#cb14-65"></a><span class="op">}</span>;</span></code></pre></div>
<h2 id="math-object-types"><span class="header-section-number">6.6</span> Math object types<a href="#math-object-types" class="self-link"></a></h2>
<h3 id="vectoret-ot"><span class="header-section-number">6.6.1</span> <code>vector&lt;ET, OT&gt;</code><a href="#vectoret-ot" class="self-link"></a></h3>
<p>Class template <code>vector&lt;ET, OT&gt;</code> represents a vector, with element type and resource management implemented by the engine type <code>ET</code>, and arithmetic operations specified by the operation traits type <code>OT</code>. If the underlying engine type provides dynamic resizing, then this class will as well.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> ET, <span class="kw">class</span> OT<span class="op">&gt;</span></span>
<span id="cb15-2"><a href="#cb15-2"></a><span class="kw">class</span> vector</span>
<span id="cb15-3"><a href="#cb15-3"></a><span class="op">{</span></span>
<span id="cb15-4"><a href="#cb15-4"></a>  <span class="kw">public</span><span class="op">:</span></span>
<span id="cb15-5"><a href="#cb15-5"></a>    <span class="kw">using</span> engine_type     <span class="op">=</span> ET;</span>
<span id="cb15-6"><a href="#cb15-6"></a>    <span class="kw">using</span> element_type    <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>element_type;</span>
<span id="cb15-7"><a href="#cb15-7"></a>    <span class="kw">using</span> reference       <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>reference;</span>
<span id="cb15-8"><a href="#cb15-8"></a>    <span class="kw">using</span> pointer         <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>pointer;</span>
<span id="cb15-9"><a href="#cb15-9"></a>    <span class="kw">using</span> const_reference <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>const_reference;</span>
<span id="cb15-10"><a href="#cb15-10"></a>    <span class="kw">using</span> const_pointer   <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>const_pointer;</span>
<span id="cb15-11"><a href="#cb15-11"></a>    <span class="kw">using</span> iterator        <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>iterator;</span>
<span id="cb15-12"><a href="#cb15-12"></a>    <span class="kw">using</span> const_iterator  <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>const_iterator;</span>
<span id="cb15-13"><a href="#cb15-13"></a>    <span class="kw">using</span> index_type      <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>index_type;</span>
<span id="cb15-14"><a href="#cb15-14"></a>    <span class="kw">using</span> size_type       <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>size_type;</span>
<span id="cb15-15"><a href="#cb15-15"></a></span>
<span id="cb15-16"><a href="#cb15-16"></a>    <span class="kw">using</span> transpose_type  <span class="op">=</span> vector <span class="kw">const</span><span class="op">&amp;</span>;</span>
<span id="cb15-17"><a href="#cb15-17"></a>    <span class="kw">using</span> hermitian_type  <span class="op">=</span> conditional_t<span class="op">&lt;</span>is_complex_v<span class="op">&lt;</span>element_type<span class="op">&gt;</span>, vector, transpose_type<span class="op">&gt;</span>;</span>
<span id="cb15-18"><a href="#cb15-18"></a></span>
<span id="cb15-19"><a href="#cb15-19"></a>    <span class="kw">using</span> is_fixed_size   <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>is_fixed_size;</span>
<span id="cb15-20"><a href="#cb15-20"></a>    <span class="kw">using</span> is_resizable    <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>is_resizable;</span>
<span id="cb15-21"><a href="#cb15-21"></a></span>
<span id="cb15-22"><a href="#cb15-22"></a>    <span class="kw">using</span> is_column_major <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>is_column_major;</span>
<span id="cb15-23"><a href="#cb15-23"></a>    <span class="kw">using</span> is_dense        <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>is_dense;</span>
<span id="cb15-24"><a href="#cb15-24"></a>    <span class="kw">using</span> is_rectangular  <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>is_rectangular;</span>
<span id="cb15-25"><a href="#cb15-25"></a>    <span class="kw">using</span> is_row_major    <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>is_row_major;</span>
<span id="cb15-26"><a href="#cb15-26"></a></span>
<span id="cb15-27"><a href="#cb15-27"></a>  <span class="kw">public</span><span class="op">:</span></span>
<span id="cb15-28"><a href="#cb15-28"></a>    <span class="op">~</span>vector<span class="op">()</span> <span class="op">=</span> <span class="cf">default</span>;</span>
<span id="cb15-29"><a href="#cb15-29"></a></span>
<span id="cb15-30"><a href="#cb15-30"></a>    <span class="kw">constexpr</span> vector<span class="op">()</span>;</span>
<span id="cb15-31"><a href="#cb15-31"></a>    <span class="kw">constexpr</span> vector<span class="op">(</span>vector<span class="op">&amp;&amp;)</span> <span class="kw">noexcept</span> <span class="op">=</span> <span class="cf">default</span>;</span>
<span id="cb15-32"><a href="#cb15-32"></a>    <span class="kw">constexpr</span> vector<span class="op">(</span>vector <span class="kw">const</span><span class="op">&amp;)</span> <span class="op">=</span> <span class="cf">default</span>;</span>
<span id="cb15-33"><a href="#cb15-33"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> ET2, <span class="kw">class</span> OT2<span class="op">&gt;</span></span>
<span id="cb15-34"><a href="#cb15-34"></a>    <span class="kw">constexpr</span> vector<span class="op">(</span>vector<span class="op">&lt;</span>ET2, OT2<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> src<span class="op">)</span>;</span>
<span id="cb15-35"><a href="#cb15-35"></a></span>
<span id="cb15-36"><a href="#cb15-36"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> U<span class="op">&gt;</span></span>
<span id="cb15-37"><a href="#cb15-37"></a>    <span class="kw">constexpr</span> vector<span class="op">(</span>initializer_list<span class="op">&lt;</span>U<span class="op">&gt;</span> list<span class="op">)</span>;</span>
<span id="cb15-38"><a href="#cb15-38"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> ET2 <span class="op">=</span> ET, detail<span class="op">::</span>enable_if_resizable<span class="op">&lt;</span>ET, ET2<span class="op">&gt;</span> <span class="op">=</span> <span class="kw">true</span><span class="op">&gt;</span></span>
<span id="cb15-39"><a href="#cb15-39"></a>    <span class="kw">constexpr</span> vector<span class="op">(</span>size_type elems<span class="op">)</span>;</span>
<span id="cb15-40"><a href="#cb15-40"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> ET2 <span class="op">=</span> ET, detail<span class="op">::</span>enable_if_resizable<span class="op">&lt;</span>ET, ET2<span class="op">&gt;</span> <span class="op">=</span> <span class="kw">true</span><span class="op">&gt;</span></span>
<span id="cb15-41"><a href="#cb15-41"></a>    <span class="kw">constexpr</span> vector<span class="op">(</span>size_type elems, size_type elemcap<span class="op">)</span>;</span>
<span id="cb15-42"><a href="#cb15-42"></a></span>
<span id="cb15-43"><a href="#cb15-43"></a>    <span class="kw">constexpr</span> vector<span class="op">&amp;</span> <span class="kw">operator</span> <span class="op">=(</span>vector<span class="op">&amp;&amp;)</span> <span class="kw">noexcept</span> <span class="op">=</span> <span class="cf">default</span>;</span>
<span id="cb15-44"><a href="#cb15-44"></a>    <span class="kw">constexpr</span> vector<span class="op">&amp;</span> <span class="kw">operator</span> <span class="op">=(</span>vector <span class="kw">const</span><span class="op">&amp;)</span> <span class="op">=</span> <span class="cf">default</span>;</span>
<span id="cb15-45"><a href="#cb15-45"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> ET2, <span class="kw">class</span> OT2<span class="op">&gt;</span></span>
<span id="cb15-46"><a href="#cb15-46"></a>    <span class="kw">constexpr</span> vector<span class="op">&amp;</span> <span class="kw">operator</span> <span class="op">=(</span>vector<span class="op">&lt;</span>ET2, OT2<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> rhs<span class="op">)</span>;</span>
<span id="cb15-47"><a href="#cb15-47"></a></span>
<span id="cb15-48"><a href="#cb15-48"></a>    <span class="co">//- Const element access.</span></span>
<span id="cb15-49"><a href="#cb15-49"></a>    <span class="co">//</span></span>
<span id="cb15-50"><a href="#cb15-50"></a>    <span class="kw">constexpr</span> const_reference   <span class="kw">operator</span> <span class="op">()(</span>index_type i<span class="op">)</span> <span class="kw">const</span>;</span>
<span id="cb15-51"><a href="#cb15-51"></a>    <span class="kw">constexpr</span> const_iterator    begin<span class="op">()</span> <span class="kw">const</span> <span class="kw">noexcept</span>;</span>
<span id="cb15-52"><a href="#cb15-52"></a>    <span class="kw">constexpr</span> const_iterator    end<span class="op">()</span> <span class="kw">const</span> <span class="kw">noexcept</span>;</span>
<span id="cb15-53"><a href="#cb15-53"></a></span>
<span id="cb15-54"><a href="#cb15-54"></a>    <span class="co">//- Accessors.</span></span>
<span id="cb15-55"><a href="#cb15-55"></a>    <span class="co">//</span></span>
<span id="cb15-56"><a href="#cb15-56"></a>    <span class="kw">constexpr</span> size_type     capacity<span class="op">()</span> <span class="kw">const</span> <span class="kw">noexcept</span>;</span>
<span id="cb15-57"><a href="#cb15-57"></a>    <span class="kw">constexpr</span> index_type    elements<span class="op">()</span> <span class="kw">const</span> <span class="kw">noexcept</span>;</span>
<span id="cb15-58"><a href="#cb15-58"></a>    <span class="kw">constexpr</span> size_type     size<span class="op">()</span> <span class="kw">const</span> <span class="kw">noexcept</span>;</span>
<span id="cb15-59"><a href="#cb15-59"></a></span>
<span id="cb15-60"><a href="#cb15-60"></a>    <span class="co">//- Transpose and Hermitian.</span></span>
<span id="cb15-61"><a href="#cb15-61"></a>    <span class="co">//</span></span>
<span id="cb15-62"><a href="#cb15-62"></a>    <span class="kw">constexpr</span> transpose_type    t<span class="op">()</span> <span class="kw">const</span>;</span>
<span id="cb15-63"><a href="#cb15-63"></a>    <span class="kw">constexpr</span> hermitian_type    h<span class="op">()</span> <span class="kw">const</span>;</span>
<span id="cb15-64"><a href="#cb15-64"></a></span>
<span id="cb15-65"><a href="#cb15-65"></a>    <span class="co">//- Mutable element access.</span></span>
<span id="cb15-66"><a href="#cb15-66"></a>    <span class="co">//</span></span>
<span id="cb15-67"><a href="#cb15-67"></a>    <span class="kw">constexpr</span> reference     <span class="kw">operator</span> <span class="op">()(</span>index_type i<span class="op">)</span>;</span>
<span id="cb15-68"><a href="#cb15-68"></a>    <span class="kw">constexpr</span> iterator      begin<span class="op">()</span> <span class="kw">noexcept</span>;</span>
<span id="cb15-69"><a href="#cb15-69"></a>    <span class="kw">constexpr</span> iterator      end<span class="op">()</span> <span class="kw">noexcept</span>;</span>
<span id="cb15-70"><a href="#cb15-70"></a></span>
<span id="cb15-71"><a href="#cb15-71"></a>    <span class="co">//- Assignment.</span></span>
<span id="cb15-72"><a href="#cb15-72"></a>    <span class="co">//</span></span>
<span id="cb15-73"><a href="#cb15-73"></a>    <span class="kw">constexpr</span> <span class="dt">void</span>      assign<span class="op">(</span>vector <span class="kw">const</span><span class="op">&amp;</span> rhs<span class="op">)</span>;</span>
<span id="cb15-74"><a href="#cb15-74"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> ET2, <span class="kw">class</span> OT2<span class="op">&gt;</span></span>
<span id="cb15-75"><a href="#cb15-75"></a>    <span class="kw">constexpr</span> <span class="dt">void</span>      assign<span class="op">(</span>vector<span class="op">&lt;</span>ET2, OT2<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> rhs<span class="op">)</span>;</span>
<span id="cb15-76"><a href="#cb15-76"></a></span>
<span id="cb15-77"><a href="#cb15-77"></a>    <span class="co">//- Change capacity.</span></span>
<span id="cb15-78"><a href="#cb15-78"></a>    <span class="co">//</span></span>
<span id="cb15-79"><a href="#cb15-79"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> ET2 <span class="op">=</span> ET, detail<span class="op">::</span>enable_if_resizable<span class="op">&lt;</span>ET, ET2<span class="op">&gt;</span> <span class="op">=</span> <span class="kw">true</span><span class="op">&gt;</span></span>
<span id="cb15-80"><a href="#cb15-80"></a>    <span class="kw">constexpr</span> <span class="dt">void</span>      reserve<span class="op">(</span>size_type elemcap<span class="op">)</span>;</span>
<span id="cb15-81"><a href="#cb15-81"></a></span>
<span id="cb15-82"><a href="#cb15-82"></a>    <span class="co">//- Change size.</span></span>
<span id="cb15-83"><a href="#cb15-83"></a>    <span class="co">//</span></span>
<span id="cb15-84"><a href="#cb15-84"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> ET2 <span class="op">=</span> ET, detail<span class="op">::</span>enable_if_resizable<span class="op">&lt;</span>ET, ET2<span class="op">&gt;</span> <span class="op">=</span> <span class="kw">true</span><span class="op">&gt;</span></span>
<span id="cb15-85"><a href="#cb15-85"></a>    <span class="kw">constexpr</span> <span class="dt">void</span>      resize<span class="op">(</span>size_type elems<span class="op">)</span>;</span>
<span id="cb15-86"><a href="#cb15-86"></a></span>
<span id="cb15-87"><a href="#cb15-87"></a>    <span class="co">//- Change size and capacity in one shot.</span></span>
<span id="cb15-88"><a href="#cb15-88"></a>    <span class="co">//</span></span>
<span id="cb15-89"><a href="#cb15-89"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> ET2 <span class="op">=</span> ET, detail<span class="op">::</span>enable_if_resizable<span class="op">&lt;</span>ET, ET2<span class="op">&gt;</span> <span class="op">=</span> <span class="kw">true</span><span class="op">&gt;</span></span>
<span id="cb15-90"><a href="#cb15-90"></a>    <span class="kw">constexpr</span> <span class="dt">void</span>      resize<span class="op">(</span>size_type elems, size_type elemcap<span class="op">)</span>;</span>
<span id="cb15-91"><a href="#cb15-91"></a></span>
<span id="cb15-92"><a href="#cb15-92"></a>    <span class="co">//- Element operations.</span></span>
<span id="cb15-93"><a href="#cb15-93"></a>    <span class="co">//</span></span>
<span id="cb15-94"><a href="#cb15-94"></a>    <span class="kw">constexpr</span> <span class="dt">void</span>      swap<span class="op">(</span>vector<span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">noexcept</span>;</span>
<span id="cb15-95"><a href="#cb15-95"></a>    <span class="kw">constexpr</span> <span class="dt">void</span>      swap_elements<span class="op">(</span>index_type i, index_type j<span class="op">)</span> <span class="kw">noexcept</span>;</span>
<span id="cb15-96"><a href="#cb15-96"></a><span class="op">}</span>;</span></code></pre></div>
<h3 id="matrixet-ot"><span class="header-section-number">6.6.2</span> <code>matrix&lt;ET, OT&gt;</code><a href="#matrixet-ot" class="self-link"></a></h3>
<p>Class template <code>matrix&lt;ET, OT&gt;</code>represents a matrix, with element type and resource management implemented by the engine type <code>ET</code>, and arithmetic operations specified by the operation traits type <code>OT</code>. If the underlying engine type provides dynamic resizing, then this class will as well.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> ET, <span class="kw">class</span> OT<span class="op">&gt;</span></span>
<span id="cb16-2"><a href="#cb16-2"></a><span class="kw">class</span> matrix</span>
<span id="cb16-3"><a href="#cb16-3"></a><span class="op">{</span></span>
<span id="cb16-4"><a href="#cb16-4"></a>  <span class="kw">public</span><span class="op">:</span></span>
<span id="cb16-5"><a href="#cb16-5"></a>    <span class="kw">using</span> engine_type     <span class="op">=</span> ET;</span>
<span id="cb16-6"><a href="#cb16-6"></a>    <span class="kw">using</span> element_type    <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>element_type;</span>
<span id="cb16-7"><a href="#cb16-7"></a>    <span class="kw">using</span> reference       <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>reference;</span>
<span id="cb16-8"><a href="#cb16-8"></a>    <span class="kw">using</span> const_reference <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>const_reference;</span>
<span id="cb16-9"><a href="#cb16-9"></a>    <span class="kw">using</span> index_type      <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>index_type;</span>
<span id="cb16-10"><a href="#cb16-10"></a>    <span class="kw">using</span> size_type       <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>size_type;</span>
<span id="cb16-11"><a href="#cb16-11"></a>    <span class="kw">using</span> size_tuple      <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>size_tuple;</span>
<span id="cb16-12"><a href="#cb16-12"></a></span>
<span id="cb16-13"><a href="#cb16-13"></a>    <span class="kw">using</span> column_type     <span class="op">=</span> vector<span class="op">&lt;</span>matrix_column_view<span class="op">&lt;</span>engine_type<span class="op">&gt;</span>, OT<span class="op">&gt;</span>;</span>
<span id="cb16-14"><a href="#cb16-14"></a>    <span class="kw">using</span> row_type        <span class="op">=</span> vector<span class="op">&lt;</span>matrix_row_view<span class="op">&lt;</span>engine_type<span class="op">&gt;</span>, OT<span class="op">&gt;</span>;</span>
<span id="cb16-15"><a href="#cb16-15"></a>    <span class="kw">using</span> transpose_type  <span class="op">=</span> matrix<span class="op">&lt;</span>matrix_transpose_view<span class="op">&lt;</span>engine_type<span class="op">&gt;</span>, OT<span class="op">&gt;</span>;</span>
<span id="cb16-16"><a href="#cb16-16"></a>    <span class="kw">using</span> hermitian_type  <span class="op">=</span> conditional_t<span class="op">&lt;</span>is_complex_v<span class="op">&lt;</span>element_type<span class="op">&gt;</span>, matrix, transpose_type<span class="op">&gt;</span>;</span>
<span id="cb16-17"><a href="#cb16-17"></a></span>
<span id="cb16-18"><a href="#cb16-18"></a>    <span class="kw">using</span> is_fixed_size   <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>is_fixed_size;</span>
<span id="cb16-19"><a href="#cb16-19"></a>    <span class="kw">using</span> is_resizable    <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>is_resizable;</span>
<span id="cb16-20"><a href="#cb16-20"></a></span>
<span id="cb16-21"><a href="#cb16-21"></a>    <span class="kw">using</span> is_column_major <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>is_column_major;</span>
<span id="cb16-22"><a href="#cb16-22"></a>    <span class="kw">using</span> is_dense        <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>is_dense;</span>
<span id="cb16-23"><a href="#cb16-23"></a>    <span class="kw">using</span> is_rectangular  <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>is_rectangular;</span>
<span id="cb16-24"><a href="#cb16-24"></a>    <span class="kw">using</span> is_row_major    <span class="op">=</span> <span class="kw">typename</span> engine_type<span class="op">::</span>is_row_major;</span>
<span id="cb16-25"><a href="#cb16-25"></a></span>
<span id="cb16-26"><a href="#cb16-26"></a>  <span class="kw">public</span><span class="op">:</span></span>
<span id="cb16-27"><a href="#cb16-27"></a>    <span class="op">~</span>matrix<span class="op">()</span> <span class="op">=</span> <span class="cf">default</span>;</span>
<span id="cb16-28"><a href="#cb16-28"></a>    <span class="kw">constexpr</span> matrix<span class="op">()</span> <span class="op">=</span> <span class="cf">default</span>;</span>
<span id="cb16-29"><a href="#cb16-29"></a>    <span class="kw">constexpr</span> matrix<span class="op">(</span>matrix<span class="op">&amp;&amp;)</span> <span class="kw">noexcept</span> <span class="op">=</span> <span class="cf">default</span>;</span>
<span id="cb16-30"><a href="#cb16-30"></a>    <span class="kw">constexpr</span> matrix<span class="op">(</span>matrix <span class="kw">const</span><span class="op">&amp;)</span> <span class="op">=</span> <span class="cf">default</span>;</span>
<span id="cb16-31"><a href="#cb16-31"></a></span>
<span id="cb16-32"><a href="#cb16-32"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> U, <span class="kw">class</span> ET2 <span class="op">=</span> ET, detail<span class="op">::</span>enable_if_fixed_size<span class="op">&lt;</span>ET, ET2<span class="op">&gt;=</span><span class="kw">true</span><span class="op">&gt;</span></span>
<span id="cb16-33"><a href="#cb16-33"></a>    <span class="kw">constexpr</span> matrix<span class="op">(</span>initializer_list<span class="op">&lt;</span>U<span class="op">&gt;</span> list<span class="op">)</span>;</span>
<span id="cb16-34"><a href="#cb16-34"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> ET2, <span class="kw">class</span> OT2<span class="op">&gt;</span></span>
<span id="cb16-35"><a href="#cb16-35"></a>    <span class="kw">constexpr</span> matrix<span class="op">(</span>matrix<span class="op">&lt;</span>ET2, OT2<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> src<span class="op">)</span>;</span>
<span id="cb16-36"><a href="#cb16-36"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> ET2 <span class="op">=</span> ET, detail<span class="op">::</span>enable_if_resizable<span class="op">&lt;</span>ET, ET2<span class="op">&gt;</span> <span class="op">=</span> <span class="kw">true</span><span class="op">&gt;</span></span>
<span id="cb16-37"><a href="#cb16-37"></a>    <span class="kw">constexpr</span> matrix<span class="op">(</span>size_tuple size<span class="op">)</span>;</span>
<span id="cb16-38"><a href="#cb16-38"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> ET2 <span class="op">=</span> ET, detail<span class="op">::</span>enable_if_resizable<span class="op">&lt;</span>ET, ET2<span class="op">&gt;</span> <span class="op">=</span> <span class="kw">true</span><span class="op">&gt;</span></span>
<span id="cb16-39"><a href="#cb16-39"></a>    <span class="kw">constexpr</span> matrix<span class="op">(</span>size_type rows, size_type cols<span class="op">)</span>;</span>
<span id="cb16-40"><a href="#cb16-40"></a></span>
<span id="cb16-41"><a href="#cb16-41"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> ET2 <span class="op">=</span> ET, detail<span class="op">::</span>enable_if_resizable<span class="op">&lt;</span>ET, ET2<span class="op">&gt;</span> <span class="op">=</span> <span class="kw">true</span><span class="op">&gt;</span></span>
<span id="cb16-42"><a href="#cb16-42"></a>    <span class="kw">constexpr</span> matrix<span class="op">(</span>size_tuple size, size_tuple cap<span class="op">)</span>;</span>
<span id="cb16-43"><a href="#cb16-43"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> ET2 <span class="op">=</span> ET, detail<span class="op">::</span>enable_if_resizable<span class="op">&lt;</span>ET, ET2<span class="op">&gt;</span> <span class="op">=</span> <span class="kw">true</span><span class="op">&gt;</span></span>
<span id="cb16-44"><a href="#cb16-44"></a>    <span class="kw">constexpr</span> matrix<span class="op">(</span>size_type rows, size_type cols, </span>
<span id="cb16-45"><a href="#cb16-45"></a>                     size_type rowcap, size_type colcap<span class="op">)</span>;</span>
<span id="cb16-46"><a href="#cb16-46"></a></span>
<span id="cb16-47"><a href="#cb16-47"></a>    <span class="kw">constexpr</span> matrix<span class="op">&amp;</span>       <span class="kw">operator</span> <span class="op">=(</span>matrix<span class="op">&amp;&amp;)</span> <span class="kw">noexcept</span> <span class="op">=</span> <span class="cf">default</span>;</span>
<span id="cb16-48"><a href="#cb16-48"></a>    <span class="kw">constexpr</span> matrix<span class="op">&amp;</span>       <span class="kw">operator</span> <span class="op">=(</span>matrix <span class="kw">const</span><span class="op">&amp;)</span> <span class="op">=</span> <span class="cf">default</span>;</span>
<span id="cb16-49"><a href="#cb16-49"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> ET2, <span class="kw">class</span> OT2<span class="op">&gt;</span></span>
<span id="cb16-50"><a href="#cb16-50"></a>    <span class="kw">constexpr</span> matrix<span class="op">&amp;</span>       <span class="kw">operator</span> <span class="op">=(</span>matrix<span class="op">&lt;</span>ET2, OT2<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> rhs<span class="op">)</span>;</span>
<span id="cb16-51"><a href="#cb16-51"></a></span>
<span id="cb16-52"><a href="#cb16-52"></a>    <span class="co">//- Const element access.</span></span>
<span id="cb16-53"><a href="#cb16-53"></a>    <span class="co">//</span></span>
<span id="cb16-54"><a href="#cb16-54"></a>    <span class="kw">constexpr</span> const_reference   <span class="kw">operator</span> <span class="op">()(</span>index_type i, index_type j<span class="op">)</span> <span class="kw">const</span>;</span>
<span id="cb16-55"><a href="#cb16-55"></a></span>
<span id="cb16-56"><a href="#cb16-56"></a>    <span class="co">//- Accessors.</span></span>
<span id="cb16-57"><a href="#cb16-57"></a>    <span class="co">//</span></span>
<span id="cb16-58"><a href="#cb16-58"></a>    <span class="kw">constexpr</span> index_type    columns<span class="op">()</span> <span class="kw">const</span> <span class="kw">noexcept</span>;</span>
<span id="cb16-59"><a href="#cb16-59"></a>    <span class="kw">constexpr</span> index_type    rows<span class="op">()</span> <span class="kw">const</span> <span class="kw">noexcept</span>;</span>
<span id="cb16-60"><a href="#cb16-60"></a>    <span class="kw">constexpr</span> size_tuple    size<span class="op">()</span> <span class="kw">const</span> <span class="kw">noexcept</span>;</span>
<span id="cb16-61"><a href="#cb16-61"></a></span>
<span id="cb16-62"><a href="#cb16-62"></a>    <span class="kw">constexpr</span> size_type     column_capacity<span class="op">()</span> <span class="kw">const</span> <span class="kw">noexcept</span>;</span>
<span id="cb16-63"><a href="#cb16-63"></a>    <span class="kw">constexpr</span> size_type     row_capacity<span class="op">()</span> <span class="kw">const</span> <span class="kw">noexcept</span>;</span>
<span id="cb16-64"><a href="#cb16-64"></a>    <span class="kw">constexpr</span> size_tuple    capacity<span class="op">()</span> <span class="kw">const</span> <span class="kw">noexcept</span>;</span>
<span id="cb16-65"><a href="#cb16-65"></a></span>
<span id="cb16-66"><a href="#cb16-66"></a>    <span class="co">//- Column view, row view, transpose view, and Hermitian.</span></span>
<span id="cb16-67"><a href="#cb16-67"></a>    <span class="co">//</span></span>
<span id="cb16-68"><a href="#cb16-68"></a>    <span class="kw">constexpr</span> column_type       column<span class="op">(</span>index_type j<span class="op">)</span> <span class="kw">const</span> <span class="kw">noexcept</span>;</span>
<span id="cb16-69"><a href="#cb16-69"></a>    <span class="kw">constexpr</span> row_type          row<span class="op">(</span>index_type i<span class="op">)</span> <span class="kw">const</span> <span class="kw">noexcept</span>;</span>
<span id="cb16-70"><a href="#cb16-70"></a>    <span class="kw">constexpr</span> transpose_type    t<span class="op">()</span> <span class="kw">const</span>;</span>
<span id="cb16-71"><a href="#cb16-71"></a>    <span class="kw">constexpr</span> hermitian_type    h<span class="op">()</span> <span class="kw">const</span>;</span>
<span id="cb16-72"><a href="#cb16-72"></a></span>
<span id="cb16-73"><a href="#cb16-73"></a>    <span class="co">//- Mutable element access.</span></span>
<span id="cb16-74"><a href="#cb16-74"></a>    <span class="co">//</span></span>
<span id="cb16-75"><a href="#cb16-75"></a>    <span class="kw">constexpr</span> reference     <span class="kw">operator</span> <span class="op">()(</span>index_type i, index_type j<span class="op">)</span>;</span>
<span id="cb16-76"><a href="#cb16-76"></a></span>
<span id="cb16-77"><a href="#cb16-77"></a>    <span class="co">//- Assignment.</span></span>
<span id="cb16-78"><a href="#cb16-78"></a>    <span class="co">//</span></span>
<span id="cb16-79"><a href="#cb16-79"></a>    <span class="kw">constexpr</span> <span class="dt">void</span>      assign<span class="op">(</span>matrix <span class="kw">const</span><span class="op">&amp;</span> rhs<span class="op">)</span>;</span>
<span id="cb16-80"><a href="#cb16-80"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> ET2, <span class="kw">class</span> OT2<span class="op">&gt;</span></span>
<span id="cb16-81"><a href="#cb16-81"></a>    <span class="kw">constexpr</span> <span class="dt">void</span>      assign<span class="op">(</span>matrix<span class="op">&lt;</span>ET2, OT2<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> rhs<span class="op">)</span>;</span>
<span id="cb16-82"><a href="#cb16-82"></a></span>
<span id="cb16-83"><a href="#cb16-83"></a>    <span class="co">//- Change capacity.</span></span>
<span id="cb16-84"><a href="#cb16-84"></a>    <span class="co">//</span></span>
<span id="cb16-85"><a href="#cb16-85"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> ET2 <span class="op">=</span> ET, detail<span class="op">::</span>enable_if_resizable<span class="op">&lt;</span>ET, ET2<span class="op">&gt;</span> <span class="op">=</span> <span class="kw">true</span><span class="op">&gt;</span></span>
<span id="cb16-86"><a href="#cb16-86"></a>    <span class="kw">constexpr</span> <span class="dt">void</span>      reserve<span class="op">(</span>size_tuple cap<span class="op">)</span>;</span>
<span id="cb16-87"><a href="#cb16-87"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> ET2 <span class="op">=</span> ET, detail<span class="op">::</span>enable_if_resizable<span class="op">&lt;</span>ET, ET2<span class="op">&gt;</span> <span class="op">=</span> <span class="kw">true</span><span class="op">&gt;</span></span>
<span id="cb16-88"><a href="#cb16-88"></a>    <span class="kw">constexpr</span> <span class="dt">void</span>      reserve<span class="op">(</span>size_type rowcap, size_type colcap<span class="op">)</span>;</span>
<span id="cb16-89"><a href="#cb16-89"></a></span>
<span id="cb16-90"><a href="#cb16-90"></a>    <span class="co">//- Change size.</span></span>
<span id="cb16-91"><a href="#cb16-91"></a>    <span class="co">//</span></span>
<span id="cb16-92"><a href="#cb16-92"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> ET2 <span class="op">=</span> ET, detail<span class="op">::</span>enable_if_resizable<span class="op">&lt;</span>ET, ET2<span class="op">&gt;</span> <span class="op">=</span> <span class="kw">true</span><span class="op">&gt;</span></span>
<span id="cb16-93"><a href="#cb16-93"></a>    <span class="kw">constexpr</span> <span class="dt">void</span>      resize<span class="op">(</span>size_tuple size<span class="op">)</span>;</span>
<span id="cb16-94"><a href="#cb16-94"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> ET2 <span class="op">=</span> ET, detail<span class="op">::</span>enable_if_resizable<span class="op">&lt;</span>ET, ET2<span class="op">&gt;</span> <span class="op">=</span> <span class="kw">true</span><span class="op">&gt;</span></span>
<span id="cb16-95"><a href="#cb16-95"></a>    <span class="kw">constexpr</span> <span class="dt">void</span>      resize<span class="op">(</span>size_type rows, size_type cols<span class="op">)</span>;</span>
<span id="cb16-96"><a href="#cb16-96"></a></span>
<span id="cb16-97"><a href="#cb16-97"></a>    <span class="co">//- Change size and capacity in one shot.</span></span>
<span id="cb16-98"><a href="#cb16-98"></a>    <span class="co">//</span></span>
<span id="cb16-99"><a href="#cb16-99"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> ET2 <span class="op">=</span> ET, detail<span class="op">::</span>enable_if_resizable<span class="op">&lt;</span>ET, ET2<span class="op">&gt;</span> <span class="op">=</span> <span class="kw">true</span><span class="op">&gt;</span></span>
<span id="cb16-100"><a href="#cb16-100"></a>    <span class="kw">constexpr</span> <span class="dt">void</span>      resize<span class="op">(</span>size_tuple size, size_tuple cap<span class="op">)</span>;</span>
<span id="cb16-101"><a href="#cb16-101"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> ET2 <span class="op">=</span> ET, detail<span class="op">::</span>enable_if_resizable<span class="op">&lt;</span>ET, ET2<span class="op">&gt;</span> <span class="op">=</span> <span class="kw">true</span><span class="op">&gt;</span></span>
<span id="cb16-102"><a href="#cb16-102"></a>    <span class="kw">constexpr</span> <span class="dt">void</span>      resize<span class="op">(</span>size_type rows, size_type cols, </span>
<span id="cb16-103"><a href="#cb16-103"></a>                               size_type rowcap, size_type colcap<span class="op">)</span>;</span>
<span id="cb16-104"><a href="#cb16-104"></a></span>
<span id="cb16-105"><a href="#cb16-105"></a>    <span class="co">//- Swapping operations.</span></span>
<span id="cb16-106"><a href="#cb16-106"></a>    <span class="co">//</span></span>
<span id="cb16-107"><a href="#cb16-107"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> ET2 <span class="op">=</span> ET, detail<span class="op">::</span>enable_if_mutable<span class="op">&lt;</span>ET, ET2<span class="op">&gt;</span> <span class="op">=</span> <span class="kw">true</span><span class="op">&gt;</span></span>
<span id="cb16-108"><a href="#cb16-108"></a>    <span class="kw">constexpr</span> <span class="dt">void</span>      swap<span class="op">(</span>matrix<span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">noexcept</span>;</span>
<span id="cb16-109"><a href="#cb16-109"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> ET2 <span class="op">=</span> ET, detail<span class="op">::</span>enable_if_mutable<span class="op">&lt;</span>ET, ET2<span class="op">&gt;</span> <span class="op">=</span> <span class="kw">true</span><span class="op">&gt;</span></span>
<span id="cb16-110"><a href="#cb16-110"></a>    <span class="kw">constexpr</span> <span class="dt">void</span>      swap_columns<span class="op">(</span>index_type i, index_type j<span class="op">)</span> <span class="kw">noexcept</span>;</span>
<span id="cb16-111"><a href="#cb16-111"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> ET2 <span class="op">=</span> ET, detail<span class="op">::</span>enable_if_mutable<span class="op">&lt;</span>ET, ET2<span class="op">&gt;</span> <span class="op">=</span> <span class="kw">true</span><span class="op">&gt;</span></span>
<span id="cb16-112"><a href="#cb16-112"></a>    <span class="kw">constexpr</span> <span class="dt">void</span>      swap_rows<span class="op">(</span>index_type i, index_type j<span class="op">)</span> <span class="kw">noexcept</span>;</span>
<span id="cb16-113"><a href="#cb16-113"></a><span class="op">}</span>;</span></code></pre></div>
<h2 id="operation-traits"><span class="header-section-number">6.7</span> Operation traits<a href="#operation-traits" class="self-link"></a></h2>
<h3 id="matrix_operation_traits"><span class="header-section-number">6.7.1</span> <code>matrix_operation_traits</code><a href="#matrix_operation_traits" class="self-link"></a></h3>
<p>Class <code>matrix_operation_traits</code> is a traits-style template parameter to <code>vector</code> and <code>matrix</code>. Its purpose is to associate sets of element promotion traits, engine promotion traits, and arithmetic traits with a <em>MathObj</em> so that those traits may be conveyed into an arithmetic operator.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1"></a><span class="kw">struct</span> matrix_operation_traits</span>
<span id="cb17-2"><a href="#cb17-2"></a><span class="op">{</span></span>
<span id="cb17-3"><a href="#cb17-3"></a>    <span class="co">//- Default element promotion traits.</span></span>
<span id="cb17-4"><a href="#cb17-4"></a>    <span class="co">//</span></span>
<span id="cb17-5"><a href="#cb17-5"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T1<span class="op">&gt;</span></span>
<span id="cb17-6"><a href="#cb17-6"></a>    <span class="kw">using</span> element_negation_traits <span class="op">=</span> matrix_negation_element_traits<span class="op">&lt;</span>T1<span class="op">&gt;</span>;</span>
<span id="cb17-7"><a href="#cb17-7"></a></span>
<span id="cb17-8"><a href="#cb17-8"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T1, <span class="kw">class</span> T2<span class="op">&gt;</span></span>
<span id="cb17-9"><a href="#cb17-9"></a>    <span class="kw">using</span> element_addition_traits <span class="op">=</span> matrix_addition_element_traits<span class="op">&lt;</span>T1, T2<span class="op">&gt;</span>;</span>
<span id="cb17-10"><a href="#cb17-10"></a></span>
<span id="cb17-11"><a href="#cb17-11"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T1, <span class="kw">class</span> T2<span class="op">&gt;</span></span>
<span id="cb17-12"><a href="#cb17-12"></a>    <span class="kw">using</span> element_subtraction_traits <span class="op">=</span> matrix_subtraction_element_traits<span class="op">&lt;</span>T1, T2<span class="op">&gt;</span>;</span>
<span id="cb17-13"><a href="#cb17-13"></a></span>
<span id="cb17-14"><a href="#cb17-14"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T1, <span class="kw">class</span> T2<span class="op">&gt;</span></span>
<span id="cb17-15"><a href="#cb17-15"></a>    <span class="kw">using</span> element_multiplication_traits <span class="op">=</span> matrix_multiplication_element_traits<span class="op">&lt;</span>T1, T2<span class="op">&gt;</span>;</span>
<span id="cb17-16"><a href="#cb17-16"></a></span>
<span id="cb17-17"><a href="#cb17-17"></a>    <span class="co">//- Default engine promotion traits.</span></span>
<span id="cb17-18"><a href="#cb17-18"></a>    <span class="co">//</span></span>
<span id="cb17-19"><a href="#cb17-19"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> OTR, <span class="kw">class</span> ET1<span class="op">&gt;</span></span>
<span id="cb17-20"><a href="#cb17-20"></a>    <span class="kw">using</span> engine_negation_traits <span class="op">=</span> matrix_negation_engine_traits<span class="op">&lt;</span>OTR, ET1<span class="op">&gt;</span>;</span>
<span id="cb17-21"><a href="#cb17-21"></a></span>
<span id="cb17-22"><a href="#cb17-22"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> OTR, <span class="kw">class</span> ET1, <span class="kw">class</span> ET2<span class="op">&gt;</span></span>
<span id="cb17-23"><a href="#cb17-23"></a>    <span class="kw">using</span> engine_addition_traits <span class="op">=</span> matrix_addition_engine_traits<span class="op">&lt;</span>OTR, ET1, ET2<span class="op">&gt;</span>;</span>
<span id="cb17-24"><a href="#cb17-24"></a></span>
<span id="cb17-25"><a href="#cb17-25"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> OTR, <span class="kw">class</span> ET1, <span class="kw">class</span> ET2<span class="op">&gt;</span></span>
<span id="cb17-26"><a href="#cb17-26"></a>    <span class="kw">using</span> engine_subtraction_traits <span class="op">=</span> matrix_subtraction_engine_traits<span class="op">&lt;</span>OTR, ET1, ET2<span class="op">&gt;</span>;</span>
<span id="cb17-27"><a href="#cb17-27"></a></span>
<span id="cb17-28"><a href="#cb17-28"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> OTR, <span class="kw">class</span> ET1, <span class="kw">class</span> ET2<span class="op">&gt;</span></span>
<span id="cb17-29"><a href="#cb17-29"></a>    <span class="kw">using</span> engine_multiplication_traits <span class="op">=</span> matrix_multiplication_engine_traits<span class="op">&lt;</span>OTR, ET1, ET2<span class="op">&gt;</span>;</span>
<span id="cb17-30"><a href="#cb17-30"></a></span>
<span id="cb17-31"><a href="#cb17-31"></a>    <span class="co">//- Default arithmetic operation traits.</span></span>
<span id="cb17-32"><a href="#cb17-32"></a>    <span class="co">//</span></span>
<span id="cb17-33"><a href="#cb17-33"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> OP1, <span class="kw">class</span> OTR<span class="op">&gt;</span></span>
<span id="cb17-34"><a href="#cb17-34"></a>    <span class="kw">using</span> negation_traits <span class="op">=</span> matrix_negation_traits<span class="op">&lt;</span>OP1, OTR<span class="op">&gt;</span>;</span>
<span id="cb17-35"><a href="#cb17-35"></a></span>
<span id="cb17-36"><a href="#cb17-36"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> OTR, <span class="kw">class</span> OP1, <span class="kw">class</span> OP2<span class="op">&gt;</span></span>
<span id="cb17-37"><a href="#cb17-37"></a>    <span class="kw">using</span> addition_traits <span class="op">=</span> matrix_addition_traits<span class="op">&lt;</span>OTR, OP1, OP2<span class="op">&gt;</span>;</span>
<span id="cb17-38"><a href="#cb17-38"></a></span>
<span id="cb17-39"><a href="#cb17-39"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> OTR, <span class="kw">class</span> OP1, <span class="kw">class</span> OP2<span class="op">&gt;</span></span>
<span id="cb17-40"><a href="#cb17-40"></a>    <span class="kw">using</span> subtraction_traits <span class="op">=</span> matrix_subtraction_traits<span class="op">&lt;</span>OTR, OP1, OP2<span class="op">&gt;</span>;</span>
<span id="cb17-41"><a href="#cb17-41"></a></span>
<span id="cb17-42"><a href="#cb17-42"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> OTR, <span class="kw">class</span> OP1, <span class="kw">class</span> OP2<span class="op">&gt;</span></span>
<span id="cb17-43"><a href="#cb17-43"></a>    <span class="kw">using</span> multiplication_traits <span class="op">=</span> matrix_multiplication_traits<span class="op">&lt;</span>OTR, OP1, OP2<span class="op">&gt;</span>;</span>
<span id="cb17-44"><a href="#cb17-44"></a><span class="op">}</span>;</span></code></pre></div>
<p>This traits type is a customization point. Users may override the default functionality it provides by creating a custom operation traits class in their own namespace, and defining only those members necessary to implement the desired custom behavior.</p>
<h3 id="matrix_operation_traits_selectorot1-ot2"><span class="header-section-number">6.7.2</span> <code>matrix_operation_traits_selector&lt;OT1, OT2&gt;</code><a href="#matrix_operation_traits_selectorot1-ot2" class="self-link"></a></h3>
<p>Class template <code>matrix_operation_traits_selector&lt;OT1, OT2&gt;</code> is used by the binary arithmetic operators to select the operation traits type to used in performing an arithmetic operation. The selection is based on the operation traits types of the two operands.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1"></a><span class="co">//- Primary template and expected specializations.</span></span>
<span id="cb18-2"><a href="#cb18-2"></a><span class="co">//</span></span>
<span id="cb18-3"><a href="#cb18-3"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T1, <span class="kw">class</span> T2<span class="op">&gt;</span></span>
<span id="cb18-4"><a href="#cb18-4"></a><span class="kw">struct</span> matrix_operation_traits_selector;</span>
<span id="cb18-5"><a href="#cb18-5"></a></span>
<span id="cb18-6"><a href="#cb18-6"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T1<span class="op">&gt;</span></span>
<span id="cb18-7"><a href="#cb18-7"></a><span class="kw">struct</span> matrix_operation_traits_selector<span class="op">&lt;</span>T1, T1<span class="op">&gt;</span></span>
<span id="cb18-8"><a href="#cb18-8"></a><span class="op">{</span></span>
<span id="cb18-9"><a href="#cb18-9"></a>    <span class="kw">using</span> traits_type <span class="op">=</span> T1;</span>
<span id="cb18-10"><a href="#cb18-10"></a><span class="op">}</span>;</span>
<span id="cb18-11"><a href="#cb18-11"></a></span>
<span id="cb18-12"><a href="#cb18-12"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T1<span class="op">&gt;</span></span>
<span id="cb18-13"><a href="#cb18-13"></a><span class="kw">struct</span> matrix_operation_traits_selector<span class="op">&lt;</span>T1, matrix_operation_traits<span class="op">&gt;</span></span>
<span id="cb18-14"><a href="#cb18-14"></a><span class="op">{</span></span>
<span id="cb18-15"><a href="#cb18-15"></a>    <span class="kw">using</span> traits_type <span class="op">=</span> T1;</span>
<span id="cb18-16"><a href="#cb18-16"></a><span class="op">}</span>;</span>
<span id="cb18-17"><a href="#cb18-17"></a></span>
<span id="cb18-18"><a href="#cb18-18"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T1<span class="op">&gt;</span></span>
<span id="cb18-19"><a href="#cb18-19"></a><span class="kw">struct</span> matrix_operation_traits_selector<span class="op">&lt;</span>matrix_operation_traits, T1<span class="op">&gt;</span></span>
<span id="cb18-20"><a href="#cb18-20"></a><span class="op">{</span></span>
<span id="cb18-21"><a href="#cb18-21"></a>    <span class="kw">using</span> traits_type <span class="op">=</span> T1;</span>
<span id="cb18-22"><a href="#cb18-22"></a><span class="op">}</span>;</span>
<span id="cb18-23"><a href="#cb18-23"></a></span>
<span id="cb18-24"><a href="#cb18-24"></a><span class="kw">template</span><span class="op">&lt;&gt;</span></span>
<span id="cb18-25"><a href="#cb18-25"></a><span class="kw">struct</span> matrix_operation_traits_selector<span class="op">&lt;</span>matrix_operation_traits, matrix_operation_traits<span class="op">&gt;</span></span>
<span id="cb18-26"><a href="#cb18-26"></a><span class="op">{</span></span>
<span id="cb18-27"><a href="#cb18-27"></a>    <span class="kw">using</span> traits_type <span class="op">=</span> matrix_operation_traits;</span>
<span id="cb18-28"><a href="#cb18-28"></a><span class="op">}</span>;</span>
<span id="cb18-29"><a href="#cb18-29"></a></span>
<span id="cb18-30"><a href="#cb18-30"></a><span class="co">//- Convenience alias.</span></span>
<span id="cb18-31"><a href="#cb18-31"></a><span class="co">//</span></span>
<span id="cb18-32"><a href="#cb18-32"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T1, <span class="kw">class</span> T2<span class="op">&gt;</span></span>
<span id="cb18-33"><a href="#cb18-33"></a><span class="kw">using</span> matrix_operation_traits_selector_t <span class="op">=</span> </span>
<span id="cb18-34"><a href="#cb18-34"></a>        <span class="kw">typename</span> matrix_operation_traits_selector<span class="op">&lt;</span>T1, T2<span class="op">&gt;::</span>traits_type;</span></code></pre></div>
<h2 id="element-promotion-traits"><span class="header-section-number">6.8</span> Element promotion traits<a href="#element-promotion-traits" class="self-link"></a></h2>
<p>Element promotion traits are used by the library to determine the resulting element type of an arithmetical expression having one or two <em>MathObj</em> operands.</p>
<h3 id="matrix_negation_element_traitst1"><span class="header-section-number">6.8.1</span> <code>matrix_negation_element_traits&lt;T1&gt;</code><a href="#matrix_negation_element_traitst1" class="self-link"></a></h3>
<p>Class template <code>matrix_negation_element_traits&lt;T1&gt;</code> implements the default traits type for determining the element type of the <em>MathObj</em> instance resulting from negating a given <em>MathObj</em> instance.</p>
<p>Alias template <code>matrix_negation_element_t&lt;OT, T1, T2&gt;</code> is used by the library to return the nested type <code>OT::element_negation_traits&lt;T1&gt;</code>.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T1<span class="op">&gt;</span></span>
<span id="cb19-2"><a href="#cb19-2"></a><span class="kw">struct</span> matrix_negation_element_traits</span>
<span id="cb19-3"><a href="#cb19-3"></a><span class="op">{</span></span>
<span id="cb19-4"><a href="#cb19-4"></a>    <span class="kw">using</span> element_type <span class="op">=</span> <span class="kw">decltype</span><span class="op">(-</span>declval<span class="op">&lt;</span>T1<span class="op">&gt;())</span>;</span>
<span id="cb19-5"><a href="#cb19-5"></a><span class="op">}</span>;</span>
<span id="cb19-6"><a href="#cb19-6"></a></span>
<span id="cb19-7"><a href="#cb19-7"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> OT, <span class="kw">class</span> T1<span class="op">&gt;</span></span>
<span id="cb19-8"><a href="#cb19-8"></a><span class="kw">using</span> matrix_negation_element_t <span class="op">=</span> <span class="op">...</span>;          <span class="co">//- Implementation-defined</span></span></code></pre></div>
<h3 id="matrix_addition_element_traitst1-t2"><span class="header-section-number">6.8.2</span> <code>matrix_addition_element_traits&lt;T1, T2&gt;</code><a href="#matrix_addition_element_traitst1-t2" class="self-link"></a></h3>
<p>Class template <code>matrix_addition_element_traits&lt;T1, T2&gt;</code> implements the default traits type for determining the element type of a <em>MathObj</em> instance resulting from the addition of two other <em>MathOb</em> instances.</p>
<p>Alias template <code>matrix_addition_element_t&lt;OT, T1, T2&gt;</code> is used by the library to obtain the nested type <code>OT::element_addition_traits&lt;T1, T2&gt;</code>.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T1, <span class="kw">class</span> T2<span class="op">&gt;</span></span>
<span id="cb20-2"><a href="#cb20-2"></a><span class="kw">struct</span> matrix_addition_element_traits</span>
<span id="cb20-3"><a href="#cb20-3"></a><span class="op">{</span></span>
<span id="cb20-4"><a href="#cb20-4"></a>    <span class="kw">using</span> element_type <span class="op">=</span> <span class="kw">decltype</span><span class="op">(</span>declval<span class="op">&lt;</span>T1<span class="op">&gt;()</span> <span class="op">+</span> declval<span class="op">&lt;</span>T2<span class="op">&gt;())</span>;</span>
<span id="cb20-5"><a href="#cb20-5"></a><span class="op">}</span>;</span>
<span id="cb20-6"><a href="#cb20-6"></a></span>
<span id="cb20-7"><a href="#cb20-7"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> OT, <span class="kw">class</span> T1, <span class="kw">class</span> T2<span class="op">&gt;</span></span>
<span id="cb20-8"><a href="#cb20-8"></a><span class="kw">using</span> matrix_addition_element_t <span class="op">=</span> <span class="op">...</span>;          <span class="co">//- Implementation-defined</span></span></code></pre></div>
<h3 id="matrix_subtraction_element_traitst1-t2"><span class="header-section-number">6.8.3</span> <code>matrix_subtraction_element_traits&lt;T1, T2&gt;</code><a href="#matrix_subtraction_element_traitst1-t2" class="self-link"></a></h3>
<p>Class template <code>matrix_subtraction_element_traits&lt;T1, T2&gt;</code> implements the default traits type for determining the element type of a <em>MathObj</em> instance resulting from the subtraction of two other <em>MathOb</em> instances.</p>
<p>Alias template <code>matrix_subtraction_element_t&lt;OT, T1, T2&gt;</code> is used by the library to obtain the nested type <code>OT::element_subtraction_traits&lt;T1, T2&gt;</code>.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T1, <span class="kw">class</span> T2<span class="op">&gt;</span></span>
<span id="cb21-2"><a href="#cb21-2"></a><span class="kw">struct</span> matrix_subtraction_element_traits</span>
<span id="cb21-3"><a href="#cb21-3"></a><span class="op">{</span></span>
<span id="cb21-4"><a href="#cb21-4"></a>    <span class="kw">using</span> element_type <span class="op">=</span> <span class="kw">decltype</span><span class="op">(</span>declval<span class="op">&lt;</span>T1<span class="op">&gt;()</span> <span class="op">-</span> declval<span class="op">&lt;</span>T2<span class="op">&gt;())</span>;</span>
<span id="cb21-5"><a href="#cb21-5"></a><span class="op">}</span>;</span>
<span id="cb21-6"><a href="#cb21-6"></a></span>
<span id="cb21-7"><a href="#cb21-7"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> OT, <span class="kw">class</span> T1, <span class="kw">class</span> T2<span class="op">&gt;</span></span>
<span id="cb21-8"><a href="#cb21-8"></a><span class="kw">using</span> matrix_subtraction_element_t <span class="op">=</span> <span class="op">...</span>;       <span class="co">//- Implementation-defined</span></span></code></pre></div>
<h3 id="matrix_multiplication_element_traitst1-t2"><span class="header-section-number">6.8.4</span> <code>matrix_multiplication_element_traits&lt;T1, T2&gt;</code><a href="#matrix_multiplication_element_traitst1-t2" class="self-link"></a></h3>
<p>Class template <code>matrix_multiplication_element_traits&lt;T1, T2&gt;</code> implements the default traits type for determining the element type of a <em>MathObj</em> instance resulting from the multiplication of two other <em>MathOb</em> instances.</p>
<p>Alias template <code>matrix_multiplication_element_t&lt;OT, T1, T2&gt;</code> is used by the library to obtain the nested type <code>OT::element_multiplication_traits&lt;T1, T2&gt;</code>.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb22-1"><a href="#cb22-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T1, <span class="kw">class</span> T2<span class="op">&gt;</span></span>
<span id="cb22-2"><a href="#cb22-2"></a><span class="kw">struct</span> matrix_multiplication_element_traits</span>
<span id="cb22-3"><a href="#cb22-3"></a><span class="op">{</span></span>
<span id="cb22-4"><a href="#cb22-4"></a>    <span class="kw">using</span> element_type <span class="op">=</span> <span class="kw">decltype</span><span class="op">(</span>declval<span class="op">&lt;</span>T1<span class="op">&gt;()</span> <span class="op">*</span> declval<span class="op">&lt;</span>T2<span class="op">&gt;())</span>;</span>
<span id="cb22-5"><a href="#cb22-5"></a><span class="op">}</span>;</span>
<span id="cb22-6"><a href="#cb22-6"></a></span>
<span id="cb22-7"><a href="#cb22-7"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> OT, <span class="kw">class</span> T1, <span class="kw">class</span> T2<span class="op">&gt;</span></span>
<span id="cb22-8"><a href="#cb22-8"></a><span class="kw">using</span> matrix_multiplication_element_t <span class="op">=</span> <span class="op">...</span>;    <span class="co">//- Implementation-defined</span></span></code></pre></div>
<h2 id="engine-promotion-traits"><span class="header-section-number">6.9</span> Engine promotion traits<a href="#engine-promotion-traits" class="self-link"></a></h2>
<p>Engine promotion traits are used by the arithmetic traits to determine the resulting engine types in an arithmetical expression.</p>
<h3 id="matrix_negation_engine_traitsot-et1"><span class="header-section-number">6.9.1</span> <code>matrix_negation_engine_traits&lt;OT, ET1&gt;</code><a href="#matrix_negation_engine_traitsot-et1" class="self-link"></a></h3>
<p>Class template <code>matrix_negation_engine_traits&lt;OT, ET1&gt;</code> implements a traits type that determines the resulting engine type when negating a <em>MathObj</em>.</p>
<p>Alias template <code>matrix_negation_engine_t&lt;OT, ET1&gt;</code> is used by the library to obtain the nested type <code>OT::engine_negation_traits&lt;ET1&gt;</code>.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb23-1"><a href="#cb23-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> OT, <span class="kw">class</span> ET1<span class="op">&gt;</span></span>
<span id="cb23-2"><a href="#cb23-2"></a><span class="kw">struct</span> matrix_negation_engine_traits</span>
<span id="cb23-3"><a href="#cb23-3"></a><span class="op">{</span></span>
<span id="cb23-4"><a href="#cb23-4"></a>    <span class="kw">using</span> element_type <span class="op">=</span> matrix_negation_element_t<span class="op">&lt;</span>OT, <span class="kw">typename</span> ET1<span class="op">::</span>element_type<span class="op">&gt;</span>;</span>
<span id="cb23-5"><a href="#cb23-5"></a></span>
<span id="cb23-6"><a href="#cb23-6"></a>    <span class="kw">using</span> engine_type  <span class="op">=</span> <span class="op">...</span>;                   <span class="co">//- Implementation-defined</span></span>
<span id="cb23-7"><a href="#cb23-7"></a><span class="op">}</span>;</span>
<span id="cb23-8"><a href="#cb23-8"></a></span>
<span id="cb23-9"><a href="#cb23-9"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> OT, <span class="kw">class</span> ET1<span class="op">&gt;</span></span>
<span id="cb23-10"><a href="#cb23-10"></a><span class="kw">using</span> matrix_negation_engine_t <span class="op">=</span> <span class="op">...</span>;           <span class="co">//- Implementation-defined</span></span></code></pre></div>
<h3 id="matrix_addition_engine_traitsot-et1-et2"><span class="header-section-number">6.9.2</span> <code>matrix_addition_engine_traits&lt;OT, ET1, ET2&gt;</code><a href="#matrix_addition_engine_traitsot-et1-et2" class="self-link"></a></h3>
<p>Class template <code>matrix_addition_engine_traits&lt;OT, ET1, ET2</code> implements a traits type that determines the resulting engine type when adding two compatible <em>MathObj</em>s.</p>
<p>Alias template <code>matrix_addition_engine_t&lt;OT, ET1, ET2&gt;</code> is used by the library to obtain the nested type <code>OT::element_addition_traits&lt;ET1, ET2&gt;</code>.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb24-1"><a href="#cb24-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> OT, <span class="kw">class</span> ET1, <span class="kw">class</span> ET2<span class="op">&gt;</span></span>
<span id="cb24-2"><a href="#cb24-2"></a><span class="kw">struct</span> matrix_addition_engine_traits</span>
<span id="cb24-3"><a href="#cb24-3"></a><span class="op">{</span></span>
<span id="cb24-4"><a href="#cb24-4"></a>    <span class="kw">using</span> element_type <span class="op">=</span> matrix_addition_element_t<span class="op">&lt;</span>OT, </span>
<span id="cb24-5"><a href="#cb24-5"></a>                                                   <span class="kw">typename</span> ET1<span class="op">::</span>element_type, </span>
<span id="cb24-6"><a href="#cb24-6"></a>                                                   <span class="kw">typename</span> ET2<span class="op">::</span>element_type<span class="op">&gt;</span>;</span>
<span id="cb24-7"><a href="#cb24-7"></a></span>
<span id="cb24-8"><a href="#cb24-8"></a>    <span class="kw">using</span> engine_type  <span class="op">=</span> <span class="op">...</span>;                   <span class="co">//- Implementation-defined</span></span>
<span id="cb24-9"><a href="#cb24-9"></a><span class="op">}</span>;</span>
<span id="cb24-10"><a href="#cb24-10"></a></span>
<span id="cb24-11"><a href="#cb24-11"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> OT, <span class="kw">class</span> ET1, <span class="kw">class</span> ET2<span class="op">&gt;</span></span>
<span id="cb24-12"><a href="#cb24-12"></a><span class="kw">using</span> matrix_addition_engine_t <span class="op">=</span> detail<span class="op">::</span>engine_add_type_t<span class="op">&lt;</span>OT, ET1, ET2<span class="op">&gt;</span>;</span></code></pre></div>
<h3 id="matrix_subtraction_engine_traitsot-et1-et2"><span class="header-section-number">6.9.3</span> <code>matrix_subtraction_engine_traits&lt;OT, ET1, ET2&gt;</code><a href="#matrix_subtraction_engine_traitsot-et1-et2" class="self-link"></a></h3>
<p>Class template <code>matrix_subtraction_engine_traits&lt;OT, ET1, ET2</code> implements a traits type that determines the resulting engine type when subtracting two compatible <em>MathObj</em>s.</p>
<p>Alias template <code>matrix_subtraction_engine_t&lt;OT, ET1, ET2&gt;</code> is used by the library to obtain the nested type <code>OT::element_subtraction_traits&lt;ET1, ET2&gt;</code>.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb25-1"><a href="#cb25-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> OT, <span class="kw">class</span> ET1, <span class="kw">class</span> ET2<span class="op">&gt;</span></span>
<span id="cb25-2"><a href="#cb25-2"></a><span class="kw">struct</span> matrix_subtraction_engine_traits</span>
<span id="cb25-3"><a href="#cb25-3"></a><span class="op">{</span></span>
<span id="cb25-4"><a href="#cb25-4"></a>    <span class="kw">using</span> element_type <span class="op">=</span> matrix_subtraction_element_t<span class="op">&lt;</span>OT, </span>
<span id="cb25-5"><a href="#cb25-5"></a>                                                      <span class="kw">typename</span> ET1<span class="op">::</span>element_type, </span>
<span id="cb25-6"><a href="#cb25-6"></a>                                                      <span class="kw">typename</span> ET2<span class="op">::</span>element_type<span class="op">&gt;</span>;</span>
<span id="cb25-7"><a href="#cb25-7"></a></span>
<span id="cb25-8"><a href="#cb25-8"></a>    <span class="kw">using</span> engine_type  <span class="op">=</span> <span class="op">...</span>;                   <span class="co">//- Implementation-defined</span></span>
<span id="cb25-9"><a href="#cb25-9"></a><span class="op">}</span>;</span>
<span id="cb25-10"><a href="#cb25-10"></a></span>
<span id="cb25-11"><a href="#cb25-11"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> OT, <span class="kw">class</span> ET1, <span class="kw">class</span> ET2<span class="op">&gt;</span></span>
<span id="cb25-12"><a href="#cb25-12"></a><span class="kw">using</span> matrix_subtraction_engine_t <span class="op">=</span> <span class="op">...</span>;        <span class="co">//- Implementation-defined</span></span></code></pre></div>
<h3 id="matrix_multiplication_engine_traitsot-et1-et2"><span class="header-section-number">6.9.4</span> <code>matrix_multiplication_engine_traits&lt;OT, ET1, ET2&gt;</code><a href="#matrix_multiplication_engine_traitsot-et1-et2" class="self-link"></a></h3>
<p>Class template <code>matrix_multiplication_engine_traits&lt;OT, ET1, ET2</code> implements a traits type that determines the resulting engine type when multiplying two compatible <em>MathObj</em>s.</p>
<p>Alias template <code>matrix_multiplication_engine_t&lt;OT, ET1, ET2&gt;</code> is used by the library to obtain the nested type <code>OT::element_multiplication_traits&lt;ET1, ET2&gt;</code>.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb26-1"><a href="#cb26-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> OT, <span class="kw">class</span> ET1, <span class="kw">class</span> ET2<span class="op">&gt;</span></span>
<span id="cb26-2"><a href="#cb26-2"></a><span class="kw">struct</span> matrix_multiplication_engine_traits</span>
<span id="cb26-3"><a href="#cb26-3"></a><span class="op">{</span></span>
<span id="cb26-4"><a href="#cb26-4"></a>    <span class="kw">using</span> element_type <span class="op">=</span> matrix_multiplication_element_t<span class="op">&lt;</span>OT,</span>
<span id="cb26-5"><a href="#cb26-5"></a>                                                         <span class="kw">typename</span> ET1<span class="op">::</span>element_type, </span>
<span id="cb26-6"><a href="#cb26-6"></a>                                                         <span class="kw">typename</span> ET2<span class="op">::</span>element_type<span class="op">&gt;</span>;</span>
<span id="cb26-7"><a href="#cb26-7"></a></span>
<span id="cb26-8"><a href="#cb26-8"></a>    <span class="kw">using</span> engine_type  <span class="op">=</span> <span class="op">...</span>;                   <span class="co">//- Implementation-defined.</span></span>
<span id="cb26-9"><a href="#cb26-9"></a><span class="op">}</span>;</span>
<span id="cb26-10"><a href="#cb26-10"></a></span>
<span id="cb26-11"><a href="#cb26-11"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> OT, <span class="kw">class</span> ET1, <span class="kw">class</span> ET2<span class="op">&gt;</span></span>
<span id="cb26-12"><a href="#cb26-12"></a><span class="kw">using</span> matrix_multiplication_engine_t <span class="op">=</span> <span class="op">...</span>;     <span class="co">//- Implementation-defined</span></span></code></pre></div>
<h2 id="arithmetic-traits"><span class="header-section-number">6.10</span> Arithmetic traits<a href="#arithmetic-traits" class="self-link"></a></h2>
<p>This section defines a set of arithmetic traits types for negation, addition, subtraction, and multiplication. The purpose of each of these traits types is threefold:</p>
<ol type="1">
<li><p>to determine the element type of the resulting <em>MathObj</em>;</p></li>
<li><p>to determine the engine type of the resulting <em>MathObj</em>; and</p></li>
<li><p>to carry out the arithmetical operation and return its result.</p></li>
</ol>
<p>The idea here is that arithmetic operators (described below) simply forward to the appropriate traits type, which does the heavy lifting.</p>
<h3 id="matrix_negation_traitsot-op1"><span class="header-section-number">6.10.1</span> <code>matrix_negation_traits&lt;OT, OP1&gt;</code><a href="#matrix_negation_traitsot-op1" class="self-link"></a></h3>
<p>Class template <code>matrix_negation_traits&lt;OT, OP1&gt;</code> is an arithmetic traits type that performs the negation of a <em>MathObj</em> and returns the result in another <em>MathObj</em> having an implementation-defined engine type. There are two partial specializations to support the two overloaded negation operators described below.</p>
<p>Alias template <code>matrix_negation_traits_t&lt;OT, OP1&gt;</code> is used by the library to obtain the nested type <code>OT::negation_traits&lt;OP1&gt;</code>.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb27-1"><a href="#cb27-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> OT, <span class="kw">class</span> ET1, <span class="kw">class</span> OT1<span class="op">&gt;</span></span>
<span id="cb27-2"><a href="#cb27-2"></a><span class="kw">struct</span> matrix_negation_traits<span class="op">&lt;</span>OT, vector<span class="op">&lt;</span>ET1, OT1<span class="op">&gt;&gt;</span></span>
<span id="cb27-3"><a href="#cb27-3"></a><span class="op">{</span></span>
<span id="cb27-4"><a href="#cb27-4"></a>    <span class="kw">using</span> engine_type <span class="op">=</span> matrix_negation_engine_t<span class="op">&lt;</span>OT, ET1<span class="op">&gt;</span>;</span>
<span id="cb27-5"><a href="#cb27-5"></a>    <span class="kw">using</span> op_traits   <span class="op">=</span> OT;</span>
<span id="cb27-6"><a href="#cb27-6"></a>    <span class="kw">using</span> result_type <span class="op">=</span> vector<span class="op">&lt;</span>engine_type, op_traits<span class="op">&gt;</span>;</span>
<span id="cb27-7"><a href="#cb27-7"></a></span>
<span id="cb27-8"><a href="#cb27-8"></a>    <span class="kw">static</span> result_type  negate<span class="op">(</span>vector<span class="op">&lt;</span>ET1, OT1<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> v1<span class="op">)</span>;</span>
<span id="cb27-9"><a href="#cb27-9"></a><span class="op">}</span>;</span>
<span id="cb27-10"><a href="#cb27-10"></a></span>
<span id="cb27-11"><a href="#cb27-11"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> OT, <span class="kw">class</span> ET1, <span class="kw">class</span> OT1<span class="op">&gt;</span></span>
<span id="cb27-12"><a href="#cb27-12"></a><span class="kw">struct</span> matrix_negation_traits<span class="op">&lt;</span>OT, matrix<span class="op">&lt;</span>ET1, OT1<span class="op">&gt;&gt;</span></span>
<span id="cb27-13"><a href="#cb27-13"></a><span class="op">{</span></span>
<span id="cb27-14"><a href="#cb27-14"></a>    <span class="kw">using</span> engine_type <span class="op">=</span> matrix_negation_engine_t<span class="op">&lt;</span>OT, ET1<span class="op">&gt;</span>;</span>
<span id="cb27-15"><a href="#cb27-15"></a>    <span class="kw">using</span> op_traits   <span class="op">=</span> OT;</span>
<span id="cb27-16"><a href="#cb27-16"></a>    <span class="kw">using</span> result_type <span class="op">=</span> matrix<span class="op">&lt;</span>engine_type, op_traits<span class="op">&gt;</span>;</span>
<span id="cb27-17"><a href="#cb27-17"></a></span>
<span id="cb27-18"><a href="#cb27-18"></a>    <span class="kw">static</span> result_type  negate<span class="op">(</span>matrix<span class="op">&lt;</span>ET1, OT1<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> m1<span class="op">)</span>;</span>
<span id="cb27-19"><a href="#cb27-19"></a><span class="op">}</span>;</span>
<span id="cb27-20"><a href="#cb27-20"></a></span>
<span id="cb27-21"><a href="#cb27-21"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> OT, <span class="kw">class</span> OP1<span class="op">&gt;</span></span>
<span id="cb27-22"><a href="#cb27-22"></a><span class="kw">using</span> matrix_negation_traits_t <span class="op">=</span> <span class="op">...</span>;       <span class="co">//- Implementation-defined</span></span></code></pre></div>
<h3 id="matrix_addition_traitsot-op1-op2"><span class="header-section-number">6.10.2</span> <code>matrix_addition_traits&lt;OT, OP1, OP2&gt;</code><a href="#matrix_addition_traitsot-op1-op2" class="self-link"></a></h3>
<p>Class template <code>matrix_addition_traits&lt;OT, OP1, OP2&gt;</code> is an arithmetic traits type that performs the addition of two compatible <em>MathObj</em>s and returns the result in a <em>MathObj</em> having an implementation-defined engine type. There are two partial specializations to support the two overloaded addition operators described below.</p>
<p>Alias template <code>matrix_addition_traits_t&lt;OT, OP1, OP2&gt;</code> is used by the library to obtain the nested type <code>OT::addition_traits&lt;OP1, OP2&gt;</code>.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb28-1"><a href="#cb28-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> OT, <span class="kw">class</span> ET1, <span class="kw">class</span> OT1, <span class="kw">class</span> ET2, <span class="kw">class</span> OT2<span class="op">&gt;</span></span>
<span id="cb28-2"><a href="#cb28-2"></a><span class="kw">struct</span> matrix_addition_traits<span class="op">&lt;</span>OT, vector<span class="op">&lt;</span>ET1, OT1<span class="op">&gt;</span>, vector<span class="op">&lt;</span>ET2, OT2<span class="op">&gt;&gt;</span></span>
<span id="cb28-3"><a href="#cb28-3"></a><span class="op">{</span></span>
<span id="cb28-4"><a href="#cb28-4"></a>    <span class="kw">using</span> engine_type <span class="op">=</span> matrix_addition_engine_t<span class="op">&lt;</span>OT, ET1, ET2<span class="op">&gt;</span>;</span>
<span id="cb28-5"><a href="#cb28-5"></a>    <span class="kw">using</span> op_traits   <span class="op">=</span> OT;</span>
<span id="cb28-6"><a href="#cb28-6"></a>    <span class="kw">using</span> result_type <span class="op">=</span> vector<span class="op">&lt;</span>engine_type, op_traits<span class="op">&gt;</span>;</span>
<span id="cb28-7"><a href="#cb28-7"></a></span>
<span id="cb28-8"><a href="#cb28-8"></a>    <span class="kw">static</span> result_type  add<span class="op">(</span>vector<span class="op">&lt;</span>ET1, OT1<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> v1, vector<span class="op">&lt;</span>ET2, OT2<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> v2<span class="op">)</span>;</span>
<span id="cb28-9"><a href="#cb28-9"></a><span class="op">}</span>;</span>
<span id="cb28-10"><a href="#cb28-10"></a></span>
<span id="cb28-11"><a href="#cb28-11"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> OT, <span class="kw">class</span> ET1, <span class="kw">class</span> OT1, <span class="kw">class</span> ET2, <span class="kw">class</span> OT2<span class="op">&gt;</span></span>
<span id="cb28-12"><a href="#cb28-12"></a><span class="kw">struct</span> matrix_addition_traits<span class="op">&lt;</span>OT, matrix<span class="op">&lt;</span>ET1, OT1<span class="op">&gt;</span>, matrix<span class="op">&lt;</span>ET2, OT2<span class="op">&gt;&gt;</span></span>
<span id="cb28-13"><a href="#cb28-13"></a><span class="op">{</span></span>
<span id="cb28-14"><a href="#cb28-14"></a>    <span class="kw">using</span> engine_type <span class="op">=</span> matrix_addition_engine_t<span class="op">&lt;</span>OT, ET1, ET2<span class="op">&gt;</span>;</span>
<span id="cb28-15"><a href="#cb28-15"></a>    <span class="kw">using</span> op_traits   <span class="op">=</span> OT;</span>
<span id="cb28-16"><a href="#cb28-16"></a>    <span class="kw">using</span> result_type <span class="op">=</span> matrix<span class="op">&lt;</span>engine_type, op_traits<span class="op">&gt;</span>;</span>
<span id="cb28-17"><a href="#cb28-17"></a></span>
<span id="cb28-18"><a href="#cb28-18"></a>    <span class="kw">static</span> result_type  add<span class="op">(</span>matrix<span class="op">&lt;</span>ET1, OT1<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> m1, matrix<span class="op">&lt;</span>ET2, OT2<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> m2<span class="op">)</span>;</span>
<span id="cb28-19"><a href="#cb28-19"></a><span class="op">}</span>;</span>
<span id="cb28-20"><a href="#cb28-20"></a></span>
<span id="cb28-21"><a href="#cb28-21"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> OT, <span class="kw">class</span> OP1, <span class="kw">class</span> OP2<span class="op">&gt;</span></span>
<span id="cb28-22"><a href="#cb28-22"></a><span class="kw">using</span> matrix_addition_traits_t <span class="op">=</span> <span class="op">...</span>;       <span class="co">//- Implementation-defined</span></span></code></pre></div>
<h3 id="matrix_subtraction_traitsot-op1-op2"><span class="header-section-number">6.10.3</span> <code>matrix_subtraction_traits&lt;OT, OP1, OP2&gt;</code><a href="#matrix_subtraction_traitsot-op1-op2" class="self-link"></a></h3>
<p>Class template <code>matrix_subtraction_traits&lt;OT, OP1, OP2&gt;</code> is an arithmetic traits type that performs the subtraction of two compatible <em>MathObj</em>s and returns the result in a <em>MathObj</em> having an implementation-defined engine type. There are two partial specializations to support the two overloaded subtraction operators described below.</p>
<p>Alias template <code>matrix_subtraction_traits_t&lt;OT, OP1, OP2&gt;</code> is used by the library to obtain the nested type <code>OT::subtraction_traits&lt;OP1, OP2&gt;</code>.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb29-1"><a href="#cb29-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> OT, <span class="kw">class</span> ET1, <span class="kw">class</span> OT1, <span class="kw">class</span> ET2, <span class="kw">class</span> OT2<span class="op">&gt;</span></span>
<span id="cb29-2"><a href="#cb29-2"></a><span class="kw">struct</span> matrix_subtraction_traits<span class="op">&lt;</span>OT, vector<span class="op">&lt;</span>ET1, OT1<span class="op">&gt;</span>, vector<span class="op">&lt;</span>ET2, OT2<span class="op">&gt;&gt;</span></span>
<span id="cb29-3"><a href="#cb29-3"></a><span class="op">{</span></span>
<span id="cb29-4"><a href="#cb29-4"></a>    <span class="kw">using</span> engine_type <span class="op">=</span> matrix_subtraction_engine_t<span class="op">&lt;</span>OT, ET1, ET2<span class="op">&gt;</span>;</span>
<span id="cb29-5"><a href="#cb29-5"></a>    <span class="kw">using</span> op_traits   <span class="op">=</span> OT;</span>
<span id="cb29-6"><a href="#cb29-6"></a>    <span class="kw">using</span> result_type <span class="op">=</span> vector<span class="op">&lt;</span>engine_type, op_traits<span class="op">&gt;</span>;</span>
<span id="cb29-7"><a href="#cb29-7"></a></span>
<span id="cb29-8"><a href="#cb29-8"></a>    <span class="kw">static</span> result_type  subtract<span class="op">(</span>vector<span class="op">&lt;</span>ET1, OT1<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> v1, vector<span class="op">&lt;</span>ET2, OT2<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> v2<span class="op">)</span>;</span>
<span id="cb29-9"><a href="#cb29-9"></a><span class="op">}</span>;</span>
<span id="cb29-10"><a href="#cb29-10"></a></span>
<span id="cb29-11"><a href="#cb29-11"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> OT, <span class="kw">class</span> ET1, <span class="kw">class</span> OT1, <span class="kw">class</span> ET2, <span class="kw">class</span> OT2<span class="op">&gt;</span></span>
<span id="cb29-12"><a href="#cb29-12"></a><span class="kw">struct</span> matrix_subtraction_traits<span class="op">&lt;</span>OT, matrix<span class="op">&lt;</span>ET1, OT1<span class="op">&gt;</span>, matrix<span class="op">&lt;</span>ET2, OT2<span class="op">&gt;&gt;</span></span>
<span id="cb29-13"><a href="#cb29-13"></a><span class="op">{</span></span>
<span id="cb29-14"><a href="#cb29-14"></a>    <span class="kw">using</span> engine_type <span class="op">=</span> matrix_subtraction_engine_t<span class="op">&lt;</span>OT, ET1, ET2<span class="op">&gt;</span>;</span>
<span id="cb29-15"><a href="#cb29-15"></a>    <span class="kw">using</span> op_traits   <span class="op">=</span> OT;</span>
<span id="cb29-16"><a href="#cb29-16"></a>    <span class="kw">using</span> result_type <span class="op">=</span> matrix<span class="op">&lt;</span>engine_type, op_traits<span class="op">&gt;</span>;</span>
<span id="cb29-17"><a href="#cb29-17"></a></span>
<span id="cb29-18"><a href="#cb29-18"></a>    <span class="kw">static</span> result_type  subtract<span class="op">(</span>matrix<span class="op">&lt;</span>ET1, OT1<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> m1, matrix<span class="op">&lt;</span>ET2, OT2<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> m2<span class="op">)</span>;</span>
<span id="cb29-19"><a href="#cb29-19"></a><span class="op">}</span>;</span>
<span id="cb29-20"><a href="#cb29-20"></a></span>
<span id="cb29-21"><a href="#cb29-21"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> OT, <span class="kw">class</span> OP1, <span class="kw">class</span> OP2<span class="op">&gt;</span></span>
<span id="cb29-22"><a href="#cb29-22"></a><span class="kw">using</span> matrix_subtraction_traits_t <span class="op">=</span> <span class="op">...</span>;        <span class="co">//- Implementation-defined</span></span></code></pre></div>
<h3 id="matrix_multiplication_traitsot-op1-op2"><span class="header-section-number">6.10.4</span> <code>matrix_multiplication_traits&lt;OT, OP1, OP2&gt;</code><a href="#matrix_multiplication_traitsot-op1-op2" class="self-link"></a></h3>
<p>Class template <code>matrix_multiplication_traits&lt;OT, OP1, OP2&gt;</code> is an arithmetic traits type that performs the multiplication of two compatible <em>MathObj</em>s and returns the result in a <em>MathObj</em> having an implementation-defined engine type. There are eight partial specializations to support the eight binary multiplication operators described below.</p>
<p>Alias template <code>matrix_multiplication_traits_t&lt;OT, OP1, OP2&gt;</code> is used by the library to obtain the nested type <code>OT::multiplication_traits&lt;OP1, OP2&gt;</code>.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb30-1"><a href="#cb30-1"></a><span class="co">//- vector*scalar</span></span>
<span id="cb30-2"><a href="#cb30-2"></a><span class="co">//</span></span>
<span id="cb30-3"><a href="#cb30-3"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> OT, <span class="kw">class</span> ET1, <span class="kw">class</span> OT1, <span class="kw">class</span> T2<span class="op">&gt;</span></span>
<span id="cb30-4"><a href="#cb30-4"></a><span class="kw">struct</span> matrix_multiplication_traits<span class="op">&lt;</span>OT, vector<span class="op">&lt;</span>ET1, OT1<span class="op">&gt;</span>, T2<span class="op">&gt;</span></span>
<span id="cb30-5"><a href="#cb30-5"></a><span class="op">{</span></span>
<span id="cb30-6"><a href="#cb30-6"></a>    <span class="kw">using</span> scalar_type <span class="op">=</span> detail<span class="op">::</span>element_tag<span class="op">&lt;</span>T2<span class="op">&gt;</span>;</span>
<span id="cb30-7"><a href="#cb30-7"></a>    <span class="kw">using</span> engine_type <span class="op">=</span> matrix_multiplication_engine_t<span class="op">&lt;</span>OT, ET1, scalar_type<span class="op">&gt;</span>;</span>
<span id="cb30-8"><a href="#cb30-8"></a>    <span class="kw">using</span> op_traits   <span class="op">=</span> OT;</span>
<span id="cb30-9"><a href="#cb30-9"></a>    <span class="kw">using</span> result_type <span class="op">=</span> vector<span class="op">&lt;</span>engine_type, op_traits<span class="op">&gt;</span>;</span>
<span id="cb30-10"><a href="#cb30-10"></a></span>
<span id="cb30-11"><a href="#cb30-11"></a>    <span class="kw">static</span> result_type  multiply<span class="op">(</span>vector<span class="op">&lt;</span>ET1, OT1<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> v1, T2 <span class="kw">const</span><span class="op">&amp;</span> s2<span class="op">)</span>;</span>
<span id="cb30-12"><a href="#cb30-12"></a><span class="op">}</span>;</span>
<span id="cb30-13"><a href="#cb30-13"></a></span>
<span id="cb30-14"><a href="#cb30-14"></a><span class="co">//- scalar*vector</span></span>
<span id="cb30-15"><a href="#cb30-15"></a><span class="co">//</span></span>
<span id="cb30-16"><a href="#cb30-16"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> OT, <span class="kw">class</span> T1, <span class="kw">class</span> ET2, <span class="kw">class</span> OT2<span class="op">&gt;</span></span>
<span id="cb30-17"><a href="#cb30-17"></a><span class="kw">struct</span> matrix_multiplication_traits<span class="op">&lt;</span>OT, T1, vector<span class="op">&lt;</span>ET2, OT2<span class="op">&gt;&gt;</span></span>
<span id="cb30-18"><a href="#cb30-18"></a><span class="op">{</span></span>
<span id="cb30-19"><a href="#cb30-19"></a>    <span class="kw">using</span> scalar_type <span class="op">=</span> detail<span class="op">::</span>element_tag<span class="op">&lt;</span>T1<span class="op">&gt;</span>;</span>
<span id="cb30-20"><a href="#cb30-20"></a>    <span class="kw">using</span> engine_type <span class="op">=</span> matrix_multiplication_engine_t<span class="op">&lt;</span>OT, scalar_type, ET2<span class="op">&gt;</span>;</span>
<span id="cb30-21"><a href="#cb30-21"></a>    <span class="kw">using</span> op_traits   <span class="op">=</span> OT;</span>
<span id="cb30-22"><a href="#cb30-22"></a>    <span class="kw">using</span> result_type <span class="op">=</span> vector<span class="op">&lt;</span>engine_type, op_traits<span class="op">&gt;</span>;</span>
<span id="cb30-23"><a href="#cb30-23"></a></span>
<span id="cb30-24"><a href="#cb30-24"></a>    <span class="kw">static</span> result_type  multiply<span class="op">(</span>T1 <span class="kw">const</span><span class="op">&amp;</span> s1, vector<span class="op">&lt;</span>ET2, OT2<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> v2<span class="op">)</span>;</span>
<span id="cb30-25"><a href="#cb30-25"></a><span class="op">}</span>;</span>
<span id="cb30-26"><a href="#cb30-26"></a></span>
<span id="cb30-27"><a href="#cb30-27"></a><span class="co">//- matrix*scalar</span></span>
<span id="cb30-28"><a href="#cb30-28"></a><span class="co">//</span></span>
<span id="cb30-29"><a href="#cb30-29"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> OT, <span class="kw">class</span> ET1, <span class="kw">class</span> OT1, <span class="kw">class</span> T2<span class="op">&gt;</span></span>
<span id="cb30-30"><a href="#cb30-30"></a><span class="kw">struct</span> matrix_multiplication_traits<span class="op">&lt;</span>OT, matrix<span class="op">&lt;</span>ET1, OT1<span class="op">&gt;</span>, T2<span class="op">&gt;</span></span>
<span id="cb30-31"><a href="#cb30-31"></a><span class="op">{</span></span>
<span id="cb30-32"><a href="#cb30-32"></a>    <span class="kw">using</span> scalar_type <span class="op">=</span> detail<span class="op">::</span>element_tag<span class="op">&lt;</span>T2<span class="op">&gt;</span>;</span>
<span id="cb30-33"><a href="#cb30-33"></a>    <span class="kw">using</span> engine_type <span class="op">=</span> matrix_multiplication_engine_t<span class="op">&lt;</span>OT, ET1, scalar_type<span class="op">&gt;</span>;</span>
<span id="cb30-34"><a href="#cb30-34"></a>    <span class="kw">using</span> op_traits   <span class="op">=</span> OT;</span>
<span id="cb30-35"><a href="#cb30-35"></a>    <span class="kw">using</span> result_type <span class="op">=</span> matrix<span class="op">&lt;</span>engine_type, op_traits<span class="op">&gt;</span>;</span>
<span id="cb30-36"><a href="#cb30-36"></a></span>
<span id="cb30-37"><a href="#cb30-37"></a>    <span class="kw">static</span> result_type  multiply<span class="op">(</span>matrix<span class="op">&lt;</span>ET1, OT1<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> m1, T2 <span class="kw">const</span><span class="op">&amp;</span> s2<span class="op">)</span>;</span>
<span id="cb30-38"><a href="#cb30-38"></a><span class="op">}</span>;</span>
<span id="cb30-39"><a href="#cb30-39"></a></span>
<span id="cb30-40"><a href="#cb30-40"></a><span class="co">//- scalar*matrix</span></span>
<span id="cb30-41"><a href="#cb30-41"></a><span class="co">//</span></span>
<span id="cb30-42"><a href="#cb30-42"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> OT, <span class="kw">class</span> T1, <span class="kw">class</span> ET2, <span class="kw">class</span> OT2<span class="op">&gt;</span></span>
<span id="cb30-43"><a href="#cb30-43"></a><span class="kw">struct</span> matrix_multiplication_traits<span class="op">&lt;</span>OT, T1, matrix<span class="op">&lt;</span>ET2, OT2<span class="op">&gt;&gt;</span></span>
<span id="cb30-44"><a href="#cb30-44"></a><span class="op">{</span></span>
<span id="cb30-45"><a href="#cb30-45"></a>    <span class="kw">using</span> scalar_type <span class="op">=</span> detail<span class="op">::</span>element_tag<span class="op">&lt;</span>T1<span class="op">&gt;</span>;</span>
<span id="cb30-46"><a href="#cb30-46"></a>    <span class="kw">using</span> engine_type <span class="op">=</span> matrix_multiplication_engine_t<span class="op">&lt;</span>OT, scalar_type, ET2<span class="op">&gt;</span>;</span>
<span id="cb30-47"><a href="#cb30-47"></a>    <span class="kw">using</span> op_traits   <span class="op">=</span> OT;</span>
<span id="cb30-48"><a href="#cb30-48"></a>    <span class="kw">using</span> result_type <span class="op">=</span> matrix<span class="op">&lt;</span>engine_type, op_traits<span class="op">&gt;</span>;</span>
<span id="cb30-49"><a href="#cb30-49"></a></span>
<span id="cb30-50"><a href="#cb30-50"></a>    <span class="kw">static</span> result_type  multiply<span class="op">(</span>T1 <span class="kw">const</span><span class="op">&amp;</span> s1, matrix<span class="op">&lt;</span>ET2, OT2<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> m2<span class="op">)</span>;</span>
<span id="cb30-51"><a href="#cb30-51"></a><span class="op">}</span>;</span>
<span id="cb30-52"><a href="#cb30-52"></a></span>
<span id="cb30-53"><a href="#cb30-53"></a><span class="co">//- vector*vector</span></span>
<span id="cb30-54"><a href="#cb30-54"></a><span class="co">//</span></span>
<span id="cb30-55"><a href="#cb30-55"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> OT, <span class="kw">class</span> ET1, <span class="kw">class</span> OT1, <span class="kw">class</span> ET2, <span class="kw">class</span> OT2<span class="op">&gt;</span></span>
<span id="cb30-56"><a href="#cb30-56"></a><span class="kw">struct</span> matrix_multiplication_traits<span class="op">&lt;</span>OT, vector<span class="op">&lt;</span>ET1, OT1<span class="op">&gt;</span>, vector<span class="op">&lt;</span>ET2, OT2<span class="op">&gt;&gt;</span></span>
<span id="cb30-57"><a href="#cb30-57"></a><span class="op">{</span></span>
<span id="cb30-58"><a href="#cb30-58"></a>    <span class="co">//- This specialization returns a scalar, and therefore does not compute an engine type.</span></span>
<span id="cb30-59"><a href="#cb30-59"></a>    <span class="co">//</span></span>
<span id="cb30-60"><a href="#cb30-60"></a>    <span class="kw">using</span> op_traits   <span class="op">=</span> OT;</span>
<span id="cb30-61"><a href="#cb30-61"></a>    <span class="kw">using</span> elem_type_1 <span class="op">=</span> <span class="kw">typename</span> vector<span class="op">&lt;</span>ET1, OT1<span class="op">&gt;::</span>element_type;</span>
<span id="cb30-62"><a href="#cb30-62"></a>    <span class="kw">using</span> elem_type_2 <span class="op">=</span> <span class="kw">typename</span> vector<span class="op">&lt;</span>ET2, OT2<span class="op">&gt;::</span>element_type;</span>
<span id="cb30-63"><a href="#cb30-63"></a>    <span class="kw">using</span> result_type <span class="op">=</span> matrix_multiplication_element_t<span class="op">&lt;</span>op_traits, elem_type_1, elem_type_2<span class="op">&gt;</span>;</span>
<span id="cb30-64"><a href="#cb30-64"></a></span>
<span id="cb30-65"><a href="#cb30-65"></a>    <span class="kw">static</span> result_type  multiply<span class="op">(</span>vector<span class="op">&lt;</span>ET1, OT1<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> v1, vector<span class="op">&lt;</span>ET2, OT2<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> v2<span class="op">)</span>;</span>
<span id="cb30-66"><a href="#cb30-66"></a><span class="op">}</span>;</span>
<span id="cb30-67"><a href="#cb30-67"></a></span>
<span id="cb30-68"><a href="#cb30-68"></a><span class="co">//- matrix*vector</span></span>
<span id="cb30-69"><a href="#cb30-69"></a><span class="co">//</span></span>
<span id="cb30-70"><a href="#cb30-70"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> OT, <span class="kw">class</span> ET1, <span class="kw">class</span> OT1, <span class="kw">class</span> ET2, <span class="kw">class</span> OT2<span class="op">&gt;</span></span>
<span id="cb30-71"><a href="#cb30-71"></a><span class="kw">struct</span> matrix_multiplication_traits<span class="op">&lt;</span>OT, matrix<span class="op">&lt;</span>ET1, OT1<span class="op">&gt;</span>, vector<span class="op">&lt;</span>ET2, OT2<span class="op">&gt;&gt;</span></span>
<span id="cb30-72"><a href="#cb30-72"></a><span class="op">{</span></span>
<span id="cb30-73"><a href="#cb30-73"></a>    <span class="kw">using</span> engine_type <span class="op">=</span> matrix_multiplication_engine_t<span class="op">&lt;</span>OT, ET1, ET2<span class="op">&gt;</span>;</span>
<span id="cb30-74"><a href="#cb30-74"></a>    <span class="kw">using</span> op_traits   <span class="op">=</span> OT;</span>
<span id="cb30-75"><a href="#cb30-75"></a>    <span class="kw">using</span> result_type <span class="op">=</span> vector<span class="op">&lt;</span>engine_type, op_traits<span class="op">&gt;</span>;</span>
<span id="cb30-76"><a href="#cb30-76"></a></span>
<span id="cb30-77"><a href="#cb30-77"></a>    <span class="kw">static</span> result_type  multiply<span class="op">(</span>matrix<span class="op">&lt;</span>ET1, OT1<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> m1, vector<span class="op">&lt;</span>ET2, OT2<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> m2<span class="op">)</span>;</span>
<span id="cb30-78"><a href="#cb30-78"></a><span class="op">}</span>;</span>
<span id="cb30-79"><a href="#cb30-79"></a></span>
<span id="cb30-80"><a href="#cb30-80"></a><span class="co">//- vector*matrix</span></span>
<span id="cb30-81"><a href="#cb30-81"></a><span class="co">//</span></span>
<span id="cb30-82"><a href="#cb30-82"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> OT, <span class="kw">class</span> ET1, <span class="kw">class</span> OT1, <span class="kw">class</span> ET2, <span class="kw">class</span> OT2<span class="op">&gt;</span></span>
<span id="cb30-83"><a href="#cb30-83"></a><span class="kw">struct</span> matrix_multiplication_traits<span class="op">&lt;</span>OT, vector<span class="op">&lt;</span>ET1, OT1<span class="op">&gt;</span>, matrix<span class="op">&lt;</span>ET2, OT2<span class="op">&gt;&gt;</span></span>
<span id="cb30-84"><a href="#cb30-84"></a><span class="op">{</span></span>
<span id="cb30-85"><a href="#cb30-85"></a>    <span class="kw">using</span> engine_type <span class="op">=</span> matrix_multiplication_engine_t<span class="op">&lt;</span>OT, ET1, ET2<span class="op">&gt;</span>;</span>
<span id="cb30-86"><a href="#cb30-86"></a>    <span class="kw">using</span> op_traits   <span class="op">=</span> OT;</span>
<span id="cb30-87"><a href="#cb30-87"></a>    <span class="kw">using</span> result_type <span class="op">=</span> vector<span class="op">&lt;</span>engine_type, op_traits<span class="op">&gt;</span>;</span>
<span id="cb30-88"><a href="#cb30-88"></a></span>
<span id="cb30-89"><a href="#cb30-89"></a>    <span class="kw">static</span> result_type  multiply<span class="op">(</span>vector<span class="op">&lt;</span>ET1, OT1<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> m1, matrix<span class="op">&lt;</span>ET2, OT2<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> m2<span class="op">)</span>;</span>
<span id="cb30-90"><a href="#cb30-90"></a><span class="op">}</span>;</span>
<span id="cb30-91"><a href="#cb30-91"></a></span>
<span id="cb30-92"><a href="#cb30-92"></a><span class="co">//- matrix*matrix</span></span>
<span id="cb30-93"><a href="#cb30-93"></a><span class="co">//</span></span>
<span id="cb30-94"><a href="#cb30-94"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> OT, <span class="kw">class</span> ET1, <span class="kw">class</span> OT1, <span class="kw">class</span> ET2, <span class="kw">class</span> OT2<span class="op">&gt;</span></span>
<span id="cb30-95"><a href="#cb30-95"></a><span class="kw">struct</span> matrix_multiplication_traits<span class="op">&lt;</span>OT, matrix<span class="op">&lt;</span>ET1, OT1<span class="op">&gt;</span>, matrix<span class="op">&lt;</span>ET2, OT2<span class="op">&gt;&gt;</span></span>
<span id="cb30-96"><a href="#cb30-96"></a><span class="op">{</span></span>
<span id="cb30-97"><a href="#cb30-97"></a>    <span class="kw">using</span> engine_type <span class="op">=</span> matrix_multiplication_engine_t<span class="op">&lt;</span>OT, ET1, ET2<span class="op">&gt;</span>;</span>
<span id="cb30-98"><a href="#cb30-98"></a>    <span class="kw">using</span> op_traits   <span class="op">=</span> OT;</span>
<span id="cb30-99"><a href="#cb30-99"></a>    <span class="kw">using</span> result_type <span class="op">=</span> matrix<span class="op">&lt;</span>engine_type, op_traits<span class="op">&gt;</span>;</span>
<span id="cb30-100"><a href="#cb30-100"></a></span>
<span id="cb30-101"><a href="#cb30-101"></a>    <span class="kw">static</span> result_type  multiply<span class="op">(</span>matrix<span class="op">&lt;</span>ET1, OT1<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> m1, matrix<span class="op">&lt;</span>ET2, OT2<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> m2<span class="op">)</span>;</span>
<span id="cb30-102"><a href="#cb30-102"></a><span class="op">}</span>;</span>
<span id="cb30-103"><a href="#cb30-103"></a></span>
<span id="cb30-104"><a href="#cb30-104"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> OT, <span class="kw">class</span> OP1, <span class="kw">class</span> OP2<span class="op">&gt;</span></span>
<span id="cb30-105"><a href="#cb30-105"></a><span class="kw">using</span> matrix_multiplication_traits_t <span class="op">=</span> <span class="op">...</span>;     <span class="co">//- Implementation-defined</span></span></code></pre></div>
<h2 id="arithmetic-operators"><span class="header-section-number">6.11</span> Arithmetic operators<a href="#arithmetic-operators" class="self-link"></a></h2>
<p>The arithmetic operators provide syntax that mimics common mathematical notation, with computation executed by an arithmetic traits type specified by one of the operands’ operation traits template parameters.</p>
<p>Readers will note that the return types of the overloaded operators described below are left unspecified. This is a deliberate choice so that implementers have the freedom to choose whatever default technique for evaluationg expressions they desire; for example, by returning temporary objects, or by using expression templates, or perhaps by some hybrid technique.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb31-1"><a href="#cb31-1"></a><span class="co">//- Negation</span></span>
<span id="cb31-2"><a href="#cb31-2"></a><span class="co">//</span></span>
<span id="cb31-3"><a href="#cb31-3"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> ET1, <span class="kw">class</span> OT1<span class="op">&gt;</span></span>
<span id="cb31-4"><a href="#cb31-4"></a><span class="kw">inline</span> <span class="kw">auto</span></span>
<span id="cb31-5"><a href="#cb31-5"></a><span class="kw">operator</span> <span class="op">-(</span>vector<span class="op">&lt;</span>ET1, OT1<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> v1<span class="op">)</span></span>
<span id="cb31-6"><a href="#cb31-6"></a><span class="op">{</span></span>
<span id="cb31-7"><a href="#cb31-7"></a>    <span class="kw">using</span> op1_type   <span class="op">=</span> vector<span class="op">&lt;</span>ET1, OT1<span class="op">&gt;</span>;</span>
<span id="cb31-8"><a href="#cb31-8"></a>    <span class="kw">using</span> op_traits  <span class="op">=</span> OT1;</span>
<span id="cb31-9"><a href="#cb31-9"></a>    <span class="kw">using</span> neg_traits <span class="op">=</span> matrix_negation_traits_t<span class="op">&lt;</span>op_traits, op1_type<span class="op">&gt;</span>;</span>
<span id="cb31-10"><a href="#cb31-10"></a></span>
<span id="cb31-11"><a href="#cb31-11"></a>    <span class="cf">return</span> neg_traits<span class="op">::</span>negate<span class="op">(</span>v1<span class="op">)</span>;</span>
<span id="cb31-12"><a href="#cb31-12"></a><span class="op">}</span></span>
<span id="cb31-13"><a href="#cb31-13"></a></span>
<span id="cb31-14"><a href="#cb31-14"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> ET1, <span class="kw">class</span> OT1<span class="op">&gt;</span></span>
<span id="cb31-15"><a href="#cb31-15"></a><span class="kw">inline</span> <span class="kw">auto</span></span>
<span id="cb31-16"><a href="#cb31-16"></a><span class="kw">operator</span> <span class="op">-(</span>matrix<span class="op">&lt;</span>ET1, OT1<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> m1<span class="op">)</span></span>
<span id="cb31-17"><a href="#cb31-17"></a><span class="op">{</span></span>
<span id="cb31-18"><a href="#cb31-18"></a>    <span class="kw">using</span> op1_type   <span class="op">=</span> matrix<span class="op">&lt;</span>ET1, OT1<span class="op">&gt;</span>;</span>
<span id="cb31-19"><a href="#cb31-19"></a>    <span class="kw">using</span> op_traits  <span class="op">=</span> OT1;</span>
<span id="cb31-20"><a href="#cb31-20"></a>    <span class="kw">using</span> neg_traits <span class="op">=</span> matrix_negation_traits_t<span class="op">&lt;</span>op_traits, op1_type<span class="op">&gt;</span>;</span>
<span id="cb31-21"><a href="#cb31-21"></a></span>
<span id="cb31-22"><a href="#cb31-22"></a>    <span class="cf">return</span> neg_traits<span class="op">::</span>negate<span class="op">(</span>m1<span class="op">)</span>;</span>
<span id="cb31-23"><a href="#cb31-23"></a><span class="op">}</span></span>
<span id="cb31-24"><a href="#cb31-24"></a></span>
<span id="cb31-25"><a href="#cb31-25"></a><span class="co">//- Addition</span></span>
<span id="cb31-26"><a href="#cb31-26"></a><span class="co">//</span></span>
<span id="cb31-27"><a href="#cb31-27"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> ET1, <span class="kw">class</span> OT1, <span class="kw">class</span> ET2, <span class="kw">class</span> OT2<span class="op">&gt;</span></span>
<span id="cb31-28"><a href="#cb31-28"></a><span class="kw">inline</span> <span class="kw">auto</span></span>
<span id="cb31-29"><a href="#cb31-29"></a><span class="kw">operator</span> <span class="op">+(</span>vector<span class="op">&lt;</span>ET1, OT1<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> v1, vector<span class="op">&lt;</span>ET2, OT2<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> v2<span class="op">)</span></span>
<span id="cb31-30"><a href="#cb31-30"></a><span class="op">{</span></span>
<span id="cb31-31"><a href="#cb31-31"></a>    <span class="kw">using</span> op_traits  <span class="op">=</span> matrix_operation_traits_selector_t<span class="op">&lt;</span>OT1, OT2<span class="op">&gt;</span>;</span>
<span id="cb31-32"><a href="#cb31-32"></a>    <span class="kw">using</span> op1_type   <span class="op">=</span> vector<span class="op">&lt;</span>ET1, OT1<span class="op">&gt;</span>;</span>
<span id="cb31-33"><a href="#cb31-33"></a>    <span class="kw">using</span> op2_type   <span class="op">=</span> vector<span class="op">&lt;</span>ET2, OT2<span class="op">&gt;</span>;</span>
<span id="cb31-34"><a href="#cb31-34"></a>    <span class="kw">using</span> add_traits <span class="op">=</span> matrix_addition_traits_t<span class="op">&lt;</span>op_traits, op1_type, op2_type<span class="op">&gt;</span>;</span>
<span id="cb31-35"><a href="#cb31-35"></a></span>
<span id="cb31-36"><a href="#cb31-36"></a>    <span class="cf">return</span> add_traits<span class="op">::</span>add<span class="op">(</span>v1, v2<span class="op">)</span>;</span>
<span id="cb31-37"><a href="#cb31-37"></a><span class="op">}</span></span>
<span id="cb31-38"><a href="#cb31-38"></a></span>
<span id="cb31-39"><a href="#cb31-39"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> ET1, <span class="kw">class</span> OT1, <span class="kw">class</span> ET2, <span class="kw">class</span> OT2<span class="op">&gt;</span></span>
<span id="cb31-40"><a href="#cb31-40"></a><span class="kw">inline</span> <span class="kw">auto</span></span>
<span id="cb31-41"><a href="#cb31-41"></a><span class="kw">operator</span> <span class="op">+(</span>matrix<span class="op">&lt;</span>ET1, OT1<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> m1, matrix<span class="op">&lt;</span>ET2, OT2<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> m2<span class="op">)</span></span>
<span id="cb31-42"><a href="#cb31-42"></a><span class="op">{</span></span>
<span id="cb31-43"><a href="#cb31-43"></a>    <span class="kw">using</span> op_traits  <span class="op">=</span> matrix_operation_traits_selector_t<span class="op">&lt;</span>OT1, OT2<span class="op">&gt;</span>;</span>
<span id="cb31-44"><a href="#cb31-44"></a>    <span class="kw">using</span> op1_type   <span class="op">=</span> matrix<span class="op">&lt;</span>ET1, OT1<span class="op">&gt;</span>;</span>
<span id="cb31-45"><a href="#cb31-45"></a>    <span class="kw">using</span> op2_type   <span class="op">=</span> matrix<span class="op">&lt;</span>ET2, OT2<span class="op">&gt;</span>;</span>
<span id="cb31-46"><a href="#cb31-46"></a>    <span class="kw">using</span> add_traits <span class="op">=</span> matrix_addition_traits_t<span class="op">&lt;</span>op_traits, op1_type, op2_type<span class="op">&gt;</span>;</span>
<span id="cb31-47"><a href="#cb31-47"></a></span>
<span id="cb31-48"><a href="#cb31-48"></a>    <span class="cf">return</span> add_traits<span class="op">::</span>add<span class="op">(</span>m1, m2<span class="op">)</span>;</span>
<span id="cb31-49"><a href="#cb31-49"></a><span class="op">}</span></span>
<span id="cb31-50"><a href="#cb31-50"></a></span>
<span id="cb31-51"><a href="#cb31-51"></a><span class="co">//- Subtraction</span></span>
<span id="cb31-52"><a href="#cb31-52"></a><span class="co">//</span></span>
<span id="cb31-53"><a href="#cb31-53"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> ET1, <span class="kw">class</span> OT1, <span class="kw">class</span> ET2, <span class="kw">class</span> OT2<span class="op">&gt;</span></span>
<span id="cb31-54"><a href="#cb31-54"></a><span class="kw">inline</span> <span class="kw">auto</span></span>
<span id="cb31-55"><a href="#cb31-55"></a><span class="kw">operator</span> <span class="op">-(</span>vector<span class="op">&lt;</span>ET1, OT1<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> v1, vector<span class="op">&lt;</span>ET2, OT2<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> v2<span class="op">)</span></span>
<span id="cb31-56"><a href="#cb31-56"></a><span class="op">{</span></span>
<span id="cb31-57"><a href="#cb31-57"></a>    <span class="kw">using</span> op_traits  <span class="op">=</span> matrix_operation_traits_selector_t<span class="op">&lt;</span>OT1, OT2<span class="op">&gt;</span>;</span>
<span id="cb31-58"><a href="#cb31-58"></a>    <span class="kw">using</span> op1_type   <span class="op">=</span> vector<span class="op">&lt;</span>ET1, OT1<span class="op">&gt;</span>;</span>
<span id="cb31-59"><a href="#cb31-59"></a>    <span class="kw">using</span> op2_type   <span class="op">=</span> vector<span class="op">&lt;</span>ET2, OT2<span class="op">&gt;</span>;</span>
<span id="cb31-60"><a href="#cb31-60"></a>    <span class="kw">using</span> sub_traits <span class="op">=</span> matrix_subtraction_traits_t<span class="op">&lt;</span>op_traits, op1_type, op2_type<span class="op">&gt;</span>;</span>
<span id="cb31-61"><a href="#cb31-61"></a></span>
<span id="cb31-62"><a href="#cb31-62"></a>    <span class="cf">return</span> sub_traits<span class="op">::</span>subtract<span class="op">(</span>v1, v2<span class="op">)</span>;</span>
<span id="cb31-63"><a href="#cb31-63"></a><span class="op">}</span></span>
<span id="cb31-64"><a href="#cb31-64"></a></span>
<span id="cb31-65"><a href="#cb31-65"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> ET1, <span class="kw">class</span> OT1, <span class="kw">class</span> ET2, <span class="kw">class</span> OT2<span class="op">&gt;</span></span>
<span id="cb31-66"><a href="#cb31-66"></a><span class="kw">inline</span> <span class="kw">auto</span></span>
<span id="cb31-67"><a href="#cb31-67"></a><span class="kw">operator</span> <span class="op">-(</span>matrix<span class="op">&lt;</span>ET1, OT1<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> m1, matrix<span class="op">&lt;</span>ET2, OT2<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> m2<span class="op">)</span></span>
<span id="cb31-68"><a href="#cb31-68"></a><span class="op">{</span></span>
<span id="cb31-69"><a href="#cb31-69"></a>    <span class="kw">using</span> op_traits  <span class="op">=</span> matrix_operation_traits_selector_t<span class="op">&lt;</span>OT1, OT2<span class="op">&gt;</span>;</span>
<span id="cb31-70"><a href="#cb31-70"></a>    <span class="kw">using</span> op1_type   <span class="op">=</span> matrix<span class="op">&lt;</span>ET1, OT1<span class="op">&gt;</span>;</span>
<span id="cb31-71"><a href="#cb31-71"></a>    <span class="kw">using</span> op2_type   <span class="op">=</span> matrix<span class="op">&lt;</span>ET2, OT2<span class="op">&gt;</span>;</span>
<span id="cb31-72"><a href="#cb31-72"></a>    <span class="kw">using</span> sub_traits <span class="op">=</span> matrix_subtraction_traits_t<span class="op">&lt;</span>op_traits, op1_type, op2_type<span class="op">&gt;</span>;</span>
<span id="cb31-73"><a href="#cb31-73"></a></span>
<span id="cb31-74"><a href="#cb31-74"></a>    <span class="cf">return</span> sub_traits<span class="op">::</span>subtract<span class="op">(</span>m1, m2<span class="op">)</span>;</span>
<span id="cb31-75"><a href="#cb31-75"></a><span class="op">}</span></span>
<span id="cb31-76"><a href="#cb31-76"></a></span>
<span id="cb31-77"><a href="#cb31-77"></a><span class="co">//- Multiplication</span></span>
<span id="cb31-78"><a href="#cb31-78"></a><span class="co">//- vector*scalar and scalar*vector</span></span>
<span id="cb31-79"><a href="#cb31-79"></a><span class="co">//</span></span>
<span id="cb31-80"><a href="#cb31-80"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> ET1, <span class="kw">class</span> OT1, <span class="kw">class</span> S2<span class="op">&gt;</span></span>
<span id="cb31-81"><a href="#cb31-81"></a><span class="kw">inline</span> <span class="kw">auto</span></span>
<span id="cb31-82"><a href="#cb31-82"></a><span class="kw">operator</span> <span class="op">*(</span>vector<span class="op">&lt;</span>ET1, OT1<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> v1, S2 <span class="kw">const</span><span class="op">&amp;</span> s2<span class="op">)</span></span>
<span id="cb31-83"><a href="#cb31-83"></a><span class="op">{</span></span>
<span id="cb31-84"><a href="#cb31-84"></a>    <span class="kw">static_assert</span><span class="op">(</span>is_matrix_element_v<span class="op">&lt;</span>S2<span class="op">&gt;)</span>;</span>
<span id="cb31-85"><a href="#cb31-85"></a></span>
<span id="cb31-86"><a href="#cb31-86"></a>    <span class="kw">using</span> op_traits  <span class="op">=</span> OT1;</span>
<span id="cb31-87"><a href="#cb31-87"></a>    <span class="kw">using</span> op1_type   <span class="op">=</span> vector<span class="op">&lt;</span>ET1, OT1<span class="op">&gt;</span>;</span>
<span id="cb31-88"><a href="#cb31-88"></a>    <span class="kw">using</span> op2_type   <span class="op">=</span> S2;</span>
<span id="cb31-89"><a href="#cb31-89"></a>    <span class="kw">using</span> mul_traits <span class="op">=</span> matrix_multiplication_traits_t<span class="op">&lt;</span>op_traits, op1_type, op2_type<span class="op">&gt;</span>;</span>
<span id="cb31-90"><a href="#cb31-90"></a></span>
<span id="cb31-91"><a href="#cb31-91"></a>    <span class="cf">return</span> mul_traits<span class="op">::</span>multiply<span class="op">(</span>v1, s2<span class="op">)</span>;</span>
<span id="cb31-92"><a href="#cb31-92"></a><span class="op">}</span></span>
<span id="cb31-93"><a href="#cb31-93"></a></span>
<span id="cb31-94"><a href="#cb31-94"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> S1, <span class="kw">class</span> ET2, <span class="kw">class</span> OT2<span class="op">&gt;</span></span>
<span id="cb31-95"><a href="#cb31-95"></a><span class="kw">inline</span> <span class="kw">auto</span></span>
<span id="cb31-96"><a href="#cb31-96"></a><span class="kw">operator</span> <span class="op">*(</span>S1 <span class="kw">const</span><span class="op">&amp;</span> s1, vector<span class="op">&lt;</span>ET2, OT2<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> v2<span class="op">)</span></span>
<span id="cb31-97"><a href="#cb31-97"></a><span class="op">{</span></span>
<span id="cb31-98"><a href="#cb31-98"></a>    <span class="kw">static_assert</span><span class="op">(</span>is_matrix_element_v<span class="op">&lt;</span>S1<span class="op">&gt;)</span>;</span>
<span id="cb31-99"><a href="#cb31-99"></a></span>
<span id="cb31-100"><a href="#cb31-100"></a>    <span class="kw">using</span> op_traits  <span class="op">=</span> OT2;</span>
<span id="cb31-101"><a href="#cb31-101"></a>    <span class="kw">using</span> op1_type   <span class="op">=</span> S1;</span>
<span id="cb31-102"><a href="#cb31-102"></a>    <span class="kw">using</span> op2_type   <span class="op">=</span> vector<span class="op">&lt;</span>ET2, OT2<span class="op">&gt;</span>;</span>
<span id="cb31-103"><a href="#cb31-103"></a>    <span class="kw">using</span> mul_traits <span class="op">=</span> matrix_multiplication_traits_t<span class="op">&lt;</span>op_traits, op1_type, op2_type<span class="op">&gt;</span>;</span>
<span id="cb31-104"><a href="#cb31-104"></a></span>
<span id="cb31-105"><a href="#cb31-105"></a>    <span class="cf">return</span> mul_traits<span class="op">::</span>multiply<span class="op">(</span>s1, v2<span class="op">)</span>;</span>
<span id="cb31-106"><a href="#cb31-106"></a><span class="op">}</span></span>
<span id="cb31-107"><a href="#cb31-107"></a></span>
<span id="cb31-108"><a href="#cb31-108"></a><span class="co">//- matrix*scalar and scalar*matrix</span></span>
<span id="cb31-109"><a href="#cb31-109"></a><span class="co">//</span></span>
<span id="cb31-110"><a href="#cb31-110"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> ET1, <span class="kw">class</span> OT1, <span class="kw">class</span> S2<span class="op">&gt;</span></span>
<span id="cb31-111"><a href="#cb31-111"></a><span class="kw">inline</span> <span class="kw">auto</span></span>
<span id="cb31-112"><a href="#cb31-112"></a><span class="kw">operator</span> <span class="op">*(</span>matrix<span class="op">&lt;</span>ET1, OT1<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> m1, S2 <span class="kw">const</span><span class="op">&amp;</span> s2<span class="op">)</span></span>
<span id="cb31-113"><a href="#cb31-113"></a><span class="op">{</span></span>
<span id="cb31-114"><a href="#cb31-114"></a>    <span class="kw">static_assert</span><span class="op">(</span>is_matrix_element_v<span class="op">&lt;</span>S2<span class="op">&gt;)</span>;</span>
<span id="cb31-115"><a href="#cb31-115"></a></span>
<span id="cb31-116"><a href="#cb31-116"></a>    <span class="kw">using</span> op_traits  <span class="op">=</span> OT1;</span>
<span id="cb31-117"><a href="#cb31-117"></a>    <span class="kw">using</span> op1_type   <span class="op">=</span> matrix<span class="op">&lt;</span>ET1, OT1<span class="op">&gt;</span>;</span>
<span id="cb31-118"><a href="#cb31-118"></a>    <span class="kw">using</span> op2_type   <span class="op">=</span> S2;</span>
<span id="cb31-119"><a href="#cb31-119"></a>    <span class="kw">using</span> mul_traits <span class="op">=</span> matrix_multiplication_traits_t<span class="op">&lt;</span>op_traits, op1_type, op2_type<span class="op">&gt;</span>;</span>
<span id="cb31-120"><a href="#cb31-120"></a></span>
<span id="cb31-121"><a href="#cb31-121"></a>    <span class="cf">return</span> mul_traits<span class="op">::</span>multiply<span class="op">(</span>m1, s2<span class="op">)</span>;</span>
<span id="cb31-122"><a href="#cb31-122"></a><span class="op">}</span></span>
<span id="cb31-123"><a href="#cb31-123"></a></span>
<span id="cb31-124"><a href="#cb31-124"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> S1, <span class="kw">class</span> ET2, <span class="kw">class</span> OT2<span class="op">&gt;</span></span>
<span id="cb31-125"><a href="#cb31-125"></a><span class="kw">inline</span> <span class="kw">auto</span></span>
<span id="cb31-126"><a href="#cb31-126"></a><span class="kw">operator</span> <span class="op">*(</span>S1 <span class="kw">const</span><span class="op">&amp;</span> s1, matrix<span class="op">&lt;</span>ET2, OT2<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> m2<span class="op">)</span></span>
<span id="cb31-127"><a href="#cb31-127"></a><span class="op">{</span></span>
<span id="cb31-128"><a href="#cb31-128"></a>    <span class="kw">static_assert</span><span class="op">(</span>is_matrix_element_v<span class="op">&lt;</span>S1<span class="op">&gt;)</span>;</span>
<span id="cb31-129"><a href="#cb31-129"></a></span>
<span id="cb31-130"><a href="#cb31-130"></a>    <span class="kw">using</span> op_traits  <span class="op">=</span> OT2;</span>
<span id="cb31-131"><a href="#cb31-131"></a>    <span class="kw">using</span> op1_type   <span class="op">=</span> S1;</span>
<span id="cb31-132"><a href="#cb31-132"></a>    <span class="kw">using</span> op2_type   <span class="op">=</span> matrix<span class="op">&lt;</span>ET2, OT2<span class="op">&gt;</span>;</span>
<span id="cb31-133"><a href="#cb31-133"></a>    <span class="kw">using</span> mul_traits <span class="op">=</span> matrix_multiplication_traits_t<span class="op">&lt;</span>op_traits, op1_type, op2_type<span class="op">&gt;</span>;</span>
<span id="cb31-134"><a href="#cb31-134"></a></span>
<span id="cb31-135"><a href="#cb31-135"></a>    <span class="cf">return</span> mul_traits<span class="op">::</span>multiply<span class="op">(</span>s1, m2<span class="op">)</span>;</span>
<span id="cb31-136"><a href="#cb31-136"></a><span class="op">}</span></span>
<span id="cb31-137"><a href="#cb31-137"></a></span>
<span id="cb31-138"><a href="#cb31-138"></a><span class="co">//- vector*vector</span></span>
<span id="cb31-139"><a href="#cb31-139"></a><span class="co">//</span></span>
<span id="cb31-140"><a href="#cb31-140"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> ET1, <span class="kw">class</span> OT1, <span class="kw">class</span> ET2, <span class="kw">class</span> OT2<span class="op">&gt;</span></span>
<span id="cb31-141"><a href="#cb31-141"></a><span class="kw">inline</span> <span class="kw">auto</span></span>
<span id="cb31-142"><a href="#cb31-142"></a><span class="kw">operator</span> <span class="op">*(</span>vector<span class="op">&lt;</span>ET1, OT1<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> v1, vector<span class="op">&lt;</span>ET2, OT2<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> v2<span class="op">)</span></span>
<span id="cb31-143"><a href="#cb31-143"></a><span class="op">{</span></span>
<span id="cb31-144"><a href="#cb31-144"></a>    <span class="kw">using</span> op_traits  <span class="op">=</span> matrix_operation_traits_selector_t<span class="op">&lt;</span>OT1, OT2<span class="op">&gt;</span>;</span>
<span id="cb31-145"><a href="#cb31-145"></a>    <span class="kw">using</span> op1_type   <span class="op">=</span> vector<span class="op">&lt;</span>ET1, OT1<span class="op">&gt;</span>;</span>
<span id="cb31-146"><a href="#cb31-146"></a>    <span class="kw">using</span> op2_type   <span class="op">=</span> vector<span class="op">&lt;</span>ET2, OT2<span class="op">&gt;</span>;</span>
<span id="cb31-147"><a href="#cb31-147"></a>    <span class="kw">using</span> mul_traits <span class="op">=</span> matrix_multiplication_traits_t<span class="op">&lt;</span>op_traits, op1_type, op2_type<span class="op">&gt;</span>;</span>
<span id="cb31-148"><a href="#cb31-148"></a></span>
<span id="cb31-149"><a href="#cb31-149"></a>    <span class="cf">return</span> mul_traits<span class="op">::</span>multiply<span class="op">(</span>v1, v2<span class="op">)</span>;</span>
<span id="cb31-150"><a href="#cb31-150"></a><span class="op">}</span></span>
<span id="cb31-151"><a href="#cb31-151"></a></span>
<span id="cb31-152"><a href="#cb31-152"></a><span class="co">//- matrix*vector</span></span>
<span id="cb31-153"><a href="#cb31-153"></a><span class="co">//</span></span>
<span id="cb31-154"><a href="#cb31-154"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> ET1, <span class="kw">class</span> OT1, <span class="kw">class</span> ET2, <span class="kw">class</span> OT2<span class="op">&gt;</span></span>
<span id="cb31-155"><a href="#cb31-155"></a><span class="kw">inline</span> <span class="kw">auto</span></span>
<span id="cb31-156"><a href="#cb31-156"></a><span class="kw">operator</span> <span class="op">*(</span>matrix<span class="op">&lt;</span>ET1, OT1<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> m1, vector<span class="op">&lt;</span>ET2, OT2<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> v2<span class="op">)</span></span>
<span id="cb31-157"><a href="#cb31-157"></a><span class="op">{</span></span>
<span id="cb31-158"><a href="#cb31-158"></a>    <span class="kw">using</span> op_traits  <span class="op">=</span> matrix_operation_traits_selector_t<span class="op">&lt;</span>OT1, OT2<span class="op">&gt;</span>;</span>
<span id="cb31-159"><a href="#cb31-159"></a>    <span class="kw">using</span> op1_type   <span class="op">=</span> matrix<span class="op">&lt;</span>ET1, OT1<span class="op">&gt;</span>;</span>
<span id="cb31-160"><a href="#cb31-160"></a>    <span class="kw">using</span> op2_type   <span class="op">=</span> vector<span class="op">&lt;</span>ET2, OT2<span class="op">&gt;</span>;</span>
<span id="cb31-161"><a href="#cb31-161"></a>    <span class="kw">using</span> mul_traits <span class="op">=</span> matrix_multiplication_traits_t<span class="op">&lt;</span>op_traits, op1_type, op2_type<span class="op">&gt;</span>;</span>
<span id="cb31-162"><a href="#cb31-162"></a></span>
<span id="cb31-163"><a href="#cb31-163"></a>    <span class="cf">return</span> mul_traits<span class="op">::</span>multiply<span class="op">(</span>m1, v2<span class="op">)</span>;</span>
<span id="cb31-164"><a href="#cb31-164"></a><span class="op">}</span></span>
<span id="cb31-165"><a href="#cb31-165"></a></span>
<span id="cb31-166"><a href="#cb31-166"></a><span class="co">//- vector*matrix</span></span>
<span id="cb31-167"><a href="#cb31-167"></a><span class="co">//</span></span>
<span id="cb31-168"><a href="#cb31-168"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> ET1, <span class="kw">class</span> OT1, <span class="kw">class</span> ET2, <span class="kw">class</span> OT2<span class="op">&gt;</span></span>
<span id="cb31-169"><a href="#cb31-169"></a><span class="kw">inline</span> <span class="kw">auto</span></span>
<span id="cb31-170"><a href="#cb31-170"></a><span class="kw">operator</span> <span class="op">*(</span>vector<span class="op">&lt;</span>ET1, OT1<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> v1, matrix<span class="op">&lt;</span>ET2, OT2<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> m2<span class="op">)</span></span>
<span id="cb31-171"><a href="#cb31-171"></a><span class="op">{</span></span>
<span id="cb31-172"><a href="#cb31-172"></a>    <span class="kw">using</span> op_traits  <span class="op">=</span> matrix_operation_traits_selector_t<span class="op">&lt;</span>OT1, OT2<span class="op">&gt;</span>;</span>
<span id="cb31-173"><a href="#cb31-173"></a>    <span class="kw">using</span> op1_type   <span class="op">=</span> vector<span class="op">&lt;</span>ET1, OT1<span class="op">&gt;</span>;</span>
<span id="cb31-174"><a href="#cb31-174"></a>    <span class="kw">using</span> op2_type   <span class="op">=</span> matrix<span class="op">&lt;</span>ET2, OT2<span class="op">&gt;</span>;</span>
<span id="cb31-175"><a href="#cb31-175"></a>    <span class="kw">using</span> mul_traits <span class="op">=</span> matrix_multiplication_traits_t<span class="op">&lt;</span>op_traits, op1_type, op2_type<span class="op">&gt;</span>;</span>
<span id="cb31-176"><a href="#cb31-176"></a></span>
<span id="cb31-177"><a href="#cb31-177"></a>    <span class="cf">return</span> mul_traits<span class="op">::</span>multiply<span class="op">(</span>v1, m2<span class="op">)</span>;</span>
<span id="cb31-178"><a href="#cb31-178"></a><span class="op">}</span></span>
<span id="cb31-179"><a href="#cb31-179"></a></span>
<span id="cb31-180"><a href="#cb31-180"></a><span class="co">//- matrix*matrix</span></span>
<span id="cb31-181"><a href="#cb31-181"></a><span class="co">//</span></span>
<span id="cb31-182"><a href="#cb31-182"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> ET1, <span class="kw">class</span> OT1, <span class="kw">class</span> ET2, <span class="kw">class</span> OT2<span class="op">&gt;</span></span>
<span id="cb31-183"><a href="#cb31-183"></a><span class="kw">inline</span> <span class="kw">auto</span></span>
<span id="cb31-184"><a href="#cb31-184"></a><span class="kw">operator</span> <span class="op">*(</span>matrix<span class="op">&lt;</span>ET1, OT1<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> m1, matrix<span class="op">&lt;</span>ET2, OT2<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> m2<span class="op">)</span></span>
<span id="cb31-185"><a href="#cb31-185"></a><span class="op">{</span></span>
<span id="cb31-186"><a href="#cb31-186"></a>    <span class="kw">using</span> op_traits  <span class="op">=</span> matrix_operation_traits_selector_t<span class="op">&lt;</span>OT1, OT2<span class="op">&gt;</span>;</span>
<span id="cb31-187"><a href="#cb31-187"></a>    <span class="kw">using</span> op1_type   <span class="op">=</span> matrix<span class="op">&lt;</span>ET1, OT1<span class="op">&gt;</span>;</span>
<span id="cb31-188"><a href="#cb31-188"></a>    <span class="kw">using</span> op2_type   <span class="op">=</span> matrix<span class="op">&lt;</span>ET2, OT2<span class="op">&gt;</span>;</span>
<span id="cb31-189"><a href="#cb31-189"></a>    <span class="kw">using</span> mul_traits <span class="op">=</span> matrix_multiplication_traits_t<span class="op">&lt;</span>op_traits, op1_type, op2_type<span class="op">&gt;</span>;</span>
<span id="cb31-190"><a href="#cb31-190"></a></span>
<span id="cb31-191"><a href="#cb31-191"></a>    <span class="cf">return</span> mul_traits<span class="op">::</span>multiply<span class="op">(</span>m1, m2<span class="op">)</span>;</span>
<span id="cb31-192"><a href="#cb31-192"></a><span class="op">}</span></span></code></pre></div>
<h1 id="customization"><span class="header-section-number">7</span> Customization<a href="#customization" class="self-link"></a></h1>
<p>The library provides for several forms of customization: custom element types, custom element promotion, custom engines, and custom arithmetical operations.<br />
The following sections show examples of each.</p>
<h2 id="integrating-a-new-element-type"><span class="header-section-number">7.1</span> Integrating a new element type<a href="#integrating-a-new-element-type" class="self-link"></a></h2>
<p>Suppose that you have created a new type that models a real number in some way and you wish for that type to be used as a matrix element:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb32-1"><a href="#cb32-1"></a><span class="kw">class</span> new_num</span>
<span id="cb32-2"><a href="#cb32-2"></a><span class="op">{</span></span>
<span id="cb32-3"><a href="#cb32-3"></a>  <span class="kw">public</span><span class="op">:</span></span>
<span id="cb32-4"><a href="#cb32-4"></a>    new_num<span class="op">()</span>;</span>
<span id="cb32-5"><a href="#cb32-5"></a>    new_num<span class="op">(</span>new_num<span class="op">&amp;&amp;)</span> <span class="op">=</span> <span class="cf">default</span>;</span>
<span id="cb32-6"><a href="#cb32-6"></a>    new_num<span class="op">(</span>new_num <span class="kw">const</span><span class="op">&amp;)</span> <span class="op">=</span> <span class="cf">default</span>;</span>
<span id="cb32-7"><a href="#cb32-7"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> U<span class="op">&gt;</span>   new_num<span class="op">(</span>U other<span class="op">)</span>;</span>
<span id="cb32-8"><a href="#cb32-8"></a></span>
<span id="cb32-9"><a href="#cb32-9"></a>    new_num<span class="op">&amp;</span>    <span class="kw">operator</span> <span class="op">=(</span>new_num<span class="op">&amp;&amp;)</span> <span class="op">=</span> <span class="cf">default</span>;</span>
<span id="cb32-10"><a href="#cb32-10"></a>    new_num<span class="op">&amp;</span>    <span class="kw">operator</span> <span class="op">=(</span>new_num <span class="kw">const</span><span class="op">&amp;)</span> <span class="op">=</span> <span class="cf">default</span>;</span>
<span id="cb32-11"><a href="#cb32-11"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> U<span class="op">&gt;</span>   new_num<span class="op">&amp;</span>    <span class="kw">operator</span> <span class="op">=(</span>U rhs<span class="op">)</span>;</span>
<span id="cb32-12"><a href="#cb32-12"></a></span>
<span id="cb32-13"><a href="#cb32-13"></a>    new_num     <span class="kw">operator</span> <span class="op">-()</span> <span class="kw">const</span>;</span>
<span id="cb32-14"><a href="#cb32-14"></a>    new_num     <span class="kw">operator</span> <span class="op">+()</span> <span class="kw">const</span>;</span>
<span id="cb32-15"><a href="#cb32-15"></a></span>
<span id="cb32-16"><a href="#cb32-16"></a>    new_num<span class="op">&amp;</span>    <span class="kw">operator</span> <span class="op">+=(</span>new_num rhs<span class="op">)</span>;</span>
<span id="cb32-17"><a href="#cb32-17"></a>    new_num<span class="op">&amp;</span>    <span class="kw">operator</span> <span class="op">-=(</span>new_num rhs<span class="op">)</span>;</span>
<span id="cb32-18"><a href="#cb32-18"></a>    new_num<span class="op">&amp;</span>    <span class="kw">operator</span> <span class="op">*=(</span>new_num rhs<span class="op">)</span>;</span>
<span id="cb32-19"><a href="#cb32-19"></a>    new_num<span class="op">&amp;</span>    <span class="kw">operator</span> <span class="op">/=(</span>new_num rhs<span class="op">)</span>;</span>
<span id="cb32-20"><a href="#cb32-20"></a></span>
<span id="cb32-21"><a href="#cb32-21"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> U<span class="op">&gt;</span>   new_num<span class="op">&amp;</span>    <span class="kw">operator</span> <span class="op">+=(</span>U rhs<span class="op">)</span>;</span>
<span id="cb32-22"><a href="#cb32-22"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> U<span class="op">&gt;</span>   new_num<span class="op">&amp;</span>    <span class="kw">operator</span> <span class="op">-=(</span>U rhs<span class="op">)</span>;</span>
<span id="cb32-23"><a href="#cb32-23"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> U<span class="op">&gt;</span>   new_num<span class="op">&amp;</span>    <span class="kw">operator</span> <span class="op">*=(</span>U rhs<span class="op">)</span>;</span>
<span id="cb32-24"><a href="#cb32-24"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> U<span class="op">&gt;</span>   new_num<span class="op">&amp;</span>    <span class="kw">operator</span> <span class="op">/=(</span>U rhs<span class="op">)</span>;</span>
<span id="cb32-25"><a href="#cb32-25"></a></span>
<span id="cb32-26"><a href="#cb32-26"></a>    <span class="op">...</span></span>
<span id="cb32-27"><a href="#cb32-27"></a><span class="op">}</span>;</span>
<span id="cb32-28"><a href="#cb32-28"></a></span>
<span id="cb32-29"><a href="#cb32-29"></a><span class="kw">inline</span> <span class="dt">bool</span> <span class="kw">operator</span> <span class="op">==(</span>NewNum lhs, NewNum rhs<span class="op">)</span>;</span>
<span id="cb32-30"><a href="#cb32-30"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> U<span class="op">&gt;</span> <span class="kw">inline</span> <span class="dt">bool</span> <span class="kw">operator</span> <span class="op">==(</span>NewNum lhs, U rhs<span class="op">)</span>;</span>
<span id="cb32-31"><a href="#cb32-31"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> U<span class="op">&gt;</span> <span class="kw">inline</span> <span class="dt">bool</span> <span class="kw">operator</span> <span class="op">==(</span>U lhs, NewNum rhs<span class="op">)</span>;</span>
<span id="cb32-32"><a href="#cb32-32"></a><span class="op">...</span></span>
<span id="cb32-33"><a href="#cb32-33"></a><span class="co">//- other comparison operators...</span></span>
<span id="cb32-34"><a href="#cb32-34"></a><span class="op">...</span></span>
<span id="cb32-35"><a href="#cb32-35"></a><span class="co">//- other arithmetic operators...</span></span>
<span id="cb32-36"><a href="#cb32-36"></a><span class="op">...</span></span>
<span id="cb32-37"><a href="#cb32-37"></a>                  <span class="kw">inline</span> new_num <span class="kw">operator</span> <span class="op">*(</span>new_num lhs, new_num rhs<span class="op">)</span>;</span>
<span id="cb32-38"><a href="#cb32-38"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> U<span class="op">&gt;</span> <span class="kw">inline</span> new_num <span class="kw">operator</span> <span class="op">*(</span>new_num lhs, U rhs<span class="op">)</span>;</span>
<span id="cb32-39"><a href="#cb32-39"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> U<span class="op">&gt;</span> <span class="kw">inline</span> new_num <span class="kw">operator</span> <span class="op">*(</span>U lhs, new_num rhs<span class="op">)</span>;</span></code></pre></div>
<p>Assuming that this type works as intended, and that all arithmetic interactions with other types are handled the set of operator overloads that you provide, then all that is required for the library to accept <code>new_num</code> as an element type is to create a specialization of <code>number_traits</code>:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb33-1"><a href="#cb33-1"></a><span class="kw">template</span><span class="op">&lt;&gt;</span></span>
<span id="cb33-2"><a href="#cb33-2"></a><span class="kw">struct</span> std<span class="op">::</span>math<span class="op">::</span>number_traits<span class="op">&lt;</span>new_num<span class="op">&gt;</span></span>
<span id="cb33-3"><a href="#cb33-3"></a><span class="op">{</span></span>
<span id="cb33-4"><a href="#cb33-4"></a>    <span class="kw">using</span> is_field    <span class="op">=</span> true_type;</span>
<span id="cb33-5"><a href="#cb33-5"></a>    <span class="kw">using</span> is_nc_ring  <span class="op">=</span> true_type;</span>
<span id="cb33-6"><a href="#cb33-6"></a>    <span class="kw">using</span> is_ring     <span class="op">=</span> true_type;</span>
<span id="cb33-7"><a href="#cb33-7"></a><span class="op">}</span>;</span></code></pre></div>
<p>By stating that <code>new_num</code> models at least a non-commutative ring, and by ensuring that its arithmetic operators functions as promised, the library’s traits types will allow compiliation to succeed.</p>
<h2 id="custom-element-promotion"><span class="header-section-number">7.2</span> Custom element promotion<a href="#custom-element-promotion" class="self-link"></a></h2>
<p>Suppose that you want the result of adding two <code>float</code> elements to be <code>double</code>. Then you would create the following custom types in your namespace:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb34-1"><a href="#cb34-1"></a><span class="co">//- Base template for custom element promotion</span></span>
<span id="cb34-2"><a href="#cb34-2"></a><span class="co">//</span></span>
<span id="cb34-3"><a href="#cb34-3"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T1, <span class="kw">class</span> T2<span class="op">&gt;</span></span>
<span id="cb34-4"><a href="#cb34-4"></a><span class="kw">struct</span> element_add_traits_tst;</span>
<span id="cb34-5"><a href="#cb34-5"></a></span>
<span id="cb34-6"><a href="#cb34-6"></a><span class="co">//- Promote any float/float addition to double.</span></span>
<span id="cb34-7"><a href="#cb34-7"></a><span class="co">//</span></span>
<span id="cb34-8"><a href="#cb34-8"></a><span class="kw">template</span><span class="op">&lt;&gt;</span></span>
<span id="cb34-9"><a href="#cb34-9"></a><span class="kw">struct</span> element_add_traits_tst<span class="op">&lt;</span><span class="dt">float</span>, <span class="dt">float</span><span class="op">&gt;</span></span>
<span id="cb34-10"><a href="#cb34-10"></a><span class="op">{</span></span>
<span id="cb34-11"><a href="#cb34-11"></a>    <span class="kw">using</span> element_type <span class="op">=</span> <span class="dt">double</span>;</span>
<span id="cb34-12"><a href="#cb34-12"></a><span class="op">}</span>;</span>
<span id="cb34-13"><a href="#cb34-13"></a></span>
<span id="cb34-14"><a href="#cb34-14"></a><span class="co">//- Custom operation traits.</span></span>
<span id="cb34-15"><a href="#cb34-15"></a><span class="co">//</span></span>
<span id="cb34-16"><a href="#cb34-16"></a><span class="kw">struct</span> test_add_op_traits_tst</span>
<span id="cb34-17"><a href="#cb34-17"></a><span class="op">{</span></span>
<span id="cb34-18"><a href="#cb34-18"></a>     <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T1, <span class="kw">class</span> T2<span class="op">&gt;</span></span>
<span id="cb34-19"><a href="#cb34-19"></a>     <span class="kw">using</span> element_addition_traits <span class="op">=</span> element_add_traits_tst<span class="op">&lt;</span>T1, T2<span class="op">&gt;</span>;</span>
<span id="cb34-20"><a href="#cb34-20"></a><span class="op">}</span>;</span></code></pre></div>
<p>The new operation traits could be used like this:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb35-1"><a href="#cb35-1"></a>matrix<span class="op">&lt;</span>fs_matrix_engine<span class="op">&lt;</span><span class="dt">float</span>, <span class="dv">2</span>, <span class="dv">3</span><span class="op">&gt;</span>, add_op_traits_tst<span class="op">&gt;</span>                    m1;</span>
<span id="cb35-2"><a href="#cb35-2"></a>matrix<span class="op">&lt;</span>dr_matrix_engine<span class="op">&lt;</span><span class="dt">float</span>, allocator<span class="op">&lt;</span><span class="dt">float</span><span class="op">&gt;&gt;</span>, add_op_traits_tst<span class="op">&gt;</span>        m2<span class="op">(</span><span class="dv">2</span>, <span class="dv">3</span><span class="op">)</span>;</span>
<span id="cb35-3"><a href="#cb35-3"></a>matrix<span class="op">&lt;</span>dr_matrix_engine<span class="op">&lt;</span><span class="dt">float</span>, allocator<span class="op">&lt;</span><span class="dt">float</span><span class="op">&gt;&gt;</span>, matrix_operation_traits<span class="op">&gt;</span>  m3<span class="op">(</span><span class="dv">2</span>, <span class="dv">3</span><span class="op">)</span>;</span>
<span id="cb35-4"><a href="#cb35-4"></a></span>
<span id="cb35-5"><a href="#cb35-5"></a><span class="co">//- mr1 --&gt; matrix&lt;fs_matrix_engine&lt;double, 2, 3&gt;, add_op_traits_tst&gt;</span></span>
<span id="cb35-6"><a href="#cb35-6"></a><span class="co">//</span></span>
<span id="cb35-7"><a href="#cb35-7"></a><span class="kw">auto</span> mr1 <span class="op">=</span> m1 <span class="op">+</span> m1;</span>
<span id="cb35-8"><a href="#cb35-8"></a></span>
<span id="cb35-9"><a href="#cb35-9"></a><span class="co">//- mr2 --&gt; matrix&lt;dr_matrix_engine&lt;double, allocator&lt;double&gt;&gt;, add_op_traits_tst&gt;</span></span>
<span id="cb35-10"><a href="#cb35-10"></a><span class="co">//</span></span>
<span id="cb35-11"><a href="#cb35-11"></a><span class="kw">auto</span> mr2 <span class="op">=</span> m1 <span class="op">+</span> m2;</span>
<span id="cb35-12"><a href="#cb35-12"></a></span>
<span id="cb35-13"><a href="#cb35-13"></a><span class="co">//- mr3 --&gt; matrix&lt;dr_matrix_engine&lt;double, allocator&lt;double&gt;&gt;, add_op_traits_tst&gt;</span></span>
<span id="cb35-14"><a href="#cb35-14"></a><span class="co">//</span></span>
<span id="cb35-15"><a href="#cb35-15"></a><span class="kw">auto</span> mr3 <span class="op">=</span> m1 <span class="op">+</span> m3;</span></code></pre></div>
<p>Note that this example assumes that an addition operation involving a fixed-size matrix and a dynamically-resizable matrix, or two dynamically-resizable matrices results in a dynamically-resizable matrix.</p>
<h2 id="integrating-a-new-engine-type"><span class="header-section-number">7.3</span> Integrating a new engine type<a href="#integrating-a-new-engine-type" class="self-link"></a></h2>
<p>Suppose that you want to add a custom fixed-size matrix engine that is somehow different from <code>fs_matrix_engine</code>; perhaps it is instrumented in some way for debugging, or uses fixed-size storage that is external to the engine object. It might look like this:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb36-1"><a href="#cb36-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T, <span class="dt">int32_t</span> R, <span class="dt">int32_t</span> C<span class="op">&gt;</span></span>
<span id="cb36-2"><a href="#cb36-2"></a><span class="kw">class</span> fs_matrix_engine_tst</span>
<span id="cb36-3"><a href="#cb36-3"></a><span class="op">{</span></span>
<span id="cb36-4"><a href="#cb36-4"></a>  <span class="kw">public</span><span class="op">:</span></span>
<span id="cb36-5"><a href="#cb36-5"></a>    <span class="kw">using</span> engine_category <span class="op">=</span> std<span class="op">::</span>math<span class="op">::</span>mutable_matrix_engine_tag;</span>
<span id="cb36-6"><a href="#cb36-6"></a>    <span class="kw">using</span> element_type    <span class="op">=</span> T;</span>
<span id="cb36-7"><a href="#cb36-7"></a>    <span class="kw">using</span> value_type      <span class="op">=</span> T;</span>
<span id="cb36-8"><a href="#cb36-8"></a>    <span class="kw">using</span> reference       <span class="op">=</span> T<span class="op">&amp;</span>;</span>
<span id="cb36-9"><a href="#cb36-9"></a>    <span class="kw">using</span> pointer         <span class="op">=</span> T<span class="op">*</span>;</span>
<span id="cb36-10"><a href="#cb36-10"></a>    <span class="kw">using</span> const_reference <span class="op">=</span> T <span class="kw">const</span><span class="op">&amp;</span>;</span>
<span id="cb36-11"><a href="#cb36-11"></a>    <span class="kw">using</span> const_pointer   <span class="op">=</span> T <span class="kw">const</span><span class="op">*</span>;</span>
<span id="cb36-12"><a href="#cb36-12"></a>    <span class="kw">using</span> difference_type <span class="op">=</span> std<span class="op">::</span><span class="dt">ptrdiff_t</span>;</span>
<span id="cb36-13"><a href="#cb36-13"></a>    <span class="kw">using</span> index_type      <span class="op">=</span> std<span class="op">::</span><span class="dt">int_fast32_t</span>;</span>
<span id="cb36-14"><a href="#cb36-14"></a>    <span class="kw">using</span> size_type       <span class="op">=</span> std<span class="op">::</span><span class="dt">int_fast32_t</span>;</span>
<span id="cb36-15"><a href="#cb36-15"></a>    <span class="kw">using</span> size_tuple      <span class="op">=</span> std<span class="op">::</span>tuple<span class="op">&lt;</span>size_type, size_type<span class="op">&gt;</span>;</span>
<span id="cb36-16"><a href="#cb36-16"></a></span>
<span id="cb36-17"><a href="#cb36-17"></a>    <span class="kw">using</span> is_fixed_size   <span class="op">=</span> std<span class="op">::</span>true_type;</span>
<span id="cb36-18"><a href="#cb36-18"></a>    <span class="kw">using</span> is_resizable    <span class="op">=</span> std<span class="op">::</span>false_type;</span>
<span id="cb36-19"><a href="#cb36-19"></a></span>
<span id="cb36-20"><a href="#cb36-20"></a>    <span class="kw">using</span> is_column_major <span class="op">=</span> std<span class="op">::</span>false_type;</span>
<span id="cb36-21"><a href="#cb36-21"></a>    <span class="kw">using</span> is_dense        <span class="op">=</span> std<span class="op">::</span>true_type;</span>
<span id="cb36-22"><a href="#cb36-22"></a>    <span class="kw">using</span> is_rectangular  <span class="op">=</span> std<span class="op">::</span>true_type;</span>
<span id="cb36-23"><a href="#cb36-23"></a>    <span class="kw">using</span> is_row_major    <span class="op">=</span> std<span class="op">::</span>true_type;</span>
<span id="cb36-24"><a href="#cb36-24"></a></span>
<span id="cb36-25"><a href="#cb36-25"></a>    <span class="kw">using</span> column_view_type    <span class="op">=</span> std<span class="op">::</span>math<span class="op">::</span>matrix_column_view<span class="op">&lt;</span>fs_matrix_engine_tst<span class="op">&gt;</span>;</span>
<span id="cb36-26"><a href="#cb36-26"></a>    <span class="kw">using</span> row_view_type       <span class="op">=</span> std<span class="op">::</span>math<span class="op">::</span>matrix_row_view<span class="op">&lt;</span>fs_matrix_engine_tst<span class="op">&gt;</span>;</span>
<span id="cb36-27"><a href="#cb36-27"></a>    <span class="kw">using</span> transpose_view_type <span class="op">=</span> std<span class="op">::</span>math<span class="op">::</span>matrix_transpose_view<span class="op">&lt;</span>fs_matrix_engine_tst<span class="op">&gt;</span>;</span>
<span id="cb36-28"><a href="#cb36-28"></a></span>
<span id="cb36-29"><a href="#cb36-29"></a>  <span class="kw">public</span><span class="op">:</span></span>
<span id="cb36-30"><a href="#cb36-30"></a>    <span class="kw">constexpr</span> fs_matrix_engine_tst<span class="op">()</span>;</span>
<span id="cb36-31"><a href="#cb36-31"></a>    <span class="kw">constexpr</span> fs_matrix_engine_tst<span class="op">(</span>fs_matrix_engine_tst<span class="op">&amp;&amp;)</span> <span class="op">=</span> <span class="cf">default</span>;</span>
<span id="cb36-32"><a href="#cb36-32"></a>    <span class="kw">constexpr</span> fs_matrix_engine_tst<span class="op">(</span>fs_matrix_engine_tst <span class="kw">const</span><span class="op">&amp;)</span> <span class="op">=</span> <span class="cf">default</span>;</span>
<span id="cb36-33"><a href="#cb36-33"></a></span>
<span id="cb36-34"><a href="#cb36-34"></a>    <span class="kw">constexpr</span> fs_matrix_engine_tst<span class="op">&amp;</span>     <span class="kw">operator</span> <span class="op">=(</span>fs_matrix_engine_tst<span class="op">&amp;&amp;)</span> <span class="op">=</span> <span class="cf">default</span>;</span>
<span id="cb36-35"><a href="#cb36-35"></a>    <span class="kw">constexpr</span> fs_matrix_engine_tst<span class="op">&amp;</span>     <span class="kw">operator</span> <span class="op">=(</span>fs_matrix_engine_tst <span class="kw">const</span><span class="op">&amp;)</span> <span class="op">=</span> <span class="cf">default</span>;</span>
<span id="cb36-36"><a href="#cb36-36"></a></span>
<span id="cb36-37"><a href="#cb36-37"></a>    <span class="kw">constexpr</span> const_reference   <span class="kw">operator</span> <span class="op">()(</span>index_type i, index_type j<span class="op">)</span> <span class="kw">const</span>;</span>
<span id="cb36-38"><a href="#cb36-38"></a></span>
<span id="cb36-39"><a href="#cb36-39"></a>    <span class="kw">constexpr</span> index_type    columns<span class="op">()</span> <span class="kw">const</span> <span class="kw">noexcept</span>;</span>
<span id="cb36-40"><a href="#cb36-40"></a>    <span class="kw">constexpr</span> index_type    rows<span class="op">()</span> <span class="kw">const</span> <span class="kw">noexcept</span>;</span>
<span id="cb36-41"><a href="#cb36-41"></a>    <span class="kw">constexpr</span> size_tuple    size<span class="op">()</span> <span class="kw">const</span> <span class="kw">noexcept</span>;</span>
<span id="cb36-42"><a href="#cb36-42"></a></span>
<span id="cb36-43"><a href="#cb36-43"></a>    <span class="kw">constexpr</span> size_type     column_capacity<span class="op">()</span> <span class="kw">const</span> <span class="kw">noexcept</span>;</span>
<span id="cb36-44"><a href="#cb36-44"></a>    <span class="kw">constexpr</span> size_type     row_capacity<span class="op">()</span> <span class="kw">const</span> <span class="kw">noexcept</span>;</span>
<span id="cb36-45"><a href="#cb36-45"></a>    <span class="kw">constexpr</span> size_tuple    capacity<span class="op">()</span> <span class="kw">const</span> <span class="kw">noexcept</span>;</span>
<span id="cb36-46"><a href="#cb36-46"></a></span>
<span id="cb36-47"><a href="#cb36-47"></a>    <span class="kw">constexpr</span> reference     <span class="kw">operator</span> <span class="op">()(</span>index_type i, index_type j<span class="op">)</span>;</span>
<span id="cb36-48"><a href="#cb36-48"></a></span>
<span id="cb36-49"><a href="#cb36-49"></a>    <span class="kw">constexpr</span> <span class="dt">void</span>      assign<span class="op">(</span>fs_matrix_engine_tst <span class="kw">const</span><span class="op">&amp;</span> rhs<span class="op">)</span>;</span>
<span id="cb36-50"><a href="#cb36-50"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> ET2<span class="op">&gt;</span></span>
<span id="cb36-51"><a href="#cb36-51"></a>    <span class="kw">constexpr</span> <span class="dt">void</span>      assign<span class="op">(</span>ET2 <span class="kw">const</span><span class="op">&amp;</span> rhs<span class="op">)</span>;</span>
<span id="cb36-52"><a href="#cb36-52"></a></span>
<span id="cb36-53"><a href="#cb36-53"></a>    <span class="kw">constexpr</span> <span class="dt">void</span>      swap<span class="op">(</span>fs_matrix_engine_tst<span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">noexcept</span>;</span>
<span id="cb36-54"><a href="#cb36-54"></a>    <span class="kw">constexpr</span> <span class="dt">void</span>      swap_columns<span class="op">(</span>index_type j1, index_type j2<span class="op">)</span>;</span>
<span id="cb36-55"><a href="#cb36-55"></a>    <span class="kw">constexpr</span> <span class="dt">void</span>      swap_rows<span class="op">(</span>index_type i1, index_type i2<span class="op">)</span>;</span>
<span id="cb36-56"><a href="#cb36-56"></a></span>
<span id="cb36-57"><a href="#cb36-57"></a>  <span class="kw">private</span><span class="op">:</span></span>
<span id="cb36-58"><a href="#cb36-58"></a>    <span class="op">...</span>         <span class="co">//- Implementation stuff</span></span>
<span id="cb36-59"><a href="#cb36-59"></a><span class="op">}</span>;</span></code></pre></div>
<p>For each arithmetic operation in which you expect the new engine type to be involved, you will need to provide a specialization of the engine promotion traits for that operation. For example, let’s assume that you’re only interested in addition operations involving two operands having the new engine type, or where one operand has the standard fixed-size engine and the other has the new engine. Then your engine promotion traits might look like this:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb37-1"><a href="#cb37-1"></a>//- Goal: Create a new fixed-size engine type and use it in arithmetic expressions.</span>
<span id="cb37-2"><a href="#cb37-2"></a>//</span>
<span id="cb37-3"><a href="#cb37-3"></a>template&lt;class OT, class ET1, class ET2&gt;</span>
<span id="cb37-4"><a href="#cb37-4"></a>struct engine_add_traits_tst;</span>
<span id="cb37-5"><a href="#cb37-5"></a></span>
<span id="cb37-6"><a href="#cb37-6"></a>template&lt;class OT, class T1, int32_t R1, int32_t C1, class T2, int32_t R2, int32_t C2&gt;</span>
<span id="cb37-7"><a href="#cb37-7"></a>struct engine_add_traits_tst&lt;OT,</span>
<span id="cb37-8"><a href="#cb37-8"></a>                             fs_matrix_engine_tst&lt;T1, R1, C1&gt;,</span>
<span id="cb37-9"><a href="#cb37-9"></a>                             fs_matrix_engine_tst&lt;T2, R2, C2&gt;&gt;</span>
<span id="cb37-10"><a href="#cb37-10"></a>{</span>
<span id="cb37-11"><a href="#cb37-11"></a>    using element_type = std::math::matrix_addition_element_t&lt;OT, T1, T2&gt;;</span>
<span id="cb37-12"><a href="#cb37-12"></a>    using engine_type  = fs_matrix_engine_tst&lt;element_type, R1, C1&gt;;</span>
<span id="cb37-13"><a href="#cb37-13"></a>};</span>
<span id="cb37-14"><a href="#cb37-14"></a></span>
<span id="cb37-15"><a href="#cb37-15"></a>template&lt;class OT, class T1, int32_t R1, int32_t C1, class T2, int32_t R2, int32_t C2&gt;</span>
<span id="cb37-16"><a href="#cb37-16"></a>struct engine_add_traits_tst&lt;OT,</span>
<span id="cb37-17"><a href="#cb37-17"></a>                             fs_matrix_engine_tst&lt;T1, R1, C1&gt;,</span>
<span id="cb37-18"><a href="#cb37-18"></a>                             std::math::fs_matrix_engine&lt;T2, R2, C2&gt;&gt;</span>
<span id="cb37-19"><a href="#cb37-19"></a>{</span>
<span id="cb37-20"><a href="#cb37-20"></a>    using element_type = std::math::matrix_addition_element_t&lt;OT, T1, T2&gt;;</span>
<span id="cb37-21"><a href="#cb37-21"></a>    using engine_type  = fs_matrix_engine_tst&lt;element_type, R1, C1&gt;;</span>
<span id="cb37-22"><a href="#cb37-22"></a>};</span>
<span id="cb37-23"><a href="#cb37-23"></a></span>
<span id="cb37-24"><a href="#cb37-24"></a>template&lt;class OT, class T1, int32_t R1, int32_t C1, class T2, int32_t R2, int32_t C2&gt;</span>
<span id="cb37-25"><a href="#cb37-25"></a>struct engine_add_traits_tst&lt;OT,</span>
<span id="cb37-26"><a href="#cb37-26"></a>                             std::math::fs_matrix_engine&lt;T1, R1, C1&gt;,</span>
<span id="cb37-27"><a href="#cb37-27"></a>                             fs_matrix_engine_tst&lt;T2, R2, C2&gt;&gt;</span>
<span id="cb37-28"><a href="#cb37-28"></a>{</span>
<span id="cb37-29"><a href="#cb37-29"></a>    using element_type = std::math::matrix_addition_element_t&lt;OT, T1, T2&gt;;</span>
<span id="cb37-30"><a href="#cb37-30"></a>    using engine_type   = fs_matrix_engine_tst&lt;element_type, R1, C1&gt;;</span>
<span id="cb37-31"><a href="#cb37-31"></a>};</span>
<span id="cb37-32"><a href="#cb37-32"></a></span>
<span id="cb37-33"><a href="#cb37-33"></a>//- This is a custom operation traits type!</span>
<span id="cb37-34"><a href="#cb37-34"></a>//</span>
<span id="cb37-35"><a href="#cb37-35"></a>struct add_op_traits_tst</span>
<span id="cb37-36"><a href="#cb37-36"></a>{</span>
<span id="cb37-37"><a href="#cb37-37"></a>    template&lt;class T1, class T2&gt;</span>
<span id="cb37-38"><a href="#cb37-38"></a>    using element_addition_traits = element_add_traits_tst&lt;T1, T2&gt;;</span>
<span id="cb37-39"><a href="#cb37-39"></a></span>
<span id="cb37-40"><a href="#cb37-40"></a>    template&lt;class T1, class T2&gt;</span>
<span id="cb37-41"><a href="#cb37-41"></a>    using engine_addition_traits = engine_add_traits_tst&lt;T1, T2&gt;;</span>
<span id="cb37-42"><a href="#cb37-42"></a>};</span></code></pre></div>
<p>As we can see, these custom promotion traits dictate the resulting engine type for these particular cases. Resulting usage might look like this:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb38-1"><a href="#cb38-1"></a>matrix<span class="op">&lt;</span>fs_matrix_engine<span class="op">&lt;</span><span class="dt">float</span>, <span class="dv">2</span>, <span class="dv">3</span><span class="op">&gt;</span>, matrix_operation_traits<span class="op">&gt;</span>              m1;</span>
<span id="cb38-2"><a href="#cb38-2"></a>matrix<span class="op">&lt;</span>fs_matrix_engine_tst<span class="op">&lt;</span><span class="dt">float</span>, <span class="dv">2</span>, <span class="dv">3</span><span class="op">&gt;</span>, add_op_traits_tst<span class="op">&gt;</span>                m2;</span>
<span id="cb38-3"><a href="#cb38-3"></a>matrix<span class="op">&lt;</span>dr_matrix_engine<span class="op">&lt;</span><span class="dt">float</span>, allocator<span class="op">&lt;</span><span class="dt">float</span><span class="op">&gt;&gt;</span>, matrix_operation_traits<span class="op">&gt;</span>  m3<span class="op">(</span><span class="dv">2</span>, <span class="dv">3</span><span class="op">)</span>;</span>
<span id="cb38-4"><a href="#cb38-4"></a></span>
<span id="cb38-5"><a href="#cb38-5"></a><span class="co">//- mr1 --&gt; matrix&lt;fs_matrix_engine&lt;float, 2, 3&gt;, matrix_operation_traits&gt;</span></span>
<span id="cb38-6"><a href="#cb38-6"></a><span class="co">//</span></span>
<span id="cb38-7"><a href="#cb38-7"></a><span class="kw">auto</span>    mr1 <span class="op">=</span> m1 <span class="op">+</span> m1;</span>
<span id="cb38-8"><a href="#cb38-8"></a></span>
<span id="cb38-9"><a href="#cb38-9"></a><span class="co">//- mr2 --&gt; matrix&lt;fs_matrix_engine_tst&lt;double, 2, 3&gt;, add_op_traits_tst&gt;</span></span>
<span id="cb38-10"><a href="#cb38-10"></a><span class="co">//</span></span>
<span id="cb38-11"><a href="#cb38-11"></a><span class="kw">auto</span>    mr2 <span class="op">=</span> m2 <span class="op">+</span> m2;</span>
<span id="cb38-12"><a href="#cb38-12"></a></span>
<span id="cb38-13"><a href="#cb38-13"></a><span class="co">//- mr3 --&gt; matrix&lt;fs_matrix_engine_tst&lt;double, 2, 3&gt;, add_op_traits_tst&gt;</span></span>
<span id="cb38-14"><a href="#cb38-14"></a><span class="co">//</span></span>
<span id="cb38-15"><a href="#cb38-15"></a><span class="kw">auto</span>    mr3 <span class="op">=</span> m1 <span class="op">+</span> m2;</span>
<span id="cb38-16"><a href="#cb38-16"></a></span>
<span id="cb38-17"><a href="#cb38-17"></a><span class="co">//- mr4 --&gt; matrix&lt;dr_matrix_engine&lt;double, allocator&lt;double&gt;&gt;, add_op_traits_tst&gt;</span></span>
<span id="cb38-18"><a href="#cb38-18"></a><span class="co">//</span></span>
<span id="cb38-19"><a href="#cb38-19"></a><span class="kw">auto</span>    mr4 <span class="op">=</span> m1 <span class="op">+</span> m3;</span></code></pre></div>
<p>Note that this example also assumes that an addition operation involving a fixed-size matrix and a dynamically-resizable matrix, or two dynamically-resizable matrices results in a dynamically-resizable matrix.</p>
<h2 id="customizing-an-arithmetic-operation"><span class="header-section-number">7.4</span> Customizing an arithmetic operation<a href="#customizing-an-arithmetic-operation" class="self-link"></a></h2>
<p>Suppose that you want to specialize the addition function for the addition of two matrices that employ the custom engine above and whose sizes happen to be 3x4.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb39-1"><a href="#cb39-1"></a><span class="co">//- Goal: Call a specialized addition function for addition of fixed-size matrix objects</span></span>
<span id="cb39-2"><a href="#cb39-2"></a><span class="co">// using the fixed-size test engine and having size 3x4.</span></span>
<span id="cb39-3"><a href="#cb39-3"></a><span class="co">//</span></span>
<span id="cb39-4"><a href="#cb39-4"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> OT, <span class="kw">class</span> OP1, <span class="kw">class</span> OP2<span class="op">&gt;</span></span>
<span id="cb39-5"><a href="#cb39-5"></a><span class="kw">struct</span> addition_traits_tst;</span>
<span id="cb39-6"><a href="#cb39-6"></a></span>
<span id="cb39-7"><a href="#cb39-7"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> OT<span class="op">&gt;</span></span>
<span id="cb39-8"><a href="#cb39-8"></a><span class="kw">struct</span> addition_traits_tst<span class="op">&lt;</span>OT,</span>
<span id="cb39-9"><a href="#cb39-9"></a>                           matrix<span class="op">&lt;</span>fs_matrix_engine_tst<span class="op">&lt;</span><span class="dt">double</span>, <span class="dv">3</span>, <span class="dv">4</span><span class="op">&gt;</span>, OT<span class="op">&gt;</span>,</span>
<span id="cb39-10"><a href="#cb39-10"></a>                           matrix<span class="op">&lt;</span>fs_matrix_engine_tst<span class="op">&lt;</span><span class="dt">double</span>, <span class="dv">3</span>, <span class="dv">4</span><span class="op">&gt;</span>, OT<span class="op">&gt;&gt;</span></span>
<span id="cb39-11"><a href="#cb39-11"></a><span class="op">{</span></span>
<span id="cb39-12"><a href="#cb39-12"></a>    <span class="kw">using</span> op_traits <span class="op">=</span> OT;</span>
<span id="cb39-13"><a href="#cb39-13"></a>    <span class="kw">using</span> engine_type <span class="op">=</span> fs_matrix_engine_tst<span class="op">&lt;</span><span class="dt">double</span>, <span class="dv">3</span>, <span class="dv">4</span><span class="op">&gt;</span>;</span>
<span id="cb39-14"><a href="#cb39-14"></a>    <span class="kw">using</span> result_type <span class="op">=</span> matrix<span class="op">&lt;</span>engine_type, op_traits<span class="op">&gt;</span>;</span>
<span id="cb39-15"><a href="#cb39-15"></a></span>
<span id="cb39-16"><a href="#cb39-16"></a>    <span class="kw">static</span> result_type  add<span class="op">(</span>matrix<span class="op">&lt;</span>fs_matrix_engine_tst<span class="op">&lt;</span><span class="dt">double</span>, <span class="dv">3</span>, <span class="dv">4</span><span class="op">&gt;</span>, OT<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> m1,</span>
<span id="cb39-17"><a href="#cb39-17"></a>                            matrix<span class="op">&lt;</span>fs_matrix_engine_tst<span class="op">&lt;</span><span class="dt">double</span>, <span class="dv">3</span>, <span class="dv">4</span><span class="op">&gt;</span>, OT<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> m2<span class="op">)</span>;</span>
<span id="cb39-18"><a href="#cb39-18"></a><span class="op">}</span>;</span>
<span id="cb39-19"><a href="#cb39-19"></a></span>
<span id="cb39-20"><a href="#cb39-20"></a><span class="co">//- This is a custom operation traits type!</span></span>
<span id="cb39-21"><a href="#cb39-21"></a><span class="co">//</span></span>
<span id="cb39-22"><a href="#cb39-22"></a><span class="kw">struct</span> test_add_op_traits_tst</span>
<span id="cb39-23"><a href="#cb39-23"></a><span class="op">{</span></span>
<span id="cb39-24"><a href="#cb39-24"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T1, <span class="kw">class</span> T2<span class="op">&gt;</span></span>
<span id="cb39-25"><a href="#cb39-25"></a>    <span class="kw">using</span> element_addition_traits <span class="op">=</span> element_add_traits_tst<span class="op">&lt;</span>T1, T2<span class="op">&gt;</span>;</span>
<span id="cb39-26"><a href="#cb39-26"></a></span>
<span id="cb39-27"><a href="#cb39-27"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> OT, <span class="kw">class</span> ET1, <span class="kw">class</span> ET2<span class="op">&gt;</span></span>
<span id="cb39-28"><a href="#cb39-28"></a>    <span class="kw">using</span> engine_addition_traits <span class="op">=</span> engine_add_traits_tst<span class="op">&lt;</span>OT, ET1, ET2<span class="op">&gt;</span>;</span>
<span id="cb39-29"><a href="#cb39-29"></a></span>
<span id="cb39-30"><a href="#cb39-30"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> OT, <span class="kw">class</span> OP1, <span class="kw">class</span> OP2<span class="op">&gt;</span></span>
<span id="cb39-31"><a href="#cb39-31"></a>    <span class="kw">using</span> addition_traits <span class="op">=</span> addition_traits_tst<span class="op">&lt;</span>OT, OP1, OP2<span class="op">&gt;</span>;</span>
<span id="cb39-32"><a href="#cb39-32"></a><span class="op">}</span>;</span></code></pre></div>
<p>Actual usage might look like this:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb40-1"><a href="#cb40-1"></a>matrix<span class="op">&lt;</span>fs_matrix_engine_tst<span class="op">&lt;</span><span class="dt">float</span>, <span class="dv">3</span>, <span class="dv">4</span><span class="op">&gt;</span>, add_op_traits_tst<span class="op">&gt;</span>    m1;</span>
<span id="cb40-2"><a href="#cb40-2"></a>matrix<span class="op">&lt;</span>fs_matrix_engine_tst<span class="op">&lt;</span><span class="dt">double</span>, <span class="dv">3</span>, <span class="dv">4</span><span class="op">&gt;</span>, add_op_traits_tst<span class="op">&gt;</span>   m2;</span>
<span id="cb40-3"><a href="#cb40-3"></a></span>
<span id="cb40-4"><a href="#cb40-4"></a><span class="co">//- mr1 --&gt; matrix&lt;fs_matrix_engine_tst&lt;double, 3, 4&gt;, add_op_traits_tst&gt;</span></span>
<span id="cb40-5"><a href="#cb40-5"></a><span class="co">//</span></span>
<span id="cb40-6"><a href="#cb40-6"></a><span class="kw">auto</span>    mr1 <span class="op">=</span> m1 <span class="op">+</span> m1;    <span class="co">//- Calls matrix_addition_traits::add()</span></span>
<span id="cb40-7"><a href="#cb40-7"></a></span>
<span id="cb40-8"><a href="#cb40-8"></a><span class="co">//- mr2 --&gt; matrix&lt;fs_matrix_engine_tst&lt;double, 3, 4&gt;, add_op_traits_tst&gt;</span></span>
<span id="cb40-9"><a href="#cb40-9"></a><span class="co">//</span></span>
<span id="cb40-10"><a href="#cb40-10"></a><span class="kw">auto</span>    mr2 <span class="op">=</span> m1 <span class="op">+</span> m2;    <span class="co">//- Calls matrix_addition_traits::add()</span></span>
<span id="cb40-11"><a href="#cb40-11"></a></span>
<span id="cb40-12"><a href="#cb40-12"></a><span class="co">//- mr3 --&gt; matrix&lt;fs_matrix_engine_tst&lt;double, 3, 4&gt;, add_op_traits_tst&gt;</span></span>
<span id="cb40-13"><a href="#cb40-13"></a><span class="co">//</span></span>
<span id="cb40-14"><a href="#cb40-14"></a><span class="kw">auto</span>    mr3 <span class="op">=</span> m2 <span class="op">+</span> m2;    <span class="co">//- Calls matrix_addition_traits_tst::add()</span></span></code></pre></div>
<h1 id="meeting-feedback"><span class="header-section-number">8</span> Meeting feedback<a href="#meeting-feedback" class="self-link"></a></h1>
<h2 id="cologne-2019"><span class="header-section-number">8.1</span> Cologne 2019<a href="#cologne-2019" class="self-link"></a></h2>
<p>At the Cologne 2019 meeting, a joint session of SG14, SG19, and SG6 was held on Friday 20-Jul-2019 and version R2 of this paper was presented. A vote was held in the afternoon, and the room reached consensus to forward P1385 to LEWG subject to reconciling implementation with P1673.</p>
<p>In the intervening months, the authors of P1673 have put together an initial implementation of the interface described therein, and provided it to the authors of this proposal. We are currently endeavoring to implement P1385 in terms of the interface expressed by P1673.</p>
<h2 id="kona-2019"><span class="header-section-number">8.2</span> Kona 2019<a href="#kona-2019" class="self-link"></a></h2>
<p>At the Kona 2019 meeting, draft version D1 of this paper was reviewed by LEWG(I) and a joint session of SG14 and SG19. Both reviews were generally positive, several good suggestions were made, and some polls regarding future directions were taken.</p>
<h3 id="lewgi-polls-and-feedback-wednesday-2019-02-20"><span class="header-section-number">8.2.1</span> LEWG(I) Polls and Feedback (Wednesday 2019-02-20)<a href="#lewgi-polls-and-feedback-wednesday-2019-02-20" class="self-link"></a></h3>
<p>There were a few polls taken in this session:</p>
<ol type="1">
<li><p>We want 0-based indexing as opposed to 1-based indexing. <br> (unanimous: 20)</p></li>
<li><p>We like having separate row_vector and column_vector types in addition to matrix. <br> SF F N A SA (21 present)<br> 3 0 5 4 4</p></li>
<li><p>We want explicitly named operations (e.g., dot and outer) in addition to operators. <br> SF F N A SA (21 present) <br> 8 5 2 1 0</p></li>
<li><p>Define engine/matrix classes in terms of mdspan + storage and mdspan concepts (e.g., extents), and expose an mdspan-esque interface. This implies that fs_ and dyn_ are combined into one template parametrized on extents (which are either static or dynamic). <br> SF F N A SA (22 present) <br> 6 2 7 0 0</p></li>
</ol>
<p>There were some additional requests:</p>
<ul>
<li><p>Provide some implementation and usage experience.</p></li>
<li><p>Provide a comparison with prior art.</p></li>
<li><p>Explore the re-usability of <code>mdspan</code> and <code>common_type</code>.</p></li>
<li><p>Be careful of allowing specializations of traits types that are part of namespace <code>std</code>; be consistent with other traits.</p></li>
</ul>
<h3 id="feedback-from-joint-sg14sg19-session-friday-2019-02-22"><span class="header-section-number">8.2.2</span> Feedback From Joint SG14/SG19 Session (Friday 2019-02-22)<a href="#feedback-from-joint-sg14sg19-session-friday-2019-02-22" class="self-link"></a></h3>
<ul>
<li><p>Stick to 0-based indexing, for compatibility with current practice, and also for performance reasons.</p></li>
<li><p>Provide a fixed-size engine whose memory is dynamically allocated.</p></li>
<li><p>In this session, there was very broad agreement that the one-vector approach advocated by LEWG(I) was the way to proceed.</p></li>
<li><p>Outer product computation is rare in practice, so, the vector-vector multiplication operator should return the inner product, and the outer product should be a named function.</p></li>
</ul>
<h3 id="other-suggestions-gathered-at-the-meeting"><span class="header-section-number">8.2.3</span> Other Suggestions Gathered at the Meeting<a href="#other-suggestions-gathered-at-the-meeting" class="self-link"></a></h3>
<ul>
<li><p>Experiment with executors for concurrent operations.</p></li>
<li><p>Include a “Gor table” (see <a href="http://wg21.link/p1362r0">P1362R0</a>, Section 4.4) showing feature levels and anticipated user sophistication for each.</p></li>
<li><p>Include tutorial material on how the library can be used and extended, with several illustrative examples.</p></li>
</ul>
</div>
</div>
</body>
</html>
